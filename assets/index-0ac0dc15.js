function d4(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in n)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s &&
            Object.defineProperty(
              n,
              r,
              s.get ? s : { enumerable: !0, get: () => i[r] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = t(r);
    fetch(r.href, s);
  }
})();
function VD(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var WD = { exports: {} },
  L_ = {},
  XD = { exports: {} },
  Yt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Dm = Symbol.for("react.element"),
  p4 = Symbol.for("react.portal"),
  m4 = Symbol.for("react.fragment"),
  g4 = Symbol.for("react.strict_mode"),
  v4 = Symbol.for("react.profiler"),
  y4 = Symbol.for("react.provider"),
  _4 = Symbol.for("react.context"),
  x4 = Symbol.for("react.forward_ref"),
  A4 = Symbol.for("react.suspense"),
  S4 = Symbol.for("react.memo"),
  M4 = Symbol.for("react.lazy"),
  ER = Symbol.iterator;
function w4(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (ER && n[ER]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var JD = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  jD = Object.assign,
  YD = {};
function Hh(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = YD),
    (this.updater = t || JD);
}
Hh.prototype.isReactComponent = {};
Hh.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
Hh.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function KD() {}
KD.prototype = Hh.prototype;
function nE(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = YD),
    (this.updater = t || JD);
}
var iE = (nE.prototype = new KD());
iE.constructor = nE;
jD(iE, Hh.prototype);
iE.isPureReactComponent = !0;
var TR = Array.isArray,
  QD = Object.prototype.hasOwnProperty,
  rE = { current: null },
  ZD = { key: !0, ref: !0, __self: !0, __source: !0 };
function qD(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      QD.call(e, i) && !ZD.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
    r.children = l;
  }
  if (n && n.defaultProps)
    for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: Dm,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: rE.current,
  };
}
function E4(n, e) {
  return {
    $$typeof: Dm,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function sE(n) {
  return typeof n == "object" && n !== null && n.$$typeof === Dm;
}
function T4(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var CR = /\/+/g;
function YA(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? T4("" + n.key)
    : e.toString(36);
}
function Tv(n, e, t, i, r) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case Dm:
          case p4:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (r = r(o)),
      (n = i === "" ? "." + YA(o, 0) : i),
      TR(r)
        ? ((t = ""),
          n != null && (t = n.replace(CR, "$&/") + "/"),
          Tv(r, e, t, "", function (u) {
            return u;
          }))
        : r != null &&
          (sE(r) &&
            (r = E4(
              r,
              t +
                (!r.key || (o && o.key === r.key)
                  ? ""
                  : ("" + r.key).replace(CR, "$&/") + "/") +
                n
            )),
          e.push(r)),
      1
    );
  if (((o = 0), (i = i === "" ? "." : i + ":"), TR(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var l = i + YA(s, a);
      o += Tv(s, e, t, l, r);
    }
  else if (((l = w4(n)), typeof l == "function"))
    for (n = l.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (l = i + YA(s, a++)), (o += Tv(s, e, t, l, r));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function Zg(n, e, t) {
  if (n == null) return n;
  var i = [],
    r = 0;
  return (
    Tv(n, i, "", "", function (s) {
      return e.call(t, s, r++);
    }),
    i
  );
}
function C4(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var Mr = { current: null },
  Cv = { transition: null },
  b4 = {
    ReactCurrentDispatcher: Mr,
    ReactCurrentBatchConfig: Cv,
    ReactCurrentOwner: rE,
  };
function $D() {
  throw Error("act(...) is not supported in production builds of React.");
}
Yt.Children = {
  map: Zg,
  forEach: function (n, e, t) {
    Zg(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      Zg(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      Zg(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!sE(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
Yt.Component = Hh;
Yt.Fragment = m4;
Yt.Profiler = v4;
Yt.PureComponent = nE;
Yt.StrictMode = g4;
Yt.Suspense = A4;
Yt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = b4;
Yt.act = $D;
Yt.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var i = jD({}, n.props),
    r = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = rE.current)),
      e.key !== void 0 && (r = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (l in e)
      QD.call(e, l) &&
        !ZD.hasOwnProperty(l) &&
        (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) i.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
    i.children = a;
  }
  return { $$typeof: Dm, type: n.type, key: r, ref: s, props: i, _owner: o };
};
Yt.createContext = function (n) {
  return (
    (n = {
      $$typeof: _4,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: y4, _context: n }),
    (n.Consumer = n)
  );
};
Yt.createElement = qD;
Yt.createFactory = function (n) {
  var e = qD.bind(null, n);
  return (e.type = n), e;
};
Yt.createRef = function () {
  return { current: null };
};
Yt.forwardRef = function (n) {
  return { $$typeof: x4, render: n };
};
Yt.isValidElement = sE;
Yt.lazy = function (n) {
  return { $$typeof: M4, _payload: { _status: -1, _result: n }, _init: C4 };
};
Yt.memo = function (n, e) {
  return { $$typeof: S4, type: n, compare: e === void 0 ? null : e };
};
Yt.startTransition = function (n) {
  var e = Cv.transition;
  Cv.transition = {};
  try {
    n();
  } finally {
    Cv.transition = e;
  }
};
Yt.unstable_act = $D;
Yt.useCallback = function (n, e) {
  return Mr.current.useCallback(n, e);
};
Yt.useContext = function (n) {
  return Mr.current.useContext(n);
};
Yt.useDebugValue = function () {};
Yt.useDeferredValue = function (n) {
  return Mr.current.useDeferredValue(n);
};
Yt.useEffect = function (n, e) {
  return Mr.current.useEffect(n, e);
};
Yt.useId = function () {
  return Mr.current.useId();
};
Yt.useImperativeHandle = function (n, e, t) {
  return Mr.current.useImperativeHandle(n, e, t);
};
Yt.useInsertionEffect = function (n, e) {
  return Mr.current.useInsertionEffect(n, e);
};
Yt.useLayoutEffect = function (n, e) {
  return Mr.current.useLayoutEffect(n, e);
};
Yt.useMemo = function (n, e) {
  return Mr.current.useMemo(n, e);
};
Yt.useReducer = function (n, e, t) {
  return Mr.current.useReducer(n, e, t);
};
Yt.useRef = function (n) {
  return Mr.current.useRef(n);
};
Yt.useState = function (n) {
  return Mr.current.useState(n);
};
Yt.useSyncExternalStore = function (n, e, t) {
  return Mr.current.useSyncExternalStore(n, e, t);
};
Yt.useTransition = function () {
  return Mr.current.useTransition();
};
Yt.version = "18.3.1";
XD.exports = Yt;
var j = XD.exports;
const zr = VD(j),
  R4 = d4({ __proto__: null, default: zr }, [j]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var P4 = j,
  B4 = Symbol.for("react.element"),
  I4 = Symbol.for("react.fragment"),
  D4 = Object.prototype.hasOwnProperty,
  L4 = P4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  F4 = { key: !0, ref: !0, __self: !0, __source: !0 };
function eL(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (i in e) D4.call(e, i) && !F4.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: B4,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: L4.current,
  };
}
L_.Fragment = I4;
L_.jsx = eL;
L_.jsxs = eL;
WD.exports = L_;
var oE = WD.exports;
const N4 = oE.Fragment,
  _e = oE.jsx,
  Dt = oE.jsxs;
var QS = {},
  tL = { exports: {} },
  Ms = {},
  nL = { exports: {} },
  iL = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(O, Y) {
    var F = O.length;
    O.push(Y);
    e: for (; 0 < F; ) {
      var se = (F - 1) >>> 1,
        Me = O[se];
      if (0 < r(Me, Y)) (O[se] = Y), (O[F] = Me), (F = se);
      else break e;
    }
  }
  function t(O) {
    return O.length === 0 ? null : O[0];
  }
  function i(O) {
    if (O.length === 0) return null;
    var Y = O[0],
      F = O.pop();
    if (F !== Y) {
      O[0] = F;
      e: for (var se = 0, Me = O.length, De = Me >>> 1; se < De; ) {
        var re = 2 * (se + 1) - 1,
          xe = O[re],
          Ce = re + 1,
          Se = O[Ce];
        if (0 > r(xe, F))
          Ce < Me && 0 > r(Se, xe)
            ? ((O[se] = Se), (O[Ce] = F), (se = Ce))
            : ((O[se] = xe), (O[re] = F), (se = re));
        else if (Ce < Me && 0 > r(Se, F)) (O[se] = Se), (O[Ce] = F), (se = Ce);
        else break e;
      }
    }
    return Y;
  }
  function r(O, Y) {
    var F = O.sortIndex - Y.sortIndex;
    return F !== 0 ? F : O.id - Y.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    u = [],
    c = 1,
    d = null,
    p = 3,
    m = !1,
    v = !1,
    _ = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    A = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(O) {
    for (var Y = t(u); Y !== null; ) {
      if (Y.callback === null) i(u);
      else if (Y.startTime <= O)
        i(u), (Y.sortIndex = Y.expirationTime), e(l, Y);
      else break;
      Y = t(u);
    }
  }
  function w(O) {
    if (((_ = !1), S(O), !v))
      if (t(l) !== null) (v = !0), K(C);
      else {
        var Y = t(u);
        Y !== null && te(w, Y.startTime - O);
      }
  }
  function C(O, Y) {
    (v = !1), _ && ((_ = !1), g(I), (I = -1)), (m = !0);
    var F = p;
    try {
      for (
        S(Y), d = t(l);
        d !== null && (!(d.expirationTime > Y) || (O && !D()));

      ) {
        var se = d.callback;
        if (typeof se == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var Me = se(d.expirationTime <= Y);
          (Y = n.unstable_now()),
            typeof Me == "function" ? (d.callback = Me) : d === t(l) && i(l),
            S(Y);
        } else i(l);
        d = t(l);
      }
      if (d !== null) var De = !0;
      else {
        var re = t(u);
        re !== null && te(w, re.startTime - Y), (De = !1);
      }
      return De;
    } finally {
      (d = null), (p = F), (m = !1);
    }
  }
  var b = !1,
    P = null,
    I = -1,
    R = 5,
    T = -1;
  function D() {
    return !(n.unstable_now() - T < R);
  }
  function G() {
    if (P !== null) {
      var O = n.unstable_now();
      T = O;
      var Y = !0;
      try {
        Y = P(!0, O);
      } finally {
        Y ? W() : ((b = !1), (P = null));
      }
    } else b = !1;
  }
  var W;
  if (typeof A == "function")
    W = function () {
      A(G);
    };
  else if (typeof MessageChannel < "u") {
    var q = new MessageChannel(),
      Z = q.port2;
    (q.port1.onmessage = G),
      (W = function () {
        Z.postMessage(null);
      });
  } else
    W = function () {
      x(G, 0);
    };
  function K(O) {
    (P = O), b || ((b = !0), W());
  }
  function te(O, Y) {
    I = x(function () {
      O(n.unstable_now());
    }, Y);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (O) {
      O.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      v || m || ((v = !0), K(C));
    }),
    (n.unstable_forceFrameRate = function (O) {
      0 > O || 125 < O
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < O ? Math.floor(1e3 / O) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (O) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var Y = 3;
          break;
        default:
          Y = p;
      }
      var F = p;
      p = Y;
      try {
        return O();
      } finally {
        p = F;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (O, Y) {
      switch (O) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          O = 3;
      }
      var F = p;
      p = O;
      try {
        return Y();
      } finally {
        p = F;
      }
    }),
    (n.unstable_scheduleCallback = function (O, Y, F) {
      var se = n.unstable_now();
      switch (
        (typeof F == "object" && F !== null
          ? ((F = F.delay), (F = typeof F == "number" && 0 < F ? se + F : se))
          : (F = se),
        O)
      ) {
        case 1:
          var Me = -1;
          break;
        case 2:
          Me = 250;
          break;
        case 5:
          Me = 1073741823;
          break;
        case 4:
          Me = 1e4;
          break;
        default:
          Me = 5e3;
      }
      return (
        (Me = F + Me),
        (O = {
          id: c++,
          callback: Y,
          priorityLevel: O,
          startTime: F,
          expirationTime: Me,
          sortIndex: -1,
        }),
        F > se
          ? ((O.sortIndex = F),
            e(u, O),
            t(l) === null &&
              O === t(u) &&
              (_ ? (g(I), (I = -1)) : (_ = !0), te(w, F - se)))
          : ((O.sortIndex = Me), e(l, O), v || m || ((v = !0), K(C))),
        O
      );
    }),
    (n.unstable_shouldYield = D),
    (n.unstable_wrapCallback = function (O) {
      var Y = p;
      return function () {
        var F = p;
        p = Y;
        try {
          return O.apply(this, arguments);
        } finally {
          p = F;
        }
      };
    });
})(iL);
nL.exports = iL;
var O4 = nL.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var U4 = j,
  vs = O4;
function Be(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var rL = new Set(),
  Gp = {};
function Dc(n, e) {
  vh(n, e), vh(n + "Capture", e);
}
function vh(n, e) {
  for (Gp[n] = e, n = 0; n < e.length; n++) rL.add(e[n]);
}
var Da = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  ZS = Object.prototype.hasOwnProperty,
  k4 =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  bR = {},
  RR = {};
function z4(n) {
  return ZS.call(RR, n)
    ? !0
    : ZS.call(bR, n)
    ? !1
    : k4.test(n)
    ? (RR[n] = !0)
    : ((bR[n] = !0), !1);
}
function H4(n, e, t, i) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function G4(n, e, t, i) {
  if (e === null || typeof e > "u" || H4(n, e, t, i)) return !0;
  if (i) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function wr(n, e, t, i, r, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var Ui = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    Ui[n] = new wr(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  Ui[e] = new wr(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  Ui[n] = new wr(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  Ui[n] = new wr(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    Ui[n] = new wr(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  Ui[n] = new wr(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  Ui[n] = new wr(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  Ui[n] = new wr(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  Ui[n] = new wr(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var aE = /[\-:]([a-z])/g;
function lE(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(aE, lE);
    Ui[e] = new wr(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(aE, lE);
    Ui[e] = new wr(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(aE, lE);
  Ui[e] = new wr(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  Ui[n] = new wr(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
Ui.xlinkHref = new wr(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  Ui[n] = new wr(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function uE(n, e, t, i) {
  var r = Ui.hasOwnProperty(e) ? Ui[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (G4(e, t, r, i) && (t = null),
    i || r === null
      ? z4(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : r.mustUseProperty
      ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : "") : t)
      : ((e = r.attributeName),
        (i = r.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((r = r.type),
            (t = r === 3 || (r === 4 && t === !0) ? "" : "" + t),
            i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var Va = U4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  qg = Symbol.for("react.element"),
  If = Symbol.for("react.portal"),
  Df = Symbol.for("react.fragment"),
  cE = Symbol.for("react.strict_mode"),
  qS = Symbol.for("react.profiler"),
  sL = Symbol.for("react.provider"),
  oL = Symbol.for("react.context"),
  fE = Symbol.for("react.forward_ref"),
  $S = Symbol.for("react.suspense"),
  eM = Symbol.for("react.suspense_list"),
  hE = Symbol.for("react.memo"),
  fl = Symbol.for("react.lazy"),
  aL = Symbol.for("react.offscreen"),
  PR = Symbol.iterator;
function gd(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (PR && n[PR]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var kn = Object.assign,
  KA;
function Jd(n) {
  if (KA === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      KA = (e && e[1]) || "";
    }
  return (
    `
` +
    KA +
    n
  );
}
var QA = !1;
function ZA(n, e) {
  if (!n || QA) return "";
  QA = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (u) {
          var i = u;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (u) {
          i = u;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (u) {
        i = u;
      }
      n();
    }
  } catch (u) {
    if (u && i && typeof u.stack == "string") {
      for (
        var r = u.stack.split(`
`),
          s = i.stack.split(`
`),
          o = r.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && r[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (r[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || r[o] !== s[a])) {
                var l =
                  `
` + r[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", n.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (QA = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? Jd(n) : "";
}
function V4(n) {
  switch (n.tag) {
    case 5:
      return Jd(n.type);
    case 16:
      return Jd("Lazy");
    case 13:
      return Jd("Suspense");
    case 19:
      return Jd("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = ZA(n.type, !1)), n;
    case 11:
      return (n = ZA(n.type.render, !1)), n;
    case 1:
      return (n = ZA(n.type, !0)), n;
    default:
      return "";
  }
}
function tM(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case Df:
      return "Fragment";
    case If:
      return "Portal";
    case qS:
      return "Profiler";
    case cE:
      return "StrictMode";
    case $S:
      return "Suspense";
    case eM:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case oL:
        return (n.displayName || "Context") + ".Consumer";
      case sL:
        return (n._context.displayName || "Context") + ".Provider";
      case fE:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case hE:
        return (
          (e = n.displayName || null), e !== null ? e : tM(n.type) || "Memo"
        );
      case fl:
        (e = n._payload), (n = n._init);
        try {
          return tM(n(e));
        } catch {}
    }
  return null;
}
function W4(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return tM(e);
    case 8:
      return e === cE ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Ol(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function lL(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function X4(n) {
  var e = lL(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    i = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var r = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (o) {
          (i = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (o) {
          i = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function $g(n) {
  n._valueTracker || (n._valueTracker = X4(n));
}
function uL(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    i = "";
  return (
    n && (i = lL(n) ? (n.checked ? "true" : "false") : n.value),
    (n = i),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function qv(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function nM(n, e) {
  var t = e.checked;
  return kn({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function BR(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (t = Ol(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: i,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function cL(n, e) {
  (e = e.checked), e != null && uE(n, "checked", e, !1);
}
function iM(n, e) {
  cL(n, e);
  var t = Ol(e.value),
    i = e.type;
  if (t != null)
    i === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? rM(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && rM(n, e.type, Ol(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function IR(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function rM(n, e, t) {
  (e !== "number" || qv(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var jd = Array.isArray;
function th(n, e, t, i) {
  if (((n = n.options), e)) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      (r = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== r && (n[t].selected = r),
        r && i && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + Ol(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        (n[r].selected = !0), i && (n[r].defaultSelected = !0);
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function sM(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Be(91));
  return kn({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function DR(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(Be(92));
      if (jd(t)) {
        if (1 < t.length) throw Error(Be(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: Ol(t) };
}
function fL(n, e) {
  var t = Ol(e.value),
    i = Ol(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i);
}
function LR(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function hL(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function oM(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? hL(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var e0,
  dL = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, i, r);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        e0 = e0 || document.createElement("div"),
          e0.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = e0.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function Vp(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var op = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  J4 = ["Webkit", "ms", "Moz", "O"];
Object.keys(op).forEach(function (n) {
  J4.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (op[e] = op[n]);
  });
});
function pL(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (op.hasOwnProperty(n) && op[n])
    ? ("" + e).trim()
    : e + "px";
}
function mL(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0,
        r = pL(t, e[t], i);
      t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : (n[t] = r);
    }
}
var j4 = kn(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function aM(n, e) {
  if (e) {
    if (j4[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Be(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Be(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(Be(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Be(62));
  }
}
function lM(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var uM = null;
function dE(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var cM = null,
  nh = null,
  ih = null;
function FR(n) {
  if ((n = Nm(n))) {
    if (typeof cM != "function") throw Error(Be(280));
    var e = n.stateNode;
    e && ((e = k_(e)), cM(n.stateNode, n.type, e));
  }
}
function gL(n) {
  nh ? (ih ? ih.push(n) : (ih = [n])) : (nh = n);
}
function vL() {
  if (nh) {
    var n = nh,
      e = ih;
    if (((ih = nh = null), FR(n), e)) for (n = 0; n < e.length; n++) FR(e[n]);
  }
}
function yL(n, e) {
  return n(e);
}
function _L() {}
var qA = !1;
function xL(n, e, t) {
  if (qA) return n(e, t);
  qA = !0;
  try {
    return yL(n, e, t);
  } finally {
    (qA = !1), (nh !== null || ih !== null) && (_L(), vL());
  }
}
function Wp(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var i = k_(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((n = n.type),
        (i = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !i);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(Be(231, e, typeof t));
  return t;
}
var fM = !1;
if (Da)
  try {
    var vd = {};
    Object.defineProperty(vd, "passive", {
      get: function () {
        fM = !0;
      },
    }),
      window.addEventListener("test", vd, vd),
      window.removeEventListener("test", vd, vd);
  } catch {
    fM = !1;
  }
function Y4(n, e, t, i, r, s, o, a, l) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, u);
  } catch (c) {
    this.onError(c);
  }
}
var ap = !1,
  $v = null,
  ey = !1,
  hM = null,
  K4 = {
    onError: function (n) {
      (ap = !0), ($v = n);
    },
  };
function Q4(n, e, t, i, r, s, o, a, l) {
  (ap = !1), ($v = null), Y4.apply(K4, arguments);
}
function Z4(n, e, t, i, r, s, o, a, l) {
  if ((Q4.apply(this, arguments), ap)) {
    if (ap) {
      var u = $v;
      (ap = !1), ($v = null);
    } else throw Error(Be(198));
    ey || ((ey = !0), (hM = u));
  }
}
function Lc(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function AL(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function NR(n) {
  if (Lc(n) !== n) throw Error(Be(188));
}
function q4(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = Lc(n)), e === null)) throw Error(Be(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return NR(r), n;
        if (s === i) return NR(r), e;
        s = s.sibling;
      }
      throw Error(Be(188));
    }
    if (t.return !== i.return) (t = r), (i = s);
    else {
      for (var o = !1, a = r.child; a; ) {
        if (a === t) {
          (o = !0), (t = r), (i = s);
          break;
        }
        if (a === i) {
          (o = !0), (i = r), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (i = r);
            break;
          }
          if (a === i) {
            (o = !0), (i = s), (t = r);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(Be(189));
      }
    }
    if (t.alternate !== i) throw Error(Be(190));
  }
  if (t.tag !== 3) throw Error(Be(188));
  return t.stateNode.current === t ? n : e;
}
function SL(n) {
  return (n = q4(n)), n !== null ? ML(n) : null;
}
function ML(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = ML(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var wL = vs.unstable_scheduleCallback,
  OR = vs.unstable_cancelCallback,
  $4 = vs.unstable_shouldYield,
  eH = vs.unstable_requestPaint,
  Qn = vs.unstable_now,
  tH = vs.unstable_getCurrentPriorityLevel,
  pE = vs.unstable_ImmediatePriority,
  EL = vs.unstable_UserBlockingPriority,
  ty = vs.unstable_NormalPriority,
  nH = vs.unstable_LowPriority,
  TL = vs.unstable_IdlePriority,
  F_ = null,
  Ho = null;
function iH(n) {
  if (Ho && typeof Ho.onCommitFiberRoot == "function")
    try {
      Ho.onCommitFiberRoot(F_, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var mo = Math.clz32 ? Math.clz32 : oH,
  rH = Math.log,
  sH = Math.LN2;
function oH(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((rH(n) / sH) | 0)) | 0;
}
var t0 = 64,
  n0 = 4194304;
function Yd(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function ny(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var i = 0,
    r = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? (i = Yd(a)) : ((s &= o), s !== 0 && (i = Yd(s)));
  } else (o = t & ~r), o !== 0 ? (i = Yd(o)) : s !== 0 && (i = Yd(s));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= i; 0 < e; )
      (t = 31 - mo(e)), (r = 1 << t), (i |= n[t]), (e &= ~r);
  return i;
}
function aH(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function lH(n, e) {
  for (
    var t = n.suspendedLanes,
      i = n.pingedLanes,
      r = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - mo(s),
      a = 1 << o,
      l = r[o];
    l === -1
      ? (!(a & t) || a & i) && (r[o] = aH(a, e))
      : l <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function dM(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function CL() {
  var n = t0;
  return (t0 <<= 1), !(t0 & 4194240) && (t0 = 64), n;
}
function $A(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function Lm(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - mo(e)),
    (n[e] = t);
}
function uH(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - mo(t),
      s = 1 << r;
    (e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~s);
  }
}
function mE(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var i = 31 - mo(t),
      r = 1 << i;
    (r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r);
  }
}
var mn = 0;
function bL(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var RL,
  gE,
  PL,
  BL,
  IL,
  pM = !1,
  i0 = [],
  wl = null,
  El = null,
  Tl = null,
  Xp = new Map(),
  Jp = new Map(),
  pl = [],
  cH =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function UR(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      wl = null;
      break;
    case "dragenter":
    case "dragleave":
      El = null;
      break;
    case "mouseover":
    case "mouseout":
      Tl = null;
      break;
    case "pointerover":
    case "pointerout":
      Xp.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Jp.delete(e.pointerId);
  }
}
function yd(n, e, t, i, r, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = Nm(e)), e !== null && gE(e)),
      n)
    : ((n.eventSystemFlags |= i),
      (e = n.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      n);
}
function fH(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return (wl = yd(wl, n, e, t, i, r)), !0;
    case "dragenter":
      return (El = yd(El, n, e, t, i, r)), !0;
    case "mouseover":
      return (Tl = yd(Tl, n, e, t, i, r)), !0;
    case "pointerover":
      var s = r.pointerId;
      return Xp.set(s, yd(Xp.get(s) || null, n, e, t, i, r)), !0;
    case "gotpointercapture":
      return (
        (s = r.pointerId), Jp.set(s, yd(Jp.get(s) || null, n, e, t, i, r)), !0
      );
  }
  return !1;
}
function DL(n) {
  var e = zu(n.target);
  if (e !== null) {
    var t = Lc(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = AL(t)), e !== null)) {
          (n.blockedOn = e),
            IL(n.priority, function () {
              PL(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function bv(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = mM(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      (uM = i), t.target.dispatchEvent(i), (uM = null);
    } else return (e = Nm(t)), e !== null && gE(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function kR(n, e, t) {
  bv(n) && t.delete(e);
}
function hH() {
  (pM = !1),
    wl !== null && bv(wl) && (wl = null),
    El !== null && bv(El) && (El = null),
    Tl !== null && bv(Tl) && (Tl = null),
    Xp.forEach(kR),
    Jp.forEach(kR);
}
function _d(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    pM ||
      ((pM = !0),
      vs.unstable_scheduleCallback(vs.unstable_NormalPriority, hH)));
}
function jp(n) {
  function e(r) {
    return _d(r, n);
  }
  if (0 < i0.length) {
    _d(i0[0], n);
    for (var t = 1; t < i0.length; t++) {
      var i = i0[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (
    wl !== null && _d(wl, n),
      El !== null && _d(El, n),
      Tl !== null && _d(Tl, n),
      Xp.forEach(e),
      Jp.forEach(e),
      t = 0;
    t < pl.length;
    t++
  )
    (i = pl[t]), i.blockedOn === n && (i.blockedOn = null);
  for (; 0 < pl.length && ((t = pl[0]), t.blockedOn === null); )
    DL(t), t.blockedOn === null && pl.shift();
}
var rh = Va.ReactCurrentBatchConfig,
  iy = !0;
function dH(n, e, t, i) {
  var r = mn,
    s = rh.transition;
  rh.transition = null;
  try {
    (mn = 1), vE(n, e, t, i);
  } finally {
    (mn = r), (rh.transition = s);
  }
}
function pH(n, e, t, i) {
  var r = mn,
    s = rh.transition;
  rh.transition = null;
  try {
    (mn = 4), vE(n, e, t, i);
  } finally {
    (mn = r), (rh.transition = s);
  }
}
function vE(n, e, t, i) {
  if (iy) {
    var r = mM(n, e, t, i);
    if (r === null) u1(n, e, i, ry, t), UR(n, i);
    else if (fH(r, n, e, t, i)) i.stopPropagation();
    else if ((UR(n, i), e & 4 && -1 < cH.indexOf(n))) {
      for (; r !== null; ) {
        var s = Nm(r);
        if (
          (s !== null && RL(s),
          (s = mM(n, e, t, i)),
          s === null && u1(n, e, i, ry, t),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else u1(n, e, i, null, t);
  }
}
var ry = null;
function mM(n, e, t, i) {
  if (((ry = null), (n = dE(i)), (n = zu(n)), n !== null))
    if (((e = Lc(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = AL(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (ry = n), null;
}
function LL(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (tH()) {
        case pE:
          return 1;
        case EL:
          return 4;
        case ty:
        case nH:
          return 16;
        case TL:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var vl = null,
  yE = null,
  Rv = null;
function FL() {
  if (Rv) return Rv;
  var n,
    e = yE,
    t = e.length,
    i,
    r = "value" in vl ? vl.value : vl.textContent,
    s = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++);
  var o = t - n;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
  return (Rv = r.slice(n, 1 < i ? 1 - i : void 0));
}
function Pv(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function r0() {
  return !0;
}
function zR() {
  return !1;
}
function ws(n) {
  function e(t, i, r, s, o) {
    (this._reactName = t),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? r0
        : zR),
      (this.isPropagationStopped = zR),
      this
    );
  }
  return (
    kn(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = r0));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = r0));
      },
      persist: function () {},
      isPersistent: r0,
    }),
    e
  );
}
var Gh = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  _E = ws(Gh),
  Fm = kn({}, Gh, { view: 0, detail: 0 }),
  mH = ws(Fm),
  e1,
  t1,
  xd,
  N_ = kn({}, Fm, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: xE,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== xd &&
            (xd && n.type === "mousemove"
              ? ((e1 = n.screenX - xd.screenX), (t1 = n.screenY - xd.screenY))
              : (t1 = e1 = 0),
            (xd = n)),
          e1);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : t1;
    },
  }),
  HR = ws(N_),
  gH = kn({}, N_, { dataTransfer: 0 }),
  vH = ws(gH),
  yH = kn({}, Fm, { relatedTarget: 0 }),
  n1 = ws(yH),
  _H = kn({}, Gh, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  xH = ws(_H),
  AH = kn({}, Gh, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  SH = ws(AH),
  MH = kn({}, Gh, { data: 0 }),
  GR = ws(MH),
  wH = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  EH = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  TH = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function CH(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = TH[n]) ? !!e[n] : !1;
}
function xE() {
  return CH;
}
var bH = kn({}, Fm, {
    key: function (n) {
      if (n.key) {
        var e = wH[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = Pv(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? EH[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: xE,
    charCode: function (n) {
      return n.type === "keypress" ? Pv(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? Pv(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  RH = ws(bH),
  PH = kn({}, N_, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  VR = ws(PH),
  BH = kn({}, Fm, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: xE,
  }),
  IH = ws(BH),
  DH = kn({}, Gh, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  LH = ws(DH),
  FH = kn({}, N_, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  NH = ws(FH),
  OH = [9, 13, 27, 32],
  AE = Da && "CompositionEvent" in window,
  lp = null;
Da && "documentMode" in document && (lp = document.documentMode);
var UH = Da && "TextEvent" in window && !lp,
  NL = Da && (!AE || (lp && 8 < lp && 11 >= lp)),
  WR = String.fromCharCode(32),
  XR = !1;
function OL(n, e) {
  switch (n) {
    case "keyup":
      return OH.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function UL(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var Lf = !1;
function kH(n, e) {
  switch (n) {
    case "compositionend":
      return UL(e);
    case "keypress":
      return e.which !== 32 ? null : ((XR = !0), WR);
    case "textInput":
      return (n = e.data), n === WR && XR ? null : n;
    default:
      return null;
  }
}
function zH(n, e) {
  if (Lf)
    return n === "compositionend" || (!AE && OL(n, e))
      ? ((n = FL()), (Rv = yE = vl = null), (Lf = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return NL && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var HH = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function JR(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!HH[n.type] : e === "textarea";
}
function kL(n, e, t, i) {
  gL(i),
    (e = sy(e, "onChange")),
    0 < e.length &&
      ((t = new _E("onChange", "change", null, t, i)),
      n.push({ event: t, listeners: e }));
}
var up = null,
  Yp = null;
function GH(n) {
  QL(n, 0);
}
function O_(n) {
  var e = Of(n);
  if (uL(e)) return n;
}
function VH(n, e) {
  if (n === "change") return e;
}
var zL = !1;
if (Da) {
  var i1;
  if (Da) {
    var r1 = "oninput" in document;
    if (!r1) {
      var jR = document.createElement("div");
      jR.setAttribute("oninput", "return;"),
        (r1 = typeof jR.oninput == "function");
    }
    i1 = r1;
  } else i1 = !1;
  zL = i1 && (!document.documentMode || 9 < document.documentMode);
}
function YR() {
  up && (up.detachEvent("onpropertychange", HL), (Yp = up = null));
}
function HL(n) {
  if (n.propertyName === "value" && O_(Yp)) {
    var e = [];
    kL(e, Yp, n, dE(n)), xL(GH, e);
  }
}
function WH(n, e, t) {
  n === "focusin"
    ? (YR(), (up = e), (Yp = t), up.attachEvent("onpropertychange", HL))
    : n === "focusout" && YR();
}
function XH(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return O_(Yp);
}
function JH(n, e) {
  if (n === "click") return O_(e);
}
function jH(n, e) {
  if (n === "input" || n === "change") return O_(e);
}
function YH(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var _o = typeof Object.is == "function" ? Object.is : YH;
function Kp(n, e) {
  if (_o(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    i = Object.keys(e);
  if (t.length !== i.length) return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!ZS.call(e, r) || !_o(n[r], e[r])) return !1;
  }
  return !0;
}
function KR(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function QR(n, e) {
  var t = KR(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (((i = n + t.textContent.length), n <= e && i >= e))
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = KR(t);
  }
}
function GL(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? GL(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function VL() {
  for (var n = window, e = qv(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = qv(n.document);
  }
  return e;
}
function SE(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function KH(n) {
  var e = VL(),
    t = n.focusedElem,
    i = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    GL(t.ownerDocument.documentElement, t)
  ) {
    if (i !== null && SE(t)) {
      if (
        ((e = i.start),
        (n = i.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var r = t.textContent.length,
          s = Math.min(i.start, r);
        (i = i.end === void 0 ? s : Math.min(i.end, r)),
          !n.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = QR(t, s));
        var o = QR(t, i);
        r &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== r.node ||
            n.anchorOffset !== r.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          n.removeAllRanges(),
          s > i
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var QH = Da && "documentMode" in document && 11 >= document.documentMode,
  Ff = null,
  gM = null,
  cp = null,
  vM = !1;
function ZR(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  vM ||
    Ff == null ||
    Ff !== qv(i) ||
    ((i = Ff),
    "selectionStart" in i && SE(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (cp && Kp(cp, i)) ||
      ((cp = i),
      (i = sy(gM, "onSelect")),
      0 < i.length &&
        ((e = new _E("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: i }),
        (e.target = Ff))));
}
function s0(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var Nf = {
    animationend: s0("Animation", "AnimationEnd"),
    animationiteration: s0("Animation", "AnimationIteration"),
    animationstart: s0("Animation", "AnimationStart"),
    transitionend: s0("Transition", "TransitionEnd"),
  },
  s1 = {},
  WL = {};
Da &&
  ((WL = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Nf.animationend.animation,
    delete Nf.animationiteration.animation,
    delete Nf.animationstart.animation),
  "TransitionEvent" in window || delete Nf.transitionend.transition);
function U_(n) {
  if (s1[n]) return s1[n];
  if (!Nf[n]) return n;
  var e = Nf[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in WL) return (s1[n] = e[t]);
  return n;
}
var XL = U_("animationend"),
  JL = U_("animationiteration"),
  jL = U_("animationstart"),
  YL = U_("transitionend"),
  KL = new Map(),
  qR =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function jl(n, e) {
  KL.set(n, e), Dc(e, [n]);
}
for (var o1 = 0; o1 < qR.length; o1++) {
  var a1 = qR[o1],
    ZH = a1.toLowerCase(),
    qH = a1[0].toUpperCase() + a1.slice(1);
  jl(ZH, "on" + qH);
}
jl(XL, "onAnimationEnd");
jl(JL, "onAnimationIteration");
jl(jL, "onAnimationStart");
jl("dblclick", "onDoubleClick");
jl("focusin", "onFocus");
jl("focusout", "onBlur");
jl(YL, "onTransitionEnd");
vh("onMouseEnter", ["mouseout", "mouseover"]);
vh("onMouseLeave", ["mouseout", "mouseover"]);
vh("onPointerEnter", ["pointerout", "pointerover"]);
vh("onPointerLeave", ["pointerout", "pointerover"]);
Dc(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
Dc(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
Dc("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Dc(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
Dc(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
Dc(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Kd =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  $H = new Set("cancel close invalid load scroll toggle".split(" ").concat(Kd));
function $R(n, e, t) {
  var i = n.type || "unknown-event";
  (n.currentTarget = t), Z4(i, e, void 0, n), (n.currentTarget = null);
}
function QL(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var a = i[o],
            l = a.instance,
            u = a.currentTarget;
          if (((a = a.listener), l !== s && r.isPropagationStopped())) break e;
          $R(r, a, u), (s = l);
        }
      else
        for (o = 0; o < i.length; o++) {
          if (
            ((a = i[o]),
            (l = a.instance),
            (u = a.currentTarget),
            (a = a.listener),
            l !== s && r.isPropagationStopped())
          )
            break e;
          $R(r, a, u), (s = l);
        }
    }
  }
  if (ey) throw ((n = hM), (ey = !1), (hM = null), n);
}
function wn(n, e) {
  var t = e[SM];
  t === void 0 && (t = e[SM] = new Set());
  var i = n + "__bubble";
  t.has(i) || (ZL(e, n, 2, !1), t.add(i));
}
function l1(n, e, t) {
  var i = 0;
  e && (i |= 4), ZL(t, n, i, e);
}
var o0 = "_reactListening" + Math.random().toString(36).slice(2);
function Qp(n) {
  if (!n[o0]) {
    (n[o0] = !0),
      rL.forEach(function (t) {
        t !== "selectionchange" && ($H.has(t) || l1(t, !1, n), l1(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[o0] || ((e[o0] = !0), l1("selectionchange", !1, e));
  }
}
function ZL(n, e, t, i) {
  switch (LL(e)) {
    case 1:
      var r = dH;
      break;
    case 4:
      r = pH;
      break;
    default:
      r = vE;
  }
  (t = r.bind(null, e, t, n)),
    (r = void 0),
    !fM ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: r })
        : n.addEventListener(e, t, !0)
      : r !== void 0
      ? n.addEventListener(e, t, { passive: r })
      : n.addEventListener(e, t, !1);
}
function u1(n, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var o = i.tag;
      if (o === 3 || o === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (o === 4)
          for (o = i.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === r || (l.nodeType === 8 && l.parentNode === r))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = zu(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            i = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  xL(function () {
    var u = s,
      c = dE(t),
      d = [];
    e: {
      var p = KL.get(n);
      if (p !== void 0) {
        var m = _E,
          v = n;
        switch (n) {
          case "keypress":
            if (Pv(t) === 0) break e;
          case "keydown":
          case "keyup":
            m = RH;
            break;
          case "focusin":
            (v = "focus"), (m = n1);
            break;
          case "focusout":
            (v = "blur"), (m = n1);
            break;
          case "beforeblur":
          case "afterblur":
            m = n1;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = HR;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = vH;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = IH;
            break;
          case XL:
          case JL:
          case jL:
            m = xH;
            break;
          case YL:
            m = LH;
            break;
          case "scroll":
            m = mH;
            break;
          case "wheel":
            m = NH;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = SH;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = VR;
        }
        var _ = (e & 4) !== 0,
          x = !_ && n === "scroll",
          g = _ ? (p !== null ? p + "Capture" : null) : p;
        _ = [];
        for (var A = u, S; A !== null; ) {
          S = A;
          var w = S.stateNode;
          if (
            (S.tag === 5 &&
              w !== null &&
              ((S = w),
              g !== null && ((w = Wp(A, g)), w != null && _.push(Zp(A, w, S)))),
            x)
          )
            break;
          A = A.return;
        }
        0 < _.length &&
          ((p = new m(p, v, null, t, c)), d.push({ event: p, listeners: _ }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = n === "mouseover" || n === "pointerover"),
          (m = n === "mouseout" || n === "pointerout"),
          p &&
            t !== uM &&
            (v = t.relatedTarget || t.fromElement) &&
            (zu(v) || v[La]))
        )
          break e;
        if (
          (m || p) &&
          ((p =
            c.window === c
              ? c
              : (p = c.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          m
            ? ((v = t.relatedTarget || t.toElement),
              (m = u),
              (v = v ? zu(v) : null),
              v !== null &&
                ((x = Lc(v)), v !== x || (v.tag !== 5 && v.tag !== 6)) &&
                (v = null))
            : ((m = null), (v = u)),
          m !== v)
        ) {
          if (
            ((_ = HR),
            (w = "onMouseLeave"),
            (g = "onMouseEnter"),
            (A = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((_ = VR),
              (w = "onPointerLeave"),
              (g = "onPointerEnter"),
              (A = "pointer")),
            (x = m == null ? p : Of(m)),
            (S = v == null ? p : Of(v)),
            (p = new _(w, A + "leave", m, t, c)),
            (p.target = x),
            (p.relatedTarget = S),
            (w = null),
            zu(c) === u &&
              ((_ = new _(g, A + "enter", v, t, c)),
              (_.target = S),
              (_.relatedTarget = x),
              (w = _)),
            (x = w),
            m && v)
          )
            t: {
              for (_ = m, g = v, A = 0, S = _; S; S = nf(S)) A++;
              for (S = 0, w = g; w; w = nf(w)) S++;
              for (; 0 < A - S; ) (_ = nf(_)), A--;
              for (; 0 < S - A; ) (g = nf(g)), S--;
              for (; A--; ) {
                if (_ === g || (g !== null && _ === g.alternate)) break t;
                (_ = nf(_)), (g = nf(g));
              }
              _ = null;
            }
          else _ = null;
          m !== null && eP(d, p, m, _, !1),
            v !== null && x !== null && eP(d, x, v, _, !0);
        }
      }
      e: {
        if (
          ((p = u ? Of(u) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === "select" || (m === "input" && p.type === "file"))
        )
          var C = VH;
        else if (JR(p))
          if (zL) C = jH;
          else {
            C = XH;
            var b = WH;
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (C = JH);
        if (C && (C = C(n, u))) {
          kL(d, C, t, c);
          break e;
        }
        b && b(n, p, u),
          n === "focusout" &&
            (b = p._wrapperState) &&
            b.controlled &&
            p.type === "number" &&
            rM(p, "number", p.value);
      }
      switch (((b = u ? Of(u) : window), n)) {
        case "focusin":
          (JR(b) || b.contentEditable === "true") &&
            ((Ff = b), (gM = u), (cp = null));
          break;
        case "focusout":
          cp = gM = Ff = null;
          break;
        case "mousedown":
          vM = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (vM = !1), ZR(d, t, c);
          break;
        case "selectionchange":
          if (QH) break;
        case "keydown":
        case "keyup":
          ZR(d, t, c);
      }
      var P;
      if (AE)
        e: {
          switch (n) {
            case "compositionstart":
              var I = "onCompositionStart";
              break e;
            case "compositionend":
              I = "onCompositionEnd";
              break e;
            case "compositionupdate":
              I = "onCompositionUpdate";
              break e;
          }
          I = void 0;
        }
      else
        Lf
          ? OL(n, t) && (I = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (I = "onCompositionStart");
      I &&
        (NL &&
          t.locale !== "ko" &&
          (Lf || I !== "onCompositionStart"
            ? I === "onCompositionEnd" && Lf && (P = FL())
            : ((vl = c),
              (yE = "value" in vl ? vl.value : vl.textContent),
              (Lf = !0))),
        (b = sy(u, I)),
        0 < b.length &&
          ((I = new GR(I, n, null, t, c)),
          d.push({ event: I, listeners: b }),
          P ? (I.data = P) : ((P = UL(t)), P !== null && (I.data = P)))),
        (P = UH ? kH(n, t) : zH(n, t)) &&
          ((u = sy(u, "onBeforeInput")),
          0 < u.length &&
            ((c = new GR("onBeforeInput", "beforeinput", null, t, c)),
            d.push({ event: c, listeners: u }),
            (c.data = P)));
    }
    QL(d, e);
  });
}
function Zp(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function sy(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n,
      s = r.stateNode;
    r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = Wp(n, t)),
      s != null && i.unshift(Zp(n, s, r)),
      (s = Wp(n, e)),
      s != null && i.push(Zp(n, s, r))),
      (n = n.return);
  }
  return i;
}
function nf(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function eP(n, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t,
      l = a.alternate,
      u = a.stateNode;
    if (l !== null && l === i) break;
    a.tag === 5 &&
      u !== null &&
      ((a = u),
      r
        ? ((l = Wp(t, s)), l != null && o.unshift(Zp(t, l, a)))
        : r || ((l = Wp(t, s)), l != null && o.push(Zp(t, l, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var eG = /\r\n?/g,
  tG = /\u0000|\uFFFD/g;
function tP(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      eG,
      `
`
    )
    .replace(tG, "");
}
function a0(n, e, t) {
  if (((e = tP(e)), tP(n) !== e && t)) throw Error(Be(425));
}
function oy() {}
var yM = null,
  _M = null;
function xM(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var AM = typeof setTimeout == "function" ? setTimeout : void 0,
  nG = typeof clearTimeout == "function" ? clearTimeout : void 0,
  nP = typeof Promise == "function" ? Promise : void 0,
  iG =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof nP < "u"
      ? function (n) {
          return nP.resolve(null).then(n).catch(rG);
        }
      : AM;
function rG(n) {
  setTimeout(function () {
    throw n;
  });
}
function c1(n, e) {
  var t = e,
    i = 0;
  do {
    var r = t.nextSibling;
    if ((n.removeChild(t), r && r.nodeType === 8))
      if (((t = r.data), t === "/$")) {
        if (i === 0) {
          n.removeChild(r), jp(e);
          return;
        }
        i--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || i++;
    t = r;
  } while (t);
  jp(e);
}
function Cl(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function iP(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var Vh = Math.random().toString(36).slice(2),
  Oo = "__reactFiber$" + Vh,
  qp = "__reactProps$" + Vh,
  La = "__reactContainer$" + Vh,
  SM = "__reactEvents$" + Vh,
  sG = "__reactListeners$" + Vh,
  oG = "__reactHandles$" + Vh;
function zu(n) {
  var e = n[Oo];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[La] || t[Oo])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = iP(n); n !== null; ) {
          if ((t = n[Oo])) return t;
          n = iP(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function Nm(n) {
  return (
    (n = n[Oo] || n[La]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function Of(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(Be(33));
}
function k_(n) {
  return n[qp] || null;
}
var MM = [],
  Uf = -1;
function Yl(n) {
  return { current: n };
}
function En(n) {
  0 > Uf || ((n.current = MM[Uf]), (MM[Uf] = null), Uf--);
}
function Mn(n, e) {
  Uf++, (MM[Uf] = n.current), (n.current = e);
}
var Ul = {},
  nr = Yl(Ul),
  Hr = Yl(!1),
  mc = Ul;
function yh(n, e) {
  var t = n.type.contextTypes;
  if (!t) return Ul;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in t) r[s] = e[s];
  return (
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function Gr(n) {
  return (n = n.childContextTypes), n != null;
}
function ay() {
  En(Hr), En(nr);
}
function rP(n, e, t) {
  if (nr.current !== Ul) throw Error(Be(168));
  Mn(nr, e), Mn(Hr, t);
}
function qL(n, e, t) {
  var i = n.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(Be(108, W4(n) || "Unknown", r));
  return kn({}, t, i);
}
function ly(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || Ul),
    (mc = nr.current),
    Mn(nr, n),
    Mn(Hr, Hr.current),
    !0
  );
}
function sP(n, e, t) {
  var i = n.stateNode;
  if (!i) throw Error(Be(169));
  t
    ? ((n = qL(n, e, mc)),
      (i.__reactInternalMemoizedMergedChildContext = n),
      En(Hr),
      En(nr),
      Mn(nr, n))
    : En(Hr),
    Mn(Hr, t);
}
var pa = null,
  z_ = !1,
  f1 = !1;
function $L(n) {
  pa === null ? (pa = [n]) : pa.push(n);
}
function aG(n) {
  (z_ = !0), $L(n);
}
function Kl() {
  if (!f1 && pa !== null) {
    f1 = !0;
    var n = 0,
      e = mn;
    try {
      var t = pa;
      for (mn = 1; n < t.length; n++) {
        var i = t[n];
        do i = i(!0);
        while (i !== null);
      }
      (pa = null), (z_ = !1);
    } catch (r) {
      throw (pa !== null && (pa = pa.slice(n + 1)), wL(pE, Kl), r);
    } finally {
      (mn = e), (f1 = !1);
    }
  }
  return null;
}
var kf = [],
  zf = 0,
  uy = null,
  cy = 0,
  ks = [],
  zs = 0,
  gc = null,
  xa = 1,
  Aa = "";
function bu(n, e) {
  (kf[zf++] = cy), (kf[zf++] = uy), (uy = n), (cy = e);
}
function e3(n, e, t) {
  (ks[zs++] = xa), (ks[zs++] = Aa), (ks[zs++] = gc), (gc = n);
  var i = xa;
  n = Aa;
  var r = 32 - mo(i) - 1;
  (i &= ~(1 << r)), (t += 1);
  var s = 32 - mo(e) + r;
  if (30 < s) {
    var o = r - (r % 5);
    (s = (i & ((1 << o) - 1)).toString(32)),
      (i >>= o),
      (r -= o),
      (xa = (1 << (32 - mo(e) + r)) | (t << r) | i),
      (Aa = s + n);
  } else (xa = (1 << s) | (t << r) | i), (Aa = n);
}
function ME(n) {
  n.return !== null && (bu(n, 1), e3(n, 1, 0));
}
function wE(n) {
  for (; n === uy; )
    (uy = kf[--zf]), (kf[zf] = null), (cy = kf[--zf]), (kf[zf] = null);
  for (; n === gc; )
    (gc = ks[--zs]),
      (ks[zs] = null),
      (Aa = ks[--zs]),
      (ks[zs] = null),
      (xa = ks[--zs]),
      (ks[zs] = null);
}
var ps = null,
  cs = null,
  Cn = !1,
  fo = null;
function t3(n, e) {
  var t = Ws(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function oP(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (ps = n), (cs = Cl(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (ps = n), (cs = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = gc !== null ? { id: xa, overflow: Aa } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = Ws(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (ps = n),
            (cs = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function wM(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function EM(n) {
  if (Cn) {
    var e = cs;
    if (e) {
      var t = e;
      if (!oP(n, e)) {
        if (wM(n)) throw Error(Be(418));
        e = Cl(t.nextSibling);
        var i = ps;
        e && oP(n, e)
          ? t3(i, t)
          : ((n.flags = (n.flags & -4097) | 2), (Cn = !1), (ps = n));
      }
    } else {
      if (wM(n)) throw Error(Be(418));
      (n.flags = (n.flags & -4097) | 2), (Cn = !1), (ps = n);
    }
  }
}
function aP(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  ps = n;
}
function l0(n) {
  if (n !== ps) return !1;
  if (!Cn) return aP(n), (Cn = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !xM(n.type, n.memoizedProps))),
    e && (e = cs))
  ) {
    if (wM(n)) throw (n3(), Error(Be(418)));
    for (; e; ) t3(n, e), (e = Cl(e.nextSibling));
  }
  if ((aP(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(Be(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              cs = Cl(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      cs = null;
    }
  } else cs = ps ? Cl(n.stateNode.nextSibling) : null;
  return !0;
}
function n3() {
  for (var n = cs; n; ) n = Cl(n.nextSibling);
}
function _h() {
  (cs = ps = null), (Cn = !1);
}
function EE(n) {
  fo === null ? (fo = [n]) : fo.push(n);
}
var lG = Va.ReactCurrentBatchConfig;
function Ad(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(Be(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(Be(147, n));
      var r = i,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = r.refs;
            o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(Be(284));
    if (!t._owner) throw Error(Be(290, n));
  }
  return n;
}
function u0(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      Be(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function lP(n) {
  var e = n._init;
  return e(n._payload);
}
function i3(n) {
  function e(g, A) {
    if (n) {
      var S = g.deletions;
      S === null ? ((g.deletions = [A]), (g.flags |= 16)) : S.push(A);
    }
  }
  function t(g, A) {
    if (!n) return null;
    for (; A !== null; ) e(g, A), (A = A.sibling);
    return null;
  }
  function i(g, A) {
    for (g = new Map(); A !== null; )
      A.key !== null ? g.set(A.key, A) : g.set(A.index, A), (A = A.sibling);
    return g;
  }
  function r(g, A) {
    return (g = Bl(g, A)), (g.index = 0), (g.sibling = null), g;
  }
  function s(g, A, S) {
    return (
      (g.index = S),
      n
        ? ((S = g.alternate),
          S !== null
            ? ((S = S.index), S < A ? ((g.flags |= 2), A) : S)
            : ((g.flags |= 2), A))
        : ((g.flags |= 1048576), A)
    );
  }
  function o(g) {
    return n && g.alternate === null && (g.flags |= 2), g;
  }
  function a(g, A, S, w) {
    return A === null || A.tag !== 6
      ? ((A = y1(S, g.mode, w)), (A.return = g), A)
      : ((A = r(A, S)), (A.return = g), A);
  }
  function l(g, A, S, w) {
    var C = S.type;
    return C === Df
      ? c(g, A, S.props.children, w, S.key)
      : A !== null &&
        (A.elementType === C ||
          (typeof C == "object" &&
            C !== null &&
            C.$$typeof === fl &&
            lP(C) === A.type))
      ? ((w = r(A, S.props)), (w.ref = Ad(g, A, S)), (w.return = g), w)
      : ((w = Ov(S.type, S.key, S.props, null, g.mode, w)),
        (w.ref = Ad(g, A, S)),
        (w.return = g),
        w);
  }
  function u(g, A, S, w) {
    return A === null ||
      A.tag !== 4 ||
      A.stateNode.containerInfo !== S.containerInfo ||
      A.stateNode.implementation !== S.implementation
      ? ((A = _1(S, g.mode, w)), (A.return = g), A)
      : ((A = r(A, S.children || [])), (A.return = g), A);
  }
  function c(g, A, S, w, C) {
    return A === null || A.tag !== 7
      ? ((A = tc(S, g.mode, w, C)), (A.return = g), A)
      : ((A = r(A, S)), (A.return = g), A);
  }
  function d(g, A, S) {
    if ((typeof A == "string" && A !== "") || typeof A == "number")
      return (A = y1("" + A, g.mode, S)), (A.return = g), A;
    if (typeof A == "object" && A !== null) {
      switch (A.$$typeof) {
        case qg:
          return (
            (S = Ov(A.type, A.key, A.props, null, g.mode, S)),
            (S.ref = Ad(g, null, A)),
            (S.return = g),
            S
          );
        case If:
          return (A = _1(A, g.mode, S)), (A.return = g), A;
        case fl:
          var w = A._init;
          return d(g, w(A._payload), S);
      }
      if (jd(A) || gd(A))
        return (A = tc(A, g.mode, S, null)), (A.return = g), A;
      u0(g, A);
    }
    return null;
  }
  function p(g, A, S, w) {
    var C = A !== null ? A.key : null;
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return C !== null ? null : a(g, A, "" + S, w);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case qg:
          return S.key === C ? l(g, A, S, w) : null;
        case If:
          return S.key === C ? u(g, A, S, w) : null;
        case fl:
          return (C = S._init), p(g, A, C(S._payload), w);
      }
      if (jd(S) || gd(S)) return C !== null ? null : c(g, A, S, w, null);
      u0(g, S);
    }
    return null;
  }
  function m(g, A, S, w, C) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (g = g.get(S) || null), a(A, g, "" + w, C);
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case qg:
          return (g = g.get(w.key === null ? S : w.key) || null), l(A, g, w, C);
        case If:
          return (g = g.get(w.key === null ? S : w.key) || null), u(A, g, w, C);
        case fl:
          var b = w._init;
          return m(g, A, S, b(w._payload), C);
      }
      if (jd(w) || gd(w)) return (g = g.get(S) || null), c(A, g, w, C, null);
      u0(A, w);
    }
    return null;
  }
  function v(g, A, S, w) {
    for (
      var C = null, b = null, P = A, I = (A = 0), R = null;
      P !== null && I < S.length;
      I++
    ) {
      P.index > I ? ((R = P), (P = null)) : (R = P.sibling);
      var T = p(g, P, S[I], w);
      if (T === null) {
        P === null && (P = R);
        break;
      }
      n && P && T.alternate === null && e(g, P),
        (A = s(T, A, I)),
        b === null ? (C = T) : (b.sibling = T),
        (b = T),
        (P = R);
    }
    if (I === S.length) return t(g, P), Cn && bu(g, I), C;
    if (P === null) {
      for (; I < S.length; I++)
        (P = d(g, S[I], w)),
          P !== null &&
            ((A = s(P, A, I)), b === null ? (C = P) : (b.sibling = P), (b = P));
      return Cn && bu(g, I), C;
    }
    for (P = i(g, P); I < S.length; I++)
      (R = m(P, g, I, S[I], w)),
        R !== null &&
          (n && R.alternate !== null && P.delete(R.key === null ? I : R.key),
          (A = s(R, A, I)),
          b === null ? (C = R) : (b.sibling = R),
          (b = R));
    return (
      n &&
        P.forEach(function (D) {
          return e(g, D);
        }),
      Cn && bu(g, I),
      C
    );
  }
  function _(g, A, S, w) {
    var C = gd(S);
    if (typeof C != "function") throw Error(Be(150));
    if (((S = C.call(S)), S == null)) throw Error(Be(151));
    for (
      var b = (C = null), P = A, I = (A = 0), R = null, T = S.next();
      P !== null && !T.done;
      I++, T = S.next()
    ) {
      P.index > I ? ((R = P), (P = null)) : (R = P.sibling);
      var D = p(g, P, T.value, w);
      if (D === null) {
        P === null && (P = R);
        break;
      }
      n && P && D.alternate === null && e(g, P),
        (A = s(D, A, I)),
        b === null ? (C = D) : (b.sibling = D),
        (b = D),
        (P = R);
    }
    if (T.done) return t(g, P), Cn && bu(g, I), C;
    if (P === null) {
      for (; !T.done; I++, T = S.next())
        (T = d(g, T.value, w)),
          T !== null &&
            ((A = s(T, A, I)), b === null ? (C = T) : (b.sibling = T), (b = T));
      return Cn && bu(g, I), C;
    }
    for (P = i(g, P); !T.done; I++, T = S.next())
      (T = m(P, g, I, T.value, w)),
        T !== null &&
          (n && T.alternate !== null && P.delete(T.key === null ? I : T.key),
          (A = s(T, A, I)),
          b === null ? (C = T) : (b.sibling = T),
          (b = T));
    return (
      n &&
        P.forEach(function (G) {
          return e(g, G);
        }),
      Cn && bu(g, I),
      C
    );
  }
  function x(g, A, S, w) {
    if (
      (typeof S == "object" &&
        S !== null &&
        S.type === Df &&
        S.key === null &&
        (S = S.props.children),
      typeof S == "object" && S !== null)
    ) {
      switch (S.$$typeof) {
        case qg:
          e: {
            for (var C = S.key, b = A; b !== null; ) {
              if (b.key === C) {
                if (((C = S.type), C === Df)) {
                  if (b.tag === 7) {
                    t(g, b.sibling),
                      (A = r(b, S.props.children)),
                      (A.return = g),
                      (g = A);
                    break e;
                  }
                } else if (
                  b.elementType === C ||
                  (typeof C == "object" &&
                    C !== null &&
                    C.$$typeof === fl &&
                    lP(C) === b.type)
                ) {
                  t(g, b.sibling),
                    (A = r(b, S.props)),
                    (A.ref = Ad(g, b, S)),
                    (A.return = g),
                    (g = A);
                  break e;
                }
                t(g, b);
                break;
              } else e(g, b);
              b = b.sibling;
            }
            S.type === Df
              ? ((A = tc(S.props.children, g.mode, w, S.key)),
                (A.return = g),
                (g = A))
              : ((w = Ov(S.type, S.key, S.props, null, g.mode, w)),
                (w.ref = Ad(g, A, S)),
                (w.return = g),
                (g = w));
          }
          return o(g);
        case If:
          e: {
            for (b = S.key; A !== null; ) {
              if (A.key === b)
                if (
                  A.tag === 4 &&
                  A.stateNode.containerInfo === S.containerInfo &&
                  A.stateNode.implementation === S.implementation
                ) {
                  t(g, A.sibling),
                    (A = r(A, S.children || [])),
                    (A.return = g),
                    (g = A);
                  break e;
                } else {
                  t(g, A);
                  break;
                }
              else e(g, A);
              A = A.sibling;
            }
            (A = _1(S, g.mode, w)), (A.return = g), (g = A);
          }
          return o(g);
        case fl:
          return (b = S._init), x(g, A, b(S._payload), w);
      }
      if (jd(S)) return v(g, A, S, w);
      if (gd(S)) return _(g, A, S, w);
      u0(g, S);
    }
    return (typeof S == "string" && S !== "") || typeof S == "number"
      ? ((S = "" + S),
        A !== null && A.tag === 6
          ? (t(g, A.sibling), (A = r(A, S)), (A.return = g), (g = A))
          : (t(g, A), (A = y1(S, g.mode, w)), (A.return = g), (g = A)),
        o(g))
      : t(g, A);
  }
  return x;
}
var xh = i3(!0),
  r3 = i3(!1),
  fy = Yl(null),
  hy = null,
  Hf = null,
  TE = null;
function CE() {
  TE = Hf = hy = null;
}
function bE(n) {
  var e = fy.current;
  En(fy), (n._currentValue = e);
}
function TM(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function sh(n, e) {
  (hy = n),
    (TE = Hf = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (Ur = !0), (n.firstContext = null));
}
function qs(n) {
  var e = n._currentValue;
  if (TE !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), Hf === null)) {
      if (hy === null) throw Error(Be(308));
      (Hf = n), (hy.dependencies = { lanes: 0, firstContext: n });
    } else Hf = Hf.next = n;
  return e;
}
var Hu = null;
function RE(n) {
  Hu === null ? (Hu = [n]) : Hu.push(n);
}
function s3(n, e, t, i) {
  var r = e.interleaved;
  return (
    r === null ? ((t.next = t), RE(e)) : ((t.next = r.next), (r.next = t)),
    (e.interleaved = t),
    Fa(n, i)
  );
}
function Fa(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var hl = !1;
function PE(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function o3(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function Ta(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function bl(n, e, t) {
  var i = n.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), nn & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      Fa(n, t)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), RE(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    Fa(n, t)
  );
}
function Bv(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), mE(n, t);
  }
}
function uP(n, e) {
  var t = n.updateQueue,
    i = n.alternate;
  if (i !== null && ((i = i.updateQueue), t === i)) {
    var r = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (r = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    (t = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function dy(n, e, t, i) {
  var r = n.updateQueue;
  hl = !1;
  var s = r.firstBaseUpdate,
    o = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var l = a,
      u = l.next;
    (l.next = null), o === null ? (s = u) : (o.next = u), (o = l);
    var c = n.alternate;
    c !== null &&
      ((c = c.updateQueue),
      (a = c.lastBaseUpdate),
      a !== o &&
        (a === null ? (c.firstBaseUpdate = u) : (a.next = u),
        (c.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var d = r.baseState;
    (o = 0), (c = u = l = null), (a = s);
    do {
      var p = a.lane,
        m = a.eventTime;
      if ((i & p) === p) {
        c !== null &&
          (c = c.next =
            {
              eventTime: m,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var v = n,
            _ = a;
          switch (((p = e), (m = t), _.tag)) {
            case 1:
              if (((v = _.payload), typeof v == "function")) {
                d = v.call(m, d, p);
                break e;
              }
              d = v;
              break e;
            case 3:
              v.flags = (v.flags & -65537) | 128;
            case 0:
              if (
                ((v = _.payload),
                (p = typeof v == "function" ? v.call(m, d, p) : v),
                p == null)
              )
                break e;
              d = kn({}, d, p);
              break e;
            case 2:
              hl = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (p = r.effects),
          p === null ? (r.effects = [a]) : p.push(a));
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          c === null ? ((u = c = m), (l = d)) : (c = c.next = m),
          (o |= p);
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        (p = a),
          (a = p.next),
          (p.next = null),
          (r.lastBaseUpdate = p),
          (r.shared.pending = null);
      }
    } while (1);
    if (
      (c === null && (l = d),
      (r.baseState = l),
      (r.firstBaseUpdate = u),
      (r.lastBaseUpdate = c),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (o |= r.lane), (r = r.next);
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    (yc |= o), (n.lanes = o), (n.memoizedState = d);
  }
}
function cP(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var i = n[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = t), typeof r != "function"))
          throw Error(Be(191, r));
        r.call(i);
      }
    }
}
var Om = {},
  Go = Yl(Om),
  $p = Yl(Om),
  em = Yl(Om);
function Gu(n) {
  if (n === Om) throw Error(Be(174));
  return n;
}
function BE(n, e) {
  switch ((Mn(em, e), Mn($p, n), Mn(Go, Om), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : oM(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = oM(e, n));
  }
  En(Go), Mn(Go, e);
}
function Ah() {
  En(Go), En($p), En(em);
}
function a3(n) {
  Gu(em.current);
  var e = Gu(Go.current),
    t = oM(e, n.type);
  e !== t && (Mn($p, n), Mn(Go, t));
}
function IE(n) {
  $p.current === n && (En(Go), En($p));
}
var Dn = Yl(0);
function py(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var h1 = [];
function DE() {
  for (var n = 0; n < h1.length; n++)
    h1[n]._workInProgressVersionPrimary = null;
  h1.length = 0;
}
var Iv = Va.ReactCurrentDispatcher,
  d1 = Va.ReactCurrentBatchConfig,
  vc = 0,
  Un = null,
  fi = null,
  Ti = null,
  my = !1,
  fp = !1,
  tm = 0,
  uG = 0;
function Vi() {
  throw Error(Be(321));
}
function LE(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!_o(n[t], e[t])) return !1;
  return !0;
}
function FE(n, e, t, i, r, s) {
  if (
    ((vc = s),
    (Un = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Iv.current = n === null || n.memoizedState === null ? dG : pG),
    (n = t(i, r)),
    fp)
  ) {
    s = 0;
    do {
      if (((fp = !1), (tm = 0), 25 <= s)) throw Error(Be(301));
      (s += 1),
        (Ti = fi = null),
        (e.updateQueue = null),
        (Iv.current = mG),
        (n = t(i, r));
    } while (fp);
  }
  if (
    ((Iv.current = gy),
    (e = fi !== null && fi.next !== null),
    (vc = 0),
    (Ti = fi = Un = null),
    (my = !1),
    e)
  )
    throw Error(Be(300));
  return n;
}
function NE() {
  var n = tm !== 0;
  return (tm = 0), n;
}
function Do() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return Ti === null ? (Un.memoizedState = Ti = n) : (Ti = Ti.next = n), Ti;
}
function $s() {
  if (fi === null) {
    var n = Un.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = fi.next;
  var e = Ti === null ? Un.memoizedState : Ti.next;
  if (e !== null) (Ti = e), (fi = n);
  else {
    if (n === null) throw Error(Be(310));
    (fi = n),
      (n = {
        memoizedState: fi.memoizedState,
        baseState: fi.baseState,
        baseQueue: fi.baseQueue,
        queue: fi.queue,
        next: null,
      }),
      Ti === null ? (Un.memoizedState = Ti = n) : (Ti = Ti.next = n);
  }
  return Ti;
}
function nm(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function p1(n) {
  var e = $s(),
    t = e.queue;
  if (t === null) throw Error(Be(311));
  t.lastRenderedReducer = n;
  var i = fi,
    r = i.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      (r.next = s.next), (s.next = o);
    }
    (i.baseQueue = r = s), (t.pending = null);
  }
  if (r !== null) {
    (s = r.next), (i = i.baseState);
    var a = (o = null),
      l = null,
      u = s;
    do {
      var c = u.lane;
      if ((vc & c) === c)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null,
            }),
          (i = u.hasEagerState ? u.eagerState : n(i, u.action));
      else {
        var d = {
          lane: c,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null,
        };
        l === null ? ((a = l = d), (o = i)) : (l = l.next = d),
          (Un.lanes |= c),
          (yc |= c);
      }
      u = u.next;
    } while (u !== null && u !== s);
    l === null ? (o = i) : (l.next = a),
      _o(i, e.memoizedState) || (Ur = !0),
      (e.memoizedState = i),
      (e.baseState = o),
      (e.baseQueue = l),
      (t.lastRenderedState = i);
  }
  if (((n = t.interleaved), n !== null)) {
    r = n;
    do (s = r.lane), (Un.lanes |= s), (yc |= s), (r = r.next);
    while (r !== n);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function m1(n) {
  var e = $s(),
    t = e.queue;
  if (t === null) throw Error(Be(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch,
    r = t.pending,
    s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = (r = r.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== r);
    _o(s, e.memoizedState) || (Ur = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, i];
}
function l3() {}
function u3(n, e) {
  var t = Un,
    i = $s(),
    r = e(),
    s = !_o(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (Ur = !0)),
    (i = i.queue),
    OE(h3.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || (Ti !== null && Ti.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      im(9, f3.bind(null, t, i, r, e), void 0, null),
      Ci === null)
    )
      throw Error(Be(349));
    vc & 30 || c3(t, e, r);
  }
  return r;
}
function c3(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = Un.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (Un.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function f3(n, e, t, i) {
  (e.value = t), (e.getSnapshot = i), d3(e) && p3(n);
}
function h3(n, e, t) {
  return t(function () {
    d3(e) && p3(n);
  });
}
function d3(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !_o(n, t);
  } catch {
    return !0;
  }
}
function p3(n) {
  var e = Fa(n, 1);
  e !== null && go(e, n, 1, -1);
}
function fP(n) {
  var e = Do();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: nm,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = hG.bind(null, Un, n)),
    [e.memoizedState, n]
  );
}
function im(n, e, t, i) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
    (e = Un.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (Un.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
    n
  );
}
function m3() {
  return $s().memoizedState;
}
function Dv(n, e, t, i) {
  var r = Do();
  (Un.flags |= n),
    (r.memoizedState = im(1 | e, t, void 0, i === void 0 ? null : i));
}
function H_(n, e, t, i) {
  var r = $s();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (fi !== null) {
    var o = fi.memoizedState;
    if (((s = o.destroy), i !== null && LE(i, o.deps))) {
      r.memoizedState = im(e, t, s, i);
      return;
    }
  }
  (Un.flags |= n), (r.memoizedState = im(1 | e, t, s, i));
}
function hP(n, e) {
  return Dv(8390656, 8, n, e);
}
function OE(n, e) {
  return H_(2048, 8, n, e);
}
function g3(n, e) {
  return H_(4, 2, n, e);
}
function v3(n, e) {
  return H_(4, 4, n, e);
}
function y3(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function _3(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), H_(4, 4, y3.bind(null, e, n), t)
  );
}
function UE() {}
function x3(n, e) {
  var t = $s();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && LE(e, i[1])
    ? i[0]
    : ((t.memoizedState = [n, e]), n);
}
function A3(n, e) {
  var t = $s();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && LE(e, i[1])
    ? i[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function S3(n, e, t) {
  return vc & 21
    ? (_o(t, e) || ((t = CL()), (Un.lanes |= t), (yc |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (Ur = !0)), (n.memoizedState = t));
}
function cG(n, e) {
  var t = mn;
  (mn = t !== 0 && 4 > t ? t : 4), n(!0);
  var i = d1.transition;
  d1.transition = {};
  try {
    n(!1), e();
  } finally {
    (mn = t), (d1.transition = i);
  }
}
function M3() {
  return $s().memoizedState;
}
function fG(n, e, t) {
  var i = Pl(n);
  if (
    ((t = {
      lane: i,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    w3(n))
  )
    E3(e, t);
  else if (((t = s3(n, e, t, i)), t !== null)) {
    var r = xr();
    go(t, n, i, r), T3(t, e, i);
  }
}
function hG(n, e, t) {
  var i = Pl(n),
    r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (w3(n)) E3(e, r);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((r.hasEagerState = !0), (r.eagerState = a), _o(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((r.next = r), RE(e))
            : ((r.next = l.next), (l.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (t = s3(n, e, r, i)),
      t !== null && ((r = xr()), go(t, n, i, r), T3(t, e, i));
  }
}
function w3(n) {
  var e = n.alternate;
  return n === Un || (e !== null && e === Un);
}
function E3(n, e) {
  fp = my = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function T3(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), mE(n, t);
  }
}
var gy = {
    readContext: qs,
    useCallback: Vi,
    useContext: Vi,
    useEffect: Vi,
    useImperativeHandle: Vi,
    useInsertionEffect: Vi,
    useLayoutEffect: Vi,
    useMemo: Vi,
    useReducer: Vi,
    useRef: Vi,
    useState: Vi,
    useDebugValue: Vi,
    useDeferredValue: Vi,
    useTransition: Vi,
    useMutableSource: Vi,
    useSyncExternalStore: Vi,
    useId: Vi,
    unstable_isNewReconciler: !1,
  },
  dG = {
    readContext: qs,
    useCallback: function (n, e) {
      return (Do().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: qs,
    useEffect: hP,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        Dv(4194308, 4, y3.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return Dv(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return Dv(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = Do();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var i = Do();
      return (
        (e = t !== void 0 ? t(e) : e),
        (i.memoizedState = i.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (i.queue = n),
        (n = n.dispatch = fG.bind(null, Un, n)),
        [i.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = Do();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: fP,
    useDebugValue: UE,
    useDeferredValue: function (n) {
      return (Do().memoizedState = n);
    },
    useTransition: function () {
      var n = fP(!1),
        e = n[0];
      return (n = cG.bind(null, n[1])), (Do().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var i = Un,
        r = Do();
      if (Cn) {
        if (t === void 0) throw Error(Be(407));
        t = t();
      } else {
        if (((t = e()), Ci === null)) throw Error(Be(349));
        vc & 30 || c3(i, e, t);
      }
      r.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (r.queue = s),
        hP(h3.bind(null, i, s, n), [n]),
        (i.flags |= 2048),
        im(9, f3.bind(null, i, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = Do(),
        e = Ci.identifierPrefix;
      if (Cn) {
        var t = Aa,
          i = xa;
        (t = (i & ~(1 << (32 - mo(i) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = tm++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = uG++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  pG = {
    readContext: qs,
    useCallback: x3,
    useContext: qs,
    useEffect: OE,
    useImperativeHandle: _3,
    useInsertionEffect: g3,
    useLayoutEffect: v3,
    useMemo: A3,
    useReducer: p1,
    useRef: m3,
    useState: function () {
      return p1(nm);
    },
    useDebugValue: UE,
    useDeferredValue: function (n) {
      var e = $s();
      return S3(e, fi.memoizedState, n);
    },
    useTransition: function () {
      var n = p1(nm)[0],
        e = $s().memoizedState;
      return [n, e];
    },
    useMutableSource: l3,
    useSyncExternalStore: u3,
    useId: M3,
    unstable_isNewReconciler: !1,
  },
  mG = {
    readContext: qs,
    useCallback: x3,
    useContext: qs,
    useEffect: OE,
    useImperativeHandle: _3,
    useInsertionEffect: g3,
    useLayoutEffect: v3,
    useMemo: A3,
    useReducer: m1,
    useRef: m3,
    useState: function () {
      return m1(nm);
    },
    useDebugValue: UE,
    useDeferredValue: function (n) {
      var e = $s();
      return fi === null ? (e.memoizedState = n) : S3(e, fi.memoizedState, n);
    },
    useTransition: function () {
      var n = m1(nm)[0],
        e = $s().memoizedState;
      return [n, e];
    },
    useMutableSource: l3,
    useSyncExternalStore: u3,
    useId: M3,
    unstable_isNewReconciler: !1,
  };
function lo(n, e) {
  if (n && n.defaultProps) {
    (e = kn({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
function CM(n, e, t, i) {
  (e = n.memoizedState),
    (t = t(i, e)),
    (t = t == null ? e : kn({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var G_ = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? Lc(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var i = xr(),
      r = Pl(n),
      s = Ta(i, r);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = bl(n, s, r)),
      e !== null && (go(e, n, r, i), Bv(e, n, r));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var i = xr(),
      r = Pl(n),
      s = Ta(i, r);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = bl(n, s, r)),
      e !== null && (go(e, n, r, i), Bv(e, n, r));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = xr(),
      i = Pl(n),
      r = Ta(t, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = bl(n, r, i)),
      e !== null && (go(e, n, i, t), Bv(e, n, i));
  },
};
function dP(n, e, t, i, r, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(i, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Kp(t, i) || !Kp(r, s)
      : !0
  );
}
function C3(n, e, t) {
  var i = !1,
    r = Ul,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = qs(s))
      : ((r = Gr(e) ? mc : nr.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? yh(n, r) : Ul)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = G_),
    (n.stateNode = e),
    (e._reactInternals = n),
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = r),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function pP(n, e, t, i) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && G_.enqueueReplaceState(e, e.state, null);
}
function bM(n, e, t, i) {
  var r = n.stateNode;
  (r.props = t), (r.state = n.memoizedState), (r.refs = {}), PE(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (r.context = qs(s))
    : ((s = Gr(e) ? mc : nr.current), (r.context = yh(n, s))),
    (r.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (CM(n, e, s, t), (r.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && G_.enqueueReplaceState(r, r.state, null),
      dy(n, t, r, i),
      (r.state = n.memoizedState)),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308);
}
function Sh(n, e) {
  try {
    var t = "",
      i = e;
    do (t += V4(i)), (i = i.return);
    while (i);
    var r = t;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function g1(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function RM(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var gG = typeof WeakMap == "function" ? WeakMap : Map;
function b3(n, e, t) {
  (t = Ta(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var i = e.value;
  return (
    (t.callback = function () {
      yy || ((yy = !0), (kM = i)), RM(n, e);
    }),
    t
  );
}
function R3(n, e, t) {
  (t = Ta(-1, t)), (t.tag = 3);
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (t.payload = function () {
      return i(r);
    }),
      (t.callback = function () {
        RM(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        RM(n, e),
          typeof i != "function" &&
            (Rl === null ? (Rl = new Set([this])) : Rl.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function mP(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new gG();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(t) || (r.add(t), (n = PG.bind(null, n, e, t)), e.then(n, n));
}
function gP(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function vP(n, e, t, i, r) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = r), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = Ta(-1, 1)), (e.tag = 2), bl(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var vG = Va.ReactCurrentOwner,
  Ur = !1;
function pr(n, e, t, i) {
  e.child = n === null ? r3(e, null, t, i) : xh(e, n.child, t, i);
}
function yP(n, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return (
    sh(e, r),
    (i = FE(n, e, t, i, s, r)),
    (t = NE()),
    n !== null && !Ur
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Na(n, e, r))
      : (Cn && t && ME(e), (e.flags |= 1), pr(n, e, i, r), e.child)
  );
}
function _P(n, e, t, i, r) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !JE(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), P3(n, e, s, i, r))
      : ((n = Ov(t.type, null, i, e, e.mode, r)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & r))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : Kp), t(o, i) && n.ref === e.ref)
    )
      return Na(n, e, r);
  }
  return (
    (e.flags |= 1),
    (n = Bl(s, i)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function P3(n, e, t, i, r) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (Kp(s, i) && n.ref === e.ref)
      if (((Ur = !1), (e.pendingProps = i = s), (n.lanes & r) !== 0))
        n.flags & 131072 && (Ur = !0);
      else return (e.lanes = n.lanes), Na(n, e, r);
  }
  return PM(n, e, t, i, r);
}
function B3(n, e, t) {
  var i = e.pendingProps,
    r = i.children,
    s = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Mn(Vf, rs),
        (rs |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          Mn(Vf, rs),
          (rs |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : t),
        Mn(Vf, rs),
        (rs |= i);
    }
  else
    s !== null ? ((i = s.baseLanes | t), (e.memoizedState = null)) : (i = t),
      Mn(Vf, rs),
      (rs |= i);
  return pr(n, e, r, t), e.child;
}
function I3(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function PM(n, e, t, i, r) {
  var s = Gr(t) ? mc : nr.current;
  return (
    (s = yh(e, s)),
    sh(e, r),
    (t = FE(n, e, t, i, s, r)),
    (i = NE()),
    n !== null && !Ur
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Na(n, e, r))
      : (Cn && i && ME(e), (e.flags |= 1), pr(n, e, t, r), e.child)
  );
}
function xP(n, e, t, i, r) {
  if (Gr(t)) {
    var s = !0;
    ly(e);
  } else s = !1;
  if ((sh(e, r), e.stateNode === null))
    Lv(n, e), C3(e, t, i), bM(e, t, i, r), (i = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      u = t.contextType;
    typeof u == "object" && u !== null
      ? (u = qs(u))
      : ((u = Gr(t) ? mc : nr.current), (u = yh(e, u)));
    var c = t.getDerivedStateFromProps,
      d =
        typeof c == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== i || l !== u) && pP(e, o, i, u)),
      (hl = !1);
    var p = e.memoizedState;
    (o.state = p),
      dy(e, i, o, r),
      (l = e.memoizedState),
      a !== i || p !== l || Hr.current || hl
        ? (typeof c == "function" && (CM(e, t, c, i), (l = e.memoizedState)),
          (a = hl || dP(e, t, a, i, p, l, u))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = l)),
          (o.props = i),
          (o.state = l),
          (o.context = u),
          (i = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (o = e.stateNode),
      o3(n, e),
      (a = e.memoizedProps),
      (u = e.type === e.elementType ? a : lo(e.type, a)),
      (o.props = u),
      (d = e.pendingProps),
      (p = o.context),
      (l = t.contextType),
      typeof l == "object" && l !== null
        ? (l = qs(l))
        : ((l = Gr(t) ? mc : nr.current), (l = yh(e, l)));
    var m = t.getDerivedStateFromProps;
    (c =
      typeof m == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || p !== l) && pP(e, o, i, l)),
      (hl = !1),
      (p = e.memoizedState),
      (o.state = p),
      dy(e, i, o, r);
    var v = e.memoizedState;
    a !== d || p !== v || Hr.current || hl
      ? (typeof m == "function" && (CM(e, t, m, i), (v = e.memoizedState)),
        (u = hl || dP(e, t, u, i, p, v, l) || !1)
          ? (c ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(i, v, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(i, v, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = v)),
        (o.props = i),
        (o.state = v),
        (o.context = l),
        (i = u))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return BM(n, e, t, i, s, r);
}
function BM(n, e, t, i, r, s) {
  I3(n, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && sP(e, t, !1), Na(n, e, s);
  (i = e.stateNode), (vG.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = xh(e, n.child, null, s)), (e.child = xh(e, null, a, s)))
      : pr(n, e, a, s),
    (e.memoizedState = i.state),
    r && sP(e, t, !0),
    e.child
  );
}
function D3(n) {
  var e = n.stateNode;
  e.pendingContext
    ? rP(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && rP(n, e.context, !1),
    BE(n, e.containerInfo);
}
function AP(n, e, t, i, r) {
  return _h(), EE(r), (e.flags |= 256), pr(n, e, t, i), e.child;
}
var IM = { dehydrated: null, treeContext: null, retryLane: 0 };
function DM(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function L3(n, e, t) {
  var i = e.pendingProps,
    r = Dn.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (r |= 1),
    Mn(Dn, r & 1),
    n === null)
  )
    return (
      EM(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = i.children),
          (n = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = X_(o, i, 0, null)),
              (n = tc(n, i, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = DM(t)),
              (e.memoizedState = IM),
              n)
            : kE(e, o))
    );
  if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return yG(n, e, o, i, a, r, t);
  if (s) {
    (s = i.fallback), (o = e.mode), (r = n.child), (a = r.sibling);
    var l = { mode: "hidden", children: i.children };
    return (
      !(o & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = l),
          (e.deletions = null))
        : ((i = Bl(r, l)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (s = Bl(a, s)) : ((s = tc(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? DM(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = IM),
      i
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (i = Bl(s, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = t),
    (i.return = e),
    (i.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function kE(n, e) {
  return (
    (e = X_({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function c0(n, e, t, i) {
  return (
    i !== null && EE(i),
    xh(e, n.child, null, t),
    (n = kE(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function yG(n, e, t, i, r, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (i = g1(Error(Be(422)))), c0(n, e, o, i))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((s = i.fallback),
        (r = e.mode),
        (i = X_({ mode: "visible", children: i.children }, r, 0, null)),
        (s = tc(s, r, o, null)),
        (s.flags |= 2),
        (i.return = e),
        (s.return = e),
        (i.sibling = s),
        (e.child = i),
        e.mode & 1 && xh(e, n.child, null, o),
        (e.child.memoizedState = DM(o)),
        (e.memoizedState = IM),
        s);
  if (!(e.mode & 1)) return c0(n, e, o, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a), (s = Error(Be(419))), (i = g1(s, i, void 0)), c0(n, e, o, i)
    );
  }
  if (((a = (o & n.childLanes) !== 0), Ur || a)) {
    if (((i = Ci), i !== null)) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | o) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), Fa(n, r), go(i, n, r, -1));
    }
    return XE(), (i = g1(Error(Be(421)))), c0(n, e, o, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = BG.bind(null, n)),
      (r._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (cs = Cl(r.nextSibling)),
      (ps = e),
      (Cn = !0),
      (fo = null),
      n !== null &&
        ((ks[zs++] = xa),
        (ks[zs++] = Aa),
        (ks[zs++] = gc),
        (xa = n.id),
        (Aa = n.overflow),
        (gc = e)),
      (e = kE(e, i.children)),
      (e.flags |= 4096),
      e);
}
function SP(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  i !== null && (i.lanes |= e), TM(n.return, e, t);
}
function v1(n, e, t, i, r) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = t),
      (s.tailMode = r));
}
function F3(n, e, t) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((pr(n, e, i.children, t), (i = Dn.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && SP(n, t, e);
        else if (n.tag === 19) SP(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    i &= 1;
  }
  if ((Mn(Dn, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          (n = t.alternate),
            n !== null && py(n) === null && (r = t),
            (t = t.sibling);
        (t = r),
          t === null
            ? ((r = e.child), (e.child = null))
            : ((r = t.sibling), (t.sibling = null)),
          v1(e, !1, r, t, s);
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (((n = r.alternate), n !== null && py(n) === null)) {
            e.child = r;
            break;
          }
          (n = r.sibling), (r.sibling = t), (t = r), (r = n);
        }
        v1(e, !0, t, null, s);
        break;
      case "together":
        v1(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function Lv(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Na(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (yc |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(Be(153));
  if (e.child !== null) {
    for (
      n = e.child, t = Bl(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = Bl(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function _G(n, e, t) {
  switch (e.tag) {
    case 3:
      D3(e), _h();
      break;
    case 5:
      a3(e);
      break;
    case 1:
      Gr(e.type) && ly(e);
      break;
    case 4:
      BE(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      Mn(fy, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (Mn(Dn, Dn.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? L3(n, e, t)
          : (Mn(Dn, Dn.current & 1),
            (n = Na(n, e, t)),
            n !== null ? n.sibling : null);
      Mn(Dn, Dn.current & 1);
      break;
    case 19:
      if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (i) return F3(n, e, t);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        Mn(Dn, Dn.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), B3(n, e, t);
  }
  return Na(n, e, t);
}
var N3, LM, O3, U3;
N3 = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
LM = function () {};
O3 = function (n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    (n = e.stateNode), Gu(Go.current);
    var s = null;
    switch (t) {
      case "input":
        (r = nM(n, r)), (i = nM(n, i)), (s = []);
        break;
      case "select":
        (r = kn({}, r, { value: void 0 })),
          (i = kn({}, i, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (r = sM(n, r)), (i = sM(n, i)), (s = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (n.onclick = oy);
    }
    aM(t, i);
    var o;
    t = null;
    for (u in r)
      if (!i.hasOwnProperty(u) && r.hasOwnProperty(u) && r[u] != null)
        if (u === "style") {
          var a = r[u];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          u !== "dangerouslySetInnerHTML" &&
            u !== "children" &&
            u !== "suppressContentEditableWarning" &&
            u !== "suppressHydrationWarning" &&
            u !== "autoFocus" &&
            (Gp.hasOwnProperty(u)
              ? s || (s = [])
              : (s = s || []).push(u, null));
    for (u in i) {
      var l = i[u];
      if (
        ((a = r != null ? r[u] : void 0),
        i.hasOwnProperty(u) && l !== a && (l != null || a != null))
      )
        if (u === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (t || (t = {}), (t[o] = l[o]));
          } else t || (s || (s = []), s.push(u, t)), (t = l);
        else
          u === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(u, l))
            : u === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(u, "" + l)
            : u !== "suppressContentEditableWarning" &&
              u !== "suppressHydrationWarning" &&
              (Gp.hasOwnProperty(u)
                ? (l != null && u === "onScroll" && wn("scroll", n),
                  s || a === l || (s = []))
                : (s = s || []).push(u, l));
    }
    t && (s = s || []).push("style", t);
    var u = s;
    (e.updateQueue = u) && (e.flags |= 4);
  }
};
U3 = function (n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Sd(n, e) {
  if (!Cn)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          t.alternate !== null && (i = t), (t = t.sibling);
        i === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (i.sibling = null);
    }
}
function Wi(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = n),
        (r = r.sibling);
  else
    for (r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = n),
        (r = r.sibling);
  return (n.subtreeFlags |= i), (n.childLanes = t), e;
}
function xG(n, e, t) {
  var i = e.pendingProps;
  switch ((wE(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Wi(e), null;
    case 1:
      return Gr(e.type) && ay(), Wi(e), null;
    case 3:
      return (
        (i = e.stateNode),
        Ah(),
        En(Hr),
        En(nr),
        DE(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (n === null || n.child === null) &&
          (l0(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), fo !== null && (GM(fo), (fo = null)))),
        LM(n, e),
        Wi(e),
        null
      );
    case 5:
      IE(e);
      var r = Gu(em.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        O3(n, e, t, i, r),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(Be(166));
          return Wi(e), null;
        }
        if (((n = Gu(Go.current)), l0(e))) {
          (i = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((i[Oo] = e), (i[qp] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              wn("cancel", i), wn("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              wn("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < Kd.length; r++) wn(Kd[r], i);
              break;
            case "source":
              wn("error", i);
              break;
            case "img":
            case "image":
            case "link":
              wn("error", i), wn("load", i);
              break;
            case "details":
              wn("toggle", i);
              break;
            case "input":
              BR(i, s), wn("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!s.multiple }),
                wn("invalid", i);
              break;
            case "textarea":
              DR(i, s), wn("invalid", i);
          }
          aM(t, s), (r = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      a0(i.textContent, a, n),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      a0(i.textContent, a, n),
                    (r = ["children", "" + a]))
                : Gp.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  wn("scroll", i);
            }
          switch (t) {
            case "input":
              $g(i), IR(i, s, !0);
              break;
            case "textarea":
              $g(i), LR(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = oy);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (o = r.nodeType === 9 ? r : r.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = hL(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof i.is == "string"
                ? (n = o.createElement(t, { is: i.is }))
                : ((n = o.createElement(t)),
                  t === "select" &&
                    ((o = n),
                    i.multiple
                      ? (o.multiple = !0)
                      : i.size && (o.size = i.size)))
              : (n = o.createElementNS(n, t)),
            (n[Oo] = e),
            (n[qp] = i),
            N3(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = lM(t, i)), t)) {
              case "dialog":
                wn("cancel", n), wn("close", n), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                wn("load", n), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < Kd.length; r++) wn(Kd[r], n);
                r = i;
                break;
              case "source":
                wn("error", n), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                wn("error", n), wn("load", n), (r = i);
                break;
              case "details":
                wn("toggle", n), (r = i);
                break;
              case "input":
                BR(n, i), (r = nM(n, i)), wn("invalid", n);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = kn({}, i, { value: void 0 })),
                  wn("invalid", n);
                break;
              case "textarea":
                DR(n, i), (r = sM(n, i)), wn("invalid", n);
                break;
              default:
                r = i;
            }
            aM(t, r), (a = r);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? mL(n, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && dL(n, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (t !== "textarea" || l !== "") && Vp(n, l)
                    : typeof l == "number" && Vp(n, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (Gp.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && wn("scroll", n)
                      : l != null && uE(n, s, l, o));
              }
            switch (t) {
              case "input":
                $g(n), IR(n, i, !1);
                break;
              case "textarea":
                $g(n), LR(n);
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + Ol(i.value));
                break;
              case "select":
                (n.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? th(n, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      th(n, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = oy);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return Wi(e), null;
    case 6:
      if (n && e.stateNode != null) U3(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(Be(166));
        if (((t = Gu(em.current)), Gu(Go.current), l0(e))) {
          if (
            ((i = e.stateNode),
            (t = e.memoizedProps),
            (i[Oo] = e),
            (s = i.nodeValue !== t) && ((n = ps), n !== null))
          )
            switch (n.tag) {
              case 3:
                a0(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  a0(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
            (i[Oo] = e),
            (e.stateNode = i);
      }
      return Wi(e), null;
    case 13:
      if (
        (En(Dn),
        (i = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if (Cn && cs !== null && e.mode & 1 && !(e.flags & 128))
          n3(), _h(), (e.flags |= 98560), (s = !1);
        else if (((s = l0(e)), i !== null && i.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(Be(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(Be(317));
            s[Oo] = e;
          } else
            _h(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          Wi(e), (s = !1);
        } else fo !== null && (GM(fo), (fo = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((i = i !== null),
          i !== (n !== null && n.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || Dn.current & 1 ? di === 0 && (di = 3) : XE())),
          e.updateQueue !== null && (e.flags |= 4),
          Wi(e),
          null);
    case 4:
      return (
        Ah(), LM(n, e), n === null && Qp(e.stateNode.containerInfo), Wi(e), null
      );
    case 10:
      return bE(e.type._context), Wi(e), null;
    case 17:
      return Gr(e.type) && ay(), Wi(e), null;
    case 19:
      if ((En(Dn), (s = e.memoizedState), s === null)) return Wi(e), null;
      if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (i) Sd(s, !1);
        else {
          if (di !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = py(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    Sd(s, !1),
                    i = o.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = i),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return Mn(Dn, (Dn.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            Qn() > Mh &&
            ((e.flags |= 128), (i = !0), Sd(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((n = py(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              Sd(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !Cn)
            )
              return Wi(e), null;
          } else
            2 * Qn() - s.renderingStartTime > Mh &&
              t !== 1073741824 &&
              ((e.flags |= 128), (i = !0), Sd(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Qn()),
          (e.sibling = null),
          (t = Dn.current),
          Mn(Dn, i ? (t & 1) | 2 : t & 1),
          e)
        : (Wi(e), null);
    case 22:
    case 23:
      return (
        WE(),
        (i = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? rs & 1073741824 && (Wi(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : Wi(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Be(156, e.tag));
}
function AG(n, e) {
  switch ((wE(e), e.tag)) {
    case 1:
      return (
        Gr(e.type) && ay(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        Ah(),
        En(Hr),
        En(nr),
        DE(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return IE(e), null;
    case 13:
      if (
        (En(Dn), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(Be(340));
        _h();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return En(Dn), null;
    case 4:
      return Ah(), null;
    case 10:
      return bE(e.type._context), null;
    case 22:
    case 23:
      return WE(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var f0 = !1,
  Qi = !1,
  SG = typeof WeakSet == "function" ? WeakSet : Set,
  ot = null;
function Gf(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        Gn(n, e, i);
      }
    else t.current = null;
}
function FM(n, e, t) {
  try {
    t();
  } catch (i) {
    Gn(n, e, i);
  }
}
var MP = !1;
function MG(n, e) {
  if (((yM = iy), (n = VL()), SE(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            u = 0,
            c = 0,
            d = n,
            p = null;
          t: for (;;) {
            for (
              var m;
              d !== t || (r !== 0 && d.nodeType !== 3) || (a = o + r),
                d !== s || (i !== 0 && d.nodeType !== 3) || (l = o + i),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (m = d.firstChild) !== null;

            )
              (p = d), (d = m);
            for (;;) {
              if (d === n) break t;
              if (
                (p === t && ++u === r && (a = o),
                p === s && ++c === i && (l = o),
                (m = d.nextSibling) !== null)
              )
                break;
              (d = p), (p = d.parentNode);
            }
            d = m;
          }
          t = a === -1 || l === -1 ? null : { start: a, end: l };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    _M = { focusedElem: n, selectionRange: t }, iy = !1, ot = e;
    ot !== null;

  )
    if (((e = ot), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (ot = n);
    else
      for (; ot !== null; ) {
        e = ot;
        try {
          var v = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (v !== null) {
                  var _ = v.memoizedProps,
                    x = v.memoizedState,
                    g = e.stateNode,
                    A = g.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? _ : lo(e.type, _),
                      x
                    );
                  g.__reactInternalSnapshotBeforeUpdate = A;
                }
                break;
              case 3:
                var S = e.stateNode.containerInfo;
                S.nodeType === 1
                  ? (S.textContent = "")
                  : S.nodeType === 9 &&
                    S.documentElement &&
                    S.removeChild(S.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Be(163));
            }
        } catch (w) {
          Gn(e, e.return, w);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (ot = n);
          break;
        }
        ot = e.return;
      }
  return (v = MP), (MP = !1), v;
}
function hp(n, e, t) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & n) === n) {
        var s = r.destroy;
        (r.destroy = void 0), s !== void 0 && FM(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function V_(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function NM(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function k3(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), k3(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[Oo], delete e[qp], delete e[SM], delete e[sG], delete e[oG])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function z3(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function wP(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || z3(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function OM(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = oy));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (OM(n, e, t), n = n.sibling; n !== null; ) OM(n, e, t), (n = n.sibling);
}
function UM(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (i !== 4 && ((n = n.child), n !== null))
    for (UM(n, e, t), n = n.sibling; n !== null; ) UM(n, e, t), (n = n.sibling);
}
var Di = null,
  co = !1;
function el(n, e, t) {
  for (t = t.child; t !== null; ) H3(n, e, t), (t = t.sibling);
}
function H3(n, e, t) {
  if (Ho && typeof Ho.onCommitFiberUnmount == "function")
    try {
      Ho.onCommitFiberUnmount(F_, t);
    } catch {}
  switch (t.tag) {
    case 5:
      Qi || Gf(t, e);
    case 6:
      var i = Di,
        r = co;
      (Di = null),
        el(n, e, t),
        (Di = i),
        (co = r),
        Di !== null &&
          (co
            ? ((n = Di),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : Di.removeChild(t.stateNode));
      break;
    case 18:
      Di !== null &&
        (co
          ? ((n = Di),
            (t = t.stateNode),
            n.nodeType === 8
              ? c1(n.parentNode, t)
              : n.nodeType === 1 && c1(n, t),
            jp(n))
          : c1(Di, t.stateNode));
      break;
    case 4:
      (i = Di),
        (r = co),
        (Di = t.stateNode.containerInfo),
        (co = !0),
        el(n, e, t),
        (Di = i),
        (co = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Qi &&
        ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && FM(t, e, o),
            (r = r.next);
        } while (r !== i);
      }
      el(n, e, t);
      break;
    case 1:
      if (
        !Qi &&
        (Gf(t, e),
        (i = t.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = t.memoizedProps),
            (i.state = t.memoizedState),
            i.componentWillUnmount();
        } catch (a) {
          Gn(t, e, a);
        }
      el(n, e, t);
      break;
    case 21:
      el(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((Qi = (i = Qi) || t.memoizedState !== null), el(n, e, t), (Qi = i))
        : el(n, e, t);
      break;
    default:
      el(n, e, t);
  }
}
function EP(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new SG()),
      e.forEach(function (i) {
        var r = IG.bind(null, n, i);
        t.has(i) || (t.add(i), i.then(r, r));
      });
  }
}
function io(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Di = a.stateNode), (co = !1);
              break e;
            case 3:
              (Di = a.stateNode.containerInfo), (co = !0);
              break e;
            case 4:
              (Di = a.stateNode.containerInfo), (co = !0);
              break e;
          }
          a = a.return;
        }
        if (Di === null) throw Error(Be(160));
        H3(s, o, r), (Di = null), (co = !1);
        var l = r.alternate;
        l !== null && (l.return = null), (r.return = null);
      } catch (u) {
        Gn(r, e, u);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) G3(e, n), (e = e.sibling);
}
function G3(n, e) {
  var t = n.alternate,
    i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((io(e, n), Io(n), i & 4)) {
        try {
          hp(3, n, n.return), V_(3, n);
        } catch (_) {
          Gn(n, n.return, _);
        }
        try {
          hp(5, n, n.return);
        } catch (_) {
          Gn(n, n.return, _);
        }
      }
      break;
    case 1:
      io(e, n), Io(n), i & 512 && t !== null && Gf(t, t.return);
      break;
    case 5:
      if (
        (io(e, n),
        Io(n),
        i & 512 && t !== null && Gf(t, t.return),
        n.flags & 32)
      ) {
        var r = n.stateNode;
        try {
          Vp(r, "");
        } catch (_) {
          Gn(n, n.return, _);
        }
      }
      if (i & 4 && ((r = n.stateNode), r != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          l = n.updateQueue;
        if (((n.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && cL(r, s),
              lM(a, o);
            var u = lM(a, s);
            for (o = 0; o < l.length; o += 2) {
              var c = l[o],
                d = l[o + 1];
              c === "style"
                ? mL(r, d)
                : c === "dangerouslySetInnerHTML"
                ? dL(r, d)
                : c === "children"
                ? Vp(r, d)
                : uE(r, c, d, u);
            }
            switch (a) {
              case "input":
                iM(r, s);
                break;
              case "textarea":
                fL(r, s);
                break;
              case "select":
                var p = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var m = s.value;
                m != null
                  ? th(r, !!s.multiple, m, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? th(r, !!s.multiple, s.defaultValue, !0)
                      : th(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[qp] = s;
          } catch (_) {
            Gn(n, n.return, _);
          }
      }
      break;
    case 6:
      if ((io(e, n), Io(n), i & 4)) {
        if (n.stateNode === null) throw Error(Be(162));
        (r = n.stateNode), (s = n.memoizedProps);
        try {
          r.nodeValue = s;
        } catch (_) {
          Gn(n, n.return, _);
        }
      }
      break;
    case 3:
      if (
        (io(e, n), Io(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          jp(e.containerInfo);
        } catch (_) {
          Gn(n, n.return, _);
        }
      break;
    case 4:
      io(e, n), Io(n);
      break;
    case 13:
      io(e, n),
        Io(n),
        (r = n.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (GE = Qn())),
        i & 4 && EP(n);
      break;
    case 22:
      if (
        ((c = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((Qi = (u = Qi) || c), io(e, n), (Qi = u)) : io(e, n),
        Io(n),
        i & 8192)
      ) {
        if (
          ((u = n.memoizedState !== null),
          (n.stateNode.isHidden = u) && !c && n.mode & 1)
        )
          for (ot = n, c = n.child; c !== null; ) {
            for (d = ot = c; ot !== null; ) {
              switch (((p = ot), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  hp(4, p, p.return);
                  break;
                case 1:
                  Gf(p, p.return);
                  var v = p.stateNode;
                  if (typeof v.componentWillUnmount == "function") {
                    (i = p), (t = p.return);
                    try {
                      (e = i),
                        (v.props = e.memoizedProps),
                        (v.state = e.memoizedState),
                        v.componentWillUnmount();
                    } catch (_) {
                      Gn(i, t, _);
                    }
                  }
                  break;
                case 5:
                  Gf(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    CP(d);
                    continue;
                  }
              }
              m !== null ? ((m.return = p), (ot = m)) : CP(d);
            }
            c = c.sibling;
          }
        e: for (c = null, d = n; ; ) {
          if (d.tag === 5) {
            if (c === null) {
              c = d;
              try {
                (r = d.stateNode),
                  u
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = pL("display", o)));
              } catch (_) {
                Gn(n, n.return, _);
              }
            }
          } else if (d.tag === 6) {
            if (c === null)
              try {
                d.stateNode.nodeValue = u ? "" : d.memoizedProps;
              } catch (_) {
                Gn(n, n.return, _);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === n) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === n) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n) break e;
            c === d && (c = null), (d = d.return);
          }
          c === d && (c = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      io(e, n), Io(n), i & 4 && EP(n);
      break;
    case 21:
      break;
    default:
      io(e, n), Io(n);
  }
}
function Io(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (z3(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(Be(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (Vp(r, ""), (i.flags &= -33));
          var s = wP(n);
          UM(n, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo,
            a = wP(n);
          OM(n, a, o);
          break;
        default:
          throw Error(Be(161));
      }
    } catch (l) {
      Gn(n, n.return, l);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function wG(n, e, t) {
  (ot = n), V3(n);
}
function V3(n, e, t) {
  for (var i = (n.mode & 1) !== 0; ot !== null; ) {
    var r = ot,
      s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || f0;
      if (!o) {
        var a = r.alternate,
          l = (a !== null && a.memoizedState !== null) || Qi;
        a = f0;
        var u = Qi;
        if (((f0 = o), (Qi = l) && !u))
          for (ot = r; ot !== null; )
            (o = ot),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? bP(r)
                : l !== null
                ? ((l.return = o), (ot = l))
                : bP(r);
        for (; s !== null; ) (ot = s), V3(s), (s = s.sibling);
        (ot = r), (f0 = a), (Qi = u);
      }
      TP(n);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (ot = s)) : TP(n);
  }
}
function TP(n) {
  for (; ot !== null; ) {
    var e = ot;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Qi || V_(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !Qi)
                if (t === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : lo(e.type, t.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    t.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && cP(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                cP(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && t.focus();
                    break;
                  case "img":
                    l.src && (t.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var u = e.alternate;
                if (u !== null) {
                  var c = u.memoizedState;
                  if (c !== null) {
                    var d = c.dehydrated;
                    d !== null && jp(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Be(163));
          }
        Qi || (e.flags & 512 && NM(e));
      } catch (p) {
        Gn(e, e.return, p);
      }
    }
    if (e === n) {
      ot = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (ot = t);
      break;
    }
    ot = e.return;
  }
}
function CP(n) {
  for (; ot !== null; ) {
    var e = ot;
    if (e === n) {
      ot = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (ot = t);
      break;
    }
    ot = e.return;
  }
}
function bP(n) {
  for (; ot !== null; ) {
    var e = ot;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            V_(4, e);
          } catch (l) {
            Gn(e, t, l);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (l) {
              Gn(e, r, l);
            }
          }
          var s = e.return;
          try {
            NM(e);
          } catch (l) {
            Gn(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            NM(e);
          } catch (l) {
            Gn(e, o, l);
          }
      }
    } catch (l) {
      Gn(e, e.return, l);
    }
    if (e === n) {
      ot = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (ot = a);
      break;
    }
    ot = e.return;
  }
}
var EG = Math.ceil,
  vy = Va.ReactCurrentDispatcher,
  zE = Va.ReactCurrentOwner,
  Ks = Va.ReactCurrentBatchConfig,
  nn = 0,
  Ci = null,
  ai = null,
  Fi = 0,
  rs = 0,
  Vf = Yl(0),
  di = 0,
  rm = null,
  yc = 0,
  W_ = 0,
  HE = 0,
  dp = null,
  Nr = null,
  GE = 0,
  Mh = 1 / 0,
  fa = null,
  yy = !1,
  kM = null,
  Rl = null,
  h0 = !1,
  yl = null,
  _y = 0,
  pp = 0,
  zM = null,
  Fv = -1,
  Nv = 0;
function xr() {
  return nn & 6 ? Qn() : Fv !== -1 ? Fv : (Fv = Qn());
}
function Pl(n) {
  return n.mode & 1
    ? nn & 2 && Fi !== 0
      ? Fi & -Fi
      : lG.transition !== null
      ? (Nv === 0 && (Nv = CL()), Nv)
      : ((n = mn),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : LL(n.type))),
        n)
    : 1;
}
function go(n, e, t, i) {
  if (50 < pp) throw ((pp = 0), (zM = null), Error(Be(185)));
  Lm(n, t, i),
    (!(nn & 2) || n !== Ci) &&
      (n === Ci && (!(nn & 2) && (W_ |= t), di === 4 && ml(n, Fi)),
      Vr(n, i),
      t === 1 && nn === 0 && !(e.mode & 1) && ((Mh = Qn() + 500), z_ && Kl()));
}
function Vr(n, e) {
  var t = n.callbackNode;
  lH(n, e);
  var i = ny(n, n === Ci ? Fi : 0);
  if (i === 0)
    t !== null && OR(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = i & -i), n.callbackPriority !== e)) {
    if ((t != null && OR(t), e === 1))
      n.tag === 0 ? aG(RP.bind(null, n)) : $L(RP.bind(null, n)),
        iG(function () {
          !(nn & 6) && Kl();
        }),
        (t = null);
    else {
      switch (bL(i)) {
        case 1:
          t = pE;
          break;
        case 4:
          t = EL;
          break;
        case 16:
          t = ty;
          break;
        case 536870912:
          t = TL;
          break;
        default:
          t = ty;
      }
      t = Z3(t, W3.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function W3(n, e) {
  if (((Fv = -1), (Nv = 0), nn & 6)) throw Error(Be(327));
  var t = n.callbackNode;
  if (oh() && n.callbackNode !== t) return null;
  var i = ny(n, n === Ci ? Fi : 0);
  if (i === 0) return null;
  if (i & 30 || i & n.expiredLanes || e) e = xy(n, i);
  else {
    e = i;
    var r = nn;
    nn |= 2;
    var s = J3();
    (Ci !== n || Fi !== e) && ((fa = null), (Mh = Qn() + 500), ec(n, e));
    do
      try {
        bG();
        break;
      } catch (a) {
        X3(n, a);
      }
    while (1);
    CE(),
      (vy.current = s),
      (nn = r),
      ai !== null ? (e = 0) : ((Ci = null), (Fi = 0), (e = di));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = dM(n)), r !== 0 && ((i = r), (e = HM(n, r)))), e === 1)
    )
      throw ((t = rm), ec(n, 0), ml(n, i), Vr(n, Qn()), t);
    if (e === 6) ml(n, i);
    else {
      if (
        ((r = n.current.alternate),
        !(i & 30) &&
          !TG(r) &&
          ((e = xy(n, i)),
          e === 2 && ((s = dM(n)), s !== 0 && ((i = s), (e = HM(n, s)))),
          e === 1))
      )
        throw ((t = rm), ec(n, 0), ml(n, i), Vr(n, Qn()), t);
      switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(Be(345));
        case 2:
          Ru(n, Nr, fa);
          break;
        case 3:
          if (
            (ml(n, i), (i & 130023424) === i && ((e = GE + 500 - Qn()), 10 < e))
          ) {
            if (ny(n, 0) !== 0) break;
            if (((r = n.suspendedLanes), (r & i) !== i)) {
              xr(), (n.pingedLanes |= n.suspendedLanes & r);
              break;
            }
            n.timeoutHandle = AM(Ru.bind(null, n, Nr, fa), e);
            break;
          }
          Ru(n, Nr, fa);
          break;
        case 4:
          if ((ml(n, i), (i & 4194240) === i)) break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - mo(i);
            (s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s);
          }
          if (
            ((i = r),
            (i = Qn() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * EG(i / 1960)) - i),
            10 < i)
          ) {
            n.timeoutHandle = AM(Ru.bind(null, n, Nr, fa), i);
            break;
          }
          Ru(n, Nr, fa);
          break;
        case 5:
          Ru(n, Nr, fa);
          break;
        default:
          throw Error(Be(329));
      }
    }
  }
  return Vr(n, Qn()), n.callbackNode === t ? W3.bind(null, n) : null;
}
function HM(n, e) {
  var t = dp;
  return (
    n.current.memoizedState.isDehydrated && (ec(n, e).flags |= 256),
    (n = xy(n, e)),
    n !== 2 && ((e = Nr), (Nr = t), e !== null && GM(e)),
    n
  );
}
function GM(n) {
  Nr === null ? (Nr = n) : Nr.push.apply(Nr, n);
}
function TG(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!_o(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function ml(n, e) {
  for (
    e &= ~HE,
      e &= ~W_,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - mo(e),
      i = 1 << t;
    (n[t] = -1), (e &= ~i);
  }
}
function RP(n) {
  if (nn & 6) throw Error(Be(327));
  oh();
  var e = ny(n, 0);
  if (!(e & 1)) return Vr(n, Qn()), null;
  var t = xy(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = dM(n);
    i !== 0 && ((e = i), (t = HM(n, i)));
  }
  if (t === 1) throw ((t = rm), ec(n, 0), ml(n, e), Vr(n, Qn()), t);
  if (t === 6) throw Error(Be(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    Ru(n, Nr, fa),
    Vr(n, Qn()),
    null
  );
}
function VE(n, e) {
  var t = nn;
  nn |= 1;
  try {
    return n(e);
  } finally {
    (nn = t), nn === 0 && ((Mh = Qn() + 500), z_ && Kl());
  }
}
function _c(n) {
  yl !== null && yl.tag === 0 && !(nn & 6) && oh();
  var e = nn;
  nn |= 1;
  var t = Ks.transition,
    i = mn;
  try {
    if (((Ks.transition = null), (mn = 1), n)) return n();
  } finally {
    (mn = i), (Ks.transition = t), (nn = e), !(nn & 6) && Kl();
  }
}
function WE() {
  (rs = Vf.current), En(Vf);
}
function ec(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), nG(t)), ai !== null))
    for (t = ai.return; t !== null; ) {
      var i = t;
      switch ((wE(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && ay();
          break;
        case 3:
          Ah(), En(Hr), En(nr), DE();
          break;
        case 5:
          IE(i);
          break;
        case 4:
          Ah();
          break;
        case 13:
          En(Dn);
          break;
        case 19:
          En(Dn);
          break;
        case 10:
          bE(i.type._context);
          break;
        case 22:
        case 23:
          WE();
      }
      t = t.return;
    }
  if (
    ((Ci = n),
    (ai = n = Bl(n.current, null)),
    (Fi = rs = e),
    (di = 0),
    (rm = null),
    (HE = W_ = yc = 0),
    (Nr = dp = null),
    Hu !== null)
  ) {
    for (e = 0; e < Hu.length; e++)
      if (((t = Hu[e]), (i = t.interleaved), i !== null)) {
        t.interleaved = null;
        var r = i.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = r), (i.next = o);
        }
        t.pending = i;
      }
    Hu = null;
  }
  return n;
}
function X3(n, e) {
  do {
    var t = ai;
    try {
      if ((CE(), (Iv.current = gy), my)) {
        for (var i = Un.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        my = !1;
      }
      if (
        ((vc = 0),
        (Ti = fi = Un = null),
        (fp = !1),
        (tm = 0),
        (zE.current = null),
        t === null || t.return === null)
      ) {
        (di = 1), (rm = e), (ai = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          l = e;
        if (
          ((e = Fi),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var u = l,
            c = a,
            d = c.tag;
          if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = c.alternate;
            p
              ? ((c.updateQueue = p.updateQueue),
                (c.memoizedState = p.memoizedState),
                (c.lanes = p.lanes))
              : ((c.updateQueue = null), (c.memoizedState = null));
          }
          var m = gP(o);
          if (m !== null) {
            (m.flags &= -257),
              vP(m, o, a, s, e),
              m.mode & 1 && mP(s, u, e),
              (e = m),
              (l = u);
            var v = e.updateQueue;
            if (v === null) {
              var _ = new Set();
              _.add(l), (e.updateQueue = _);
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              mP(s, u, e), XE();
              break e;
            }
            l = Error(Be(426));
          }
        } else if (Cn && a.mode & 1) {
          var x = gP(o);
          if (x !== null) {
            !(x.flags & 65536) && (x.flags |= 256),
              vP(x, o, a, s, e),
              EE(Sh(l, a));
            break e;
          }
        }
        (s = l = Sh(l, a)),
          di !== 4 && (di = 2),
          dp === null ? (dp = [s]) : dp.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var g = b3(s, l, e);
              uP(s, g);
              break e;
            case 1:
              a = l;
              var A = s.type,
                S = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof A.getDerivedStateFromError == "function" ||
                  (S !== null &&
                    typeof S.componentDidCatch == "function" &&
                    (Rl === null || !Rl.has(S))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var w = R3(s, a, e);
                uP(s, w);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      Y3(t);
    } catch (C) {
      (e = C), ai === t && t !== null && (ai = t = t.return);
      continue;
    }
    break;
  } while (1);
}
function J3() {
  var n = vy.current;
  return (vy.current = gy), n === null ? gy : n;
}
function XE() {
  (di === 0 || di === 3 || di === 2) && (di = 4),
    Ci === null || (!(yc & 268435455) && !(W_ & 268435455)) || ml(Ci, Fi);
}
function xy(n, e) {
  var t = nn;
  nn |= 2;
  var i = J3();
  (Ci !== n || Fi !== e) && ((fa = null), ec(n, e));
  do
    try {
      CG();
      break;
    } catch (r) {
      X3(n, r);
    }
  while (1);
  if ((CE(), (nn = t), (vy.current = i), ai !== null)) throw Error(Be(261));
  return (Ci = null), (Fi = 0), di;
}
function CG() {
  for (; ai !== null; ) j3(ai);
}
function bG() {
  for (; ai !== null && !$4(); ) j3(ai);
}
function j3(n) {
  var e = Q3(n.alternate, n, rs);
  (n.memoizedProps = n.pendingProps),
    e === null ? Y3(n) : (ai = e),
    (zE.current = null);
}
function Y3(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = AG(t, e)), t !== null)) {
        (t.flags &= 32767), (ai = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (di = 6), (ai = null);
        return;
      }
    } else if (((t = xG(t, e, rs)), t !== null)) {
      ai = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      ai = e;
      return;
    }
    ai = e = n;
  } while (e !== null);
  di === 0 && (di = 5);
}
function Ru(n, e, t) {
  var i = mn,
    r = Ks.transition;
  try {
    (Ks.transition = null), (mn = 1), RG(n, e, t, i);
  } finally {
    (Ks.transition = r), (mn = i);
  }
  return null;
}
function RG(n, e, t, i) {
  do oh();
  while (yl !== null);
  if (nn & 6) throw Error(Be(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(Be(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (uH(n, s),
    n === Ci && ((ai = Ci = null), (Fi = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      h0 ||
      ((h0 = !0),
      Z3(ty, function () {
        return oh(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = Ks.transition), (Ks.transition = null);
    var o = mn;
    mn = 1;
    var a = nn;
    (nn |= 4),
      (zE.current = null),
      MG(n, t),
      G3(t, n),
      KH(_M),
      (iy = !!yM),
      (_M = yM = null),
      (n.current = t),
      wG(t),
      eH(),
      (nn = a),
      (mn = o),
      (Ks.transition = s);
  } else n.current = t;
  if (
    (h0 && ((h0 = !1), (yl = n), (_y = r)),
    (s = n.pendingLanes),
    s === 0 && (Rl = null),
    iH(t.stateNode),
    Vr(n, Qn()),
    e !== null)
  )
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      (r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest });
  if (yy) throw ((yy = !1), (n = kM), (kM = null), n);
  return (
    _y & 1 && n.tag !== 0 && oh(),
    (s = n.pendingLanes),
    s & 1 ? (n === zM ? pp++ : ((pp = 0), (zM = n))) : (pp = 0),
    Kl(),
    null
  );
}
function oh() {
  if (yl !== null) {
    var n = bL(_y),
      e = Ks.transition,
      t = mn;
    try {
      if (((Ks.transition = null), (mn = 16 > n ? 16 : n), yl === null))
        var i = !1;
      else {
        if (((n = yl), (yl = null), (_y = 0), nn & 6)) throw Error(Be(331));
        var r = nn;
        for (nn |= 4, ot = n.current; ot !== null; ) {
          var s = ot,
            o = s.child;
          if (ot.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var u = a[l];
                for (ot = u; ot !== null; ) {
                  var c = ot;
                  switch (c.tag) {
                    case 0:
                    case 11:
                    case 15:
                      hp(8, c, s);
                  }
                  var d = c.child;
                  if (d !== null) (d.return = c), (ot = d);
                  else
                    for (; ot !== null; ) {
                      c = ot;
                      var p = c.sibling,
                        m = c.return;
                      if ((k3(c), c === u)) {
                        ot = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = m), (ot = p);
                        break;
                      }
                      ot = m;
                    }
                }
              }
              var v = s.alternate;
              if (v !== null) {
                var _ = v.child;
                if (_ !== null) {
                  v.child = null;
                  do {
                    var x = _.sibling;
                    (_.sibling = null), (_ = x);
                  } while (_ !== null);
                }
              }
              ot = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (ot = o);
          else
            e: for (; ot !== null; ) {
              if (((s = ot), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    hp(9, s, s.return);
                }
              var g = s.sibling;
              if (g !== null) {
                (g.return = s.return), (ot = g);
                break e;
              }
              ot = s.return;
            }
        }
        var A = n.current;
        for (ot = A; ot !== null; ) {
          o = ot;
          var S = o.child;
          if (o.subtreeFlags & 2064 && S !== null) (S.return = o), (ot = S);
          else
            e: for (o = A; ot !== null; ) {
              if (((a = ot), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      V_(9, a);
                  }
                } catch (C) {
                  Gn(a, a.return, C);
                }
              if (a === o) {
                ot = null;
                break e;
              }
              var w = a.sibling;
              if (w !== null) {
                (w.return = a.return), (ot = w);
                break e;
              }
              ot = a.return;
            }
        }
        if (
          ((nn = r), Kl(), Ho && typeof Ho.onPostCommitFiberRoot == "function")
        )
          try {
            Ho.onPostCommitFiberRoot(F_, n);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (mn = t), (Ks.transition = e);
    }
  }
  return !1;
}
function PP(n, e, t) {
  (e = Sh(t, e)),
    (e = b3(n, e, 1)),
    (n = bl(n, e, 1)),
    (e = xr()),
    n !== null && (Lm(n, 1, e), Vr(n, e));
}
function Gn(n, e, t) {
  if (n.tag === 3) PP(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        PP(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (Rl === null || !Rl.has(i)))
        ) {
          (n = Sh(t, n)),
            (n = R3(e, n, 1)),
            (e = bl(e, n, 1)),
            (n = xr()),
            e !== null && (Lm(e, 1, n), Vr(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function PG(n, e, t) {
  var i = n.pingCache;
  i !== null && i.delete(e),
    (e = xr()),
    (n.pingedLanes |= n.suspendedLanes & t),
    Ci === n &&
      (Fi & t) === t &&
      (di === 4 || (di === 3 && (Fi & 130023424) === Fi && 500 > Qn() - GE)
        ? ec(n, 0)
        : (HE |= t)),
    Vr(n, e);
}
function K3(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = n0), (n0 <<= 1), !(n0 & 130023424) && (n0 = 4194304))
      : (e = 1));
  var t = xr();
  (n = Fa(n, e)), n !== null && (Lm(n, e, t), Vr(n, t));
}
function BG(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), K3(n, t);
}
function IG(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode,
        r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(Be(314));
  }
  i !== null && i.delete(e), K3(n, t);
}
var Q3;
Q3 = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || Hr.current) Ur = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (Ur = !1), _G(n, e, t);
      Ur = !!(n.flags & 131072);
    }
  else (Ur = !1), Cn && e.flags & 1048576 && e3(e, cy, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      Lv(n, e), (n = e.pendingProps);
      var r = yh(e, nr.current);
      sh(e, t), (r = FE(null, e, i, n, r, t));
      var s = NE();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Gr(i) ? ((s = !0), ly(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            PE(e),
            (r.updater = G_),
            (e.stateNode = r),
            (r._reactInternals = e),
            bM(e, i, n, t),
            (e = BM(null, e, i, !0, s, t)))
          : ((e.tag = 0), Cn && s && ME(e), pr(null, e, r, t), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (Lv(n, e),
          (n = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = LG(i)),
          (n = lo(i, n)),
          r)
        ) {
          case 0:
            e = PM(null, e, i, n, t);
            break e;
          case 1:
            e = xP(null, e, i, n, t);
            break e;
          case 11:
            e = yP(null, e, i, n, t);
            break e;
          case 14:
            e = _P(null, e, i, lo(i.type, n), t);
            break e;
        }
        throw Error(Be(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : lo(i, r)),
        PM(n, e, i, r, t)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : lo(i, r)),
        xP(n, e, i, r, t)
      );
    case 3:
      e: {
        if ((D3(e), n === null)) throw Error(Be(387));
        (i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          o3(n, e),
          dy(e, i, null, t);
        var o = e.memoizedState;
        if (((i = o.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (r = Sh(Error(Be(423)), e)), (e = AP(n, e, i, t, r));
            break e;
          } else if (i !== r) {
            (r = Sh(Error(Be(424)), e)), (e = AP(n, e, i, t, r));
            break e;
          } else
            for (
              cs = Cl(e.stateNode.containerInfo.firstChild),
                ps = e,
                Cn = !0,
                fo = null,
                t = r3(e, null, i, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((_h(), i === r)) {
            e = Na(n, e, t);
            break e;
          }
          pr(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        a3(e),
        n === null && EM(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = r.children),
        xM(i, r) ? (o = null) : s !== null && xM(i, s) && (e.flags |= 32),
        I3(n, e),
        pr(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && EM(e), null;
    case 13:
      return L3(n, e, t);
    case 4:
      return (
        BE(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        n === null ? (e.child = xh(e, null, i, t)) : pr(n, e, i, t),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : lo(i, r)),
        yP(n, e, i, r, t)
      );
    case 7:
      return pr(n, e, e.pendingProps, t), e.child;
    case 8:
      return pr(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return pr(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (o = r.value),
          Mn(fy, i._currentValue),
          (i._currentValue = o),
          s !== null)
        )
          if (_o(s.value, o)) {
            if (s.children === r.children && !Hr.current) {
              e = Na(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === i) {
                    if (s.tag === 1) {
                      (l = Ta(-1, t & -t)), (l.tag = 2);
                      var u = s.updateQueue;
                      if (u !== null) {
                        u = u.shared;
                        var c = u.pending;
                        c === null
                          ? (l.next = l)
                          : ((l.next = c.next), (c.next = l)),
                          (u.pending = l);
                      }
                    }
                    (s.lanes |= t),
                      (l = s.alternate),
                      l !== null && (l.lanes |= t),
                      TM(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(Be(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  TM(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        pr(n, e, r.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        sh(e, t),
        (r = qs(r)),
        (i = i(r)),
        (e.flags |= 1),
        pr(n, e, i, t),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = lo(i, e.pendingProps)),
        (r = lo(i.type, r)),
        _P(n, e, i, r, t)
      );
    case 15:
      return P3(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : lo(i, r)),
        Lv(n, e),
        (e.tag = 1),
        Gr(i) ? ((n = !0), ly(e)) : (n = !1),
        sh(e, t),
        C3(e, i, r),
        bM(e, i, r, t),
        BM(null, e, i, !0, n, t)
      );
    case 19:
      return F3(n, e, t);
    case 22:
      return B3(n, e, t);
  }
  throw Error(Be(156, e.tag));
};
function Z3(n, e) {
  return wL(n, e);
}
function DG(n, e, t, i) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Ws(n, e, t, i) {
  return new DG(n, e, t, i);
}
function JE(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function LG(n) {
  if (typeof n == "function") return JE(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === fE)) return 11;
    if (n === hE) return 14;
  }
  return 2;
}
function Bl(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = Ws(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function Ov(n, e, t, i, r, s) {
  var o = 2;
  if (((i = n), typeof n == "function")) JE(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case Df:
        return tc(t.children, r, s, e);
      case cE:
        (o = 8), (r |= 8);
        break;
      case qS:
        return (
          (n = Ws(12, t, e, r | 2)), (n.elementType = qS), (n.lanes = s), n
        );
      case $S:
        return (n = Ws(13, t, e, r)), (n.elementType = $S), (n.lanes = s), n;
      case eM:
        return (n = Ws(19, t, e, r)), (n.elementType = eM), (n.lanes = s), n;
      case aL:
        return X_(t, r, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case sL:
              o = 10;
              break e;
            case oL:
              o = 9;
              break e;
            case fE:
              o = 11;
              break e;
            case hE:
              o = 14;
              break e;
            case fl:
              (o = 16), (i = null);
              break e;
          }
        throw Error(Be(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = Ws(o, t, e, r)), (e.elementType = n), (e.type = i), (e.lanes = s), e
  );
}
function tc(n, e, t, i) {
  return (n = Ws(7, n, i, e)), (n.lanes = t), n;
}
function X_(n, e, t, i) {
  return (
    (n = Ws(22, n, i, e)),
    (n.elementType = aL),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function y1(n, e, t) {
  return (n = Ws(6, n, null, e)), (n.lanes = t), n;
}
function _1(n, e, t) {
  return (
    (e = Ws(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function FG(n, e, t, i, r) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = $A(0)),
    (this.expirationTimes = $A(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = $A(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function jE(n, e, t, i, r, s, o, a, l) {
  return (
    (n = new FG(n, e, t, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = Ws(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: i,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    PE(s),
    n
  );
}
function NG(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: If,
    key: i == null ? null : "" + i,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function q3(n) {
  if (!n) return Ul;
  n = n._reactInternals;
  e: {
    if (Lc(n) !== n || n.tag !== 1) throw Error(Be(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Gr(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Be(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (Gr(t)) return qL(n, t, e);
  }
  return e;
}
function $3(n, e, t, i, r, s, o, a, l) {
  return (
    (n = jE(t, i, !0, n, r, s, o, a, l)),
    (n.context = q3(null)),
    (t = n.current),
    (i = xr()),
    (r = Pl(t)),
    (s = Ta(i, r)),
    (s.callback = e ?? null),
    bl(t, s, r),
    (n.current.lanes = r),
    Lm(n, r, i),
    Vr(n, i),
    n
  );
}
function J_(n, e, t, i) {
  var r = e.current,
    s = xr(),
    o = Pl(r);
  return (
    (t = q3(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = Ta(s, o)),
    (e.payload = { element: n }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (n = bl(r, e, o)),
    n !== null && (go(n, r, o, s), Bv(n, r, o)),
    o
  );
}
function Ay(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function BP(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function YE(n, e) {
  BP(n, e), (n = n.alternate) && BP(n, e);
}
function OG() {
  return null;
}
var eF =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function KE(n) {
  this._internalRoot = n;
}
j_.prototype.render = KE.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(Be(409));
  J_(n, e, null, null);
};
j_.prototype.unmount = KE.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    _c(function () {
      J_(null, n, null, null);
    }),
      (e[La] = null);
  }
};
function j_(n) {
  this._internalRoot = n;
}
j_.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = BL();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < pl.length && e !== 0 && e < pl[t].priority; t++);
    pl.splice(t, 0, n), t === 0 && DL(n);
  }
};
function QE(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function Y_(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function IP() {}
function UG(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var u = Ay(o);
        s.call(u);
      };
    }
    var o = $3(e, i, n, 0, null, !1, !1, "", IP);
    return (
      (n._reactRootContainer = o),
      (n[La] = o.current),
      Qp(n.nodeType === 8 ? n.parentNode : n),
      _c(),
      o
    );
  }
  for (; (r = n.lastChild); ) n.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var u = Ay(l);
      a.call(u);
    };
  }
  var l = jE(n, 0, !1, null, null, !1, !1, "", IP);
  return (
    (n._reactRootContainer = l),
    (n[La] = l.current),
    Qp(n.nodeType === 8 ? n.parentNode : n),
    _c(function () {
      J_(e, l, t, i);
    }),
    l
  );
}
function K_(n, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var l = Ay(o);
        a.call(l);
      };
    }
    J_(e, o, n, r);
  } else o = UG(t, e, n, r, i);
  return Ay(o);
}
RL = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = Yd(e.pendingLanes);
        t !== 0 &&
          (mE(e, t | 1), Vr(e, Qn()), !(nn & 6) && ((Mh = Qn() + 500), Kl()));
      }
      break;
    case 13:
      _c(function () {
        var i = Fa(n, 1);
        if (i !== null) {
          var r = xr();
          go(i, n, 1, r);
        }
      }),
        YE(n, 1);
  }
};
gE = function (n) {
  if (n.tag === 13) {
    var e = Fa(n, 134217728);
    if (e !== null) {
      var t = xr();
      go(e, n, 134217728, t);
    }
    YE(n, 134217728);
  }
};
PL = function (n) {
  if (n.tag === 13) {
    var e = Pl(n),
      t = Fa(n, e);
    if (t !== null) {
      var i = xr();
      go(t, n, e, i);
    }
    YE(n, e);
  }
};
BL = function () {
  return mn;
};
IL = function (n, e) {
  var t = mn;
  try {
    return (mn = n), e();
  } finally {
    mn = t;
  }
};
cM = function (n, e, t) {
  switch (e) {
    case "input":
      if ((iM(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = k_(i);
            if (!r) throw Error(Be(90));
            uL(i), iM(i, r);
          }
        }
      }
      break;
    case "textarea":
      fL(n, t);
      break;
    case "select":
      (e = t.value), e != null && th(n, !!t.multiple, e, !1);
  }
};
yL = VE;
_L = _c;
var kG = { usingClientEntryPoint: !1, Events: [Nm, Of, k_, gL, vL, VE] },
  Md = {
    findFiberByHostInstance: zu,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  zG = {
    bundleType: Md.bundleType,
    version: Md.version,
    rendererPackageName: Md.rendererPackageName,
    rendererConfig: Md.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Va.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = SL(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: Md.findFiberByHostInstance || OG,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var d0 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!d0.isDisabled && d0.supportsFiber)
    try {
      (F_ = d0.inject(zG)), (Ho = d0);
    } catch {}
}
Ms.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = kG;
Ms.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!QE(e)) throw Error(Be(200));
  return NG(n, e, null, t);
};
Ms.createRoot = function (n, e) {
  if (!QE(n)) throw Error(Be(299));
  var t = !1,
    i = "",
    r = eF;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = jE(n, 1, !1, null, null, t, !1, i, r)),
    (n[La] = e.current),
    Qp(n.nodeType === 8 ? n.parentNode : n),
    new KE(e)
  );
};
Ms.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(Be(188))
      : ((n = Object.keys(n).join(",")), Error(Be(268, n)));
  return (n = SL(e)), (n = n === null ? null : n.stateNode), n;
};
Ms.flushSync = function (n) {
  return _c(n);
};
Ms.hydrate = function (n, e, t) {
  if (!Y_(e)) throw Error(Be(200));
  return K_(null, n, e, !0, t);
};
Ms.hydrateRoot = function (n, e, t) {
  if (!QE(n)) throw Error(Be(405));
  var i = (t != null && t.hydratedSources) || null,
    r = !1,
    s = "",
    o = eF;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = $3(e, null, n, 1, t ?? null, r, !1, s, o)),
    (n[La] = e.current),
    Qp(n),
    i)
  )
    for (n = 0; n < i.length; n++)
      (t = i[n]),
        (r = t._getVersion),
        (r = r(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, r])
          : e.mutableSourceEagerHydrationData.push(t, r);
  return new j_(e);
};
Ms.render = function (n, e, t) {
  if (!Y_(e)) throw Error(Be(200));
  return K_(null, n, e, !1, t);
};
Ms.unmountComponentAtNode = function (n) {
  if (!Y_(n)) throw Error(Be(40));
  return n._reactRootContainer
    ? (_c(function () {
        K_(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[La] = null);
        });
      }),
      !0)
    : !1;
};
Ms.unstable_batchedUpdates = VE;
Ms.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
  if (!Y_(t)) throw Error(Be(200));
  if (n == null || n._reactInternals === void 0) throw Error(Be(38));
  return K_(n, e, t, !1, i);
};
Ms.version = "18.3.1-next-f1338f8080-20240426";
function tF() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(tF);
    } catch (n) {
      console.error(n);
    }
}
tF(), (tL.exports = Ms);
var HG = tL.exports,
  nF,
  DP = HG;
(nF = QS.createRoot = DP.createRoot), (QS.hydrateRoot = DP.hydrateRoot);
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function sm() {
  return (
    (sm = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    sm.apply(this, arguments)
  );
}
var Vu;
(function (n) {
  (n.Pop = "POP"), (n.Push = "PUSH"), (n.Replace = "REPLACE");
})(Vu || (Vu = {}));
const LP = "popstate";
function GG(n) {
  n === void 0 && (n = {});
  function e(i, r) {
    let { pathname: s, search: o, hash: a } = i.location;
    return VM(
      "",
      { pathname: s, search: o, hash: a },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || "default"
    );
  }
  function t(i, r) {
    return typeof r == "string" ? r : Sy(r);
  }
  return WG(e, t, null, n);
}
function vo(n, e) {
  if (n === !1 || n === null || typeof n > "u") throw new Error(e);
}
function VG() {
  return Math.random().toString(36).substr(2, 8);
}
function FP(n, e) {
  return { usr: n.state, key: n.key, idx: e };
}
function VM(n, e, t, i) {
  return (
    t === void 0 && (t = null),
    sm(
      { pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" },
      typeof e == "string" ? Q_(e) : e,
      { state: t, key: (e && e.key) || i || VG() }
    )
  );
}
function Sy(n) {
  let { pathname: e = "/", search: t = "", hash: i = "" } = n;
  return (
    t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i),
    e
  );
}
function Q_(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && ((e.hash = n.substr(t)), (n = n.substr(0, t)));
    let i = n.indexOf("?");
    i >= 0 && ((e.search = n.substr(i)), (n = n.substr(0, i))),
      n && (e.pathname = n);
  }
  return e;
}
function WG(n, e, t, i) {
  i === void 0 && (i = {});
  let { window: r = document.defaultView, v5Compat: s = !1 } = i,
    o = r.history,
    a = Vu.Pop,
    l = null,
    u = c();
  u == null && ((u = 0), o.replaceState(sm({}, o.state, { idx: u }), ""));
  function c() {
    return (o.state || { idx: null }).idx;
  }
  function d() {
    a = Vu.Pop;
    let x = c(),
      g = x == null ? null : x - u;
    (u = x), l && l({ action: a, location: _.location, delta: g });
  }
  function p(x, g) {
    a = Vu.Push;
    let A = VM(_.location, x, g);
    t && t(A, x), (u = c() + 1);
    let S = FP(A, u),
      w = _.createHref(A);
    try {
      o.pushState(S, "", w);
    } catch (C) {
      if (C instanceof DOMException && C.name === "DataCloneError") throw C;
      r.location.assign(w);
    }
    s && l && l({ action: a, location: _.location, delta: 1 });
  }
  function m(x, g) {
    a = Vu.Replace;
    let A = VM(_.location, x, g);
    t && t(A, x), (u = c());
    let S = FP(A, u),
      w = _.createHref(A);
    o.replaceState(S, "", w),
      s && l && l({ action: a, location: _.location, delta: 0 });
  }
  function v(x) {
    let g = r.location.origin !== "null" ? r.location.origin : r.location.href,
      A = typeof x == "string" ? x : Sy(x);
    return (
      (A = A.replace(/ $/, "%20")),
      vo(
        g,
        "No window.location.(origin|href) available to create URL for href: " +
          A
      ),
      new URL(A, g)
    );
  }
  let _ = {
    get action() {
      return a;
    },
    get location() {
      return n(r, o);
    },
    listen(x) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        r.addEventListener(LP, d),
        (l = x),
        () => {
          r.removeEventListener(LP, d), (l = null);
        }
      );
    },
    createHref(x) {
      return e(r, x);
    },
    createURL: v,
    encodeLocation(x) {
      let g = v(x);
      return { pathname: g.pathname, search: g.search, hash: g.hash };
    },
    push: p,
    replace: m,
    go(x) {
      return o.go(x);
    },
  };
  return _;
}
var NP;
(function (n) {
  (n.data = "data"),
    (n.deferred = "deferred"),
    (n.redirect = "redirect"),
    (n.error = "error");
})(NP || (NP = {}));
function iF(n, e) {
  if (e === "/") return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    i = n.charAt(t);
  return i && i !== "/" ? null : n.slice(t) || "/";
}
function XG(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: i = "",
    hash: r = "",
  } = typeof n == "string" ? Q_(n) : n;
  return {
    pathname: t ? (t.startsWith("/") ? t : JG(t, e)) : e,
    search: YG(i),
    hash: KG(r),
  };
}
function JG(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    n.split("/").forEach((r) => {
      r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function x1(n, e, t, i) {
  return (
    "Cannot include a '" +
    n +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(i) +
      "].  Please separate it out to the ") +
    ("`to." + t + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function jG(n) {
  return n.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function rF(n, e) {
  let t = jG(n);
  return e
    ? t.map((i, r) => (r === t.length - 1 ? i.pathname : i.pathnameBase))
    : t.map((i) => i.pathnameBase);
}
function sF(n, e, t, i) {
  i === void 0 && (i = !1);
  let r;
  typeof n == "string"
    ? (r = Q_(n))
    : ((r = sm({}, n)),
      vo(
        !r.pathname || !r.pathname.includes("?"),
        x1("?", "pathname", "search", r)
      ),
      vo(
        !r.pathname || !r.pathname.includes("#"),
        x1("#", "pathname", "hash", r)
      ),
      vo(!r.search || !r.search.includes("#"), x1("#", "search", "hash", r)));
  let s = n === "" || r.pathname === "",
    o = s ? "/" : r.pathname,
    a;
  if (o == null) a = t;
  else {
    let d = e.length - 1;
    if (!i && o.startsWith("..")) {
      let p = o.split("/");
      for (; p[0] === ".."; ) p.shift(), (d -= 1);
      r.pathname = p.join("/");
    }
    a = d >= 0 ? e[d] : "/";
  }
  let l = XG(r, a),
    u = o && o !== "/" && o.endsWith("/"),
    c = (s || o === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l;
}
const oF = (n) => n.join("/").replace(/\/\/+/g, "/"),
  YG = (n) => (!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n),
  KG = (n) => (!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n),
  aF = ["post", "put", "patch", "delete"];
new Set(aF);
const QG = ["get", ...aF];
new Set(QG);
/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function My() {
  return (
    (My = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    My.apply(this, arguments)
  );
}
const lF = j.createContext(null),
  Wh = j.createContext(null),
  ZE = j.createContext(null),
  Z_ = j.createContext({ outlet: null, matches: [], isDataRoute: !1 });
function ZG(n, e) {
  let { relative: t } = e === void 0 ? {} : e;
  q_() || vo(!1);
  let { basename: i, navigator: r } = j.useContext(Wh),
    { hash: s, pathname: o, search: a } = cF(n, { relative: t }),
    l = o;
  return (
    i !== "/" && (l = o === "/" ? i : oF([i, o])),
    r.createHref({ pathname: l, search: a, hash: s })
  );
}
function q_() {
  return j.useContext(ZE) != null;
}
function qE() {
  return q_() || vo(!1), j.useContext(ZE).location;
}
function uF(n) {
  j.useContext(Wh).static || j.useLayoutEffect(n);
}
function qG() {
  let { isDataRoute: n } = j.useContext(Z_);
  return n ? iV() : $G();
}
function $G() {
  q_() || vo(!1);
  let n = j.useContext(lF),
    { basename: e, future: t, navigator: i } = j.useContext(Wh),
    { matches: r } = j.useContext(Z_),
    { pathname: s } = qE(),
    o = JSON.stringify(rF(r, t.v7_relativeSplatPath)),
    a = j.useRef(!1);
  return (
    uF(() => {
      a.current = !0;
    }),
    j.useCallback(
      function (u, c) {
        if ((c === void 0 && (c = {}), !a.current)) return;
        if (typeof u == "number") {
          i.go(u);
          return;
        }
        let d = sF(u, JSON.parse(o), s, c.relative === "path");
        n == null &&
          e !== "/" &&
          (d.pathname = d.pathname === "/" ? e : oF([e, d.pathname])),
          (c.replace ? i.replace : i.push)(d, c.state, c);
      },
      [e, i, o, s, n]
    )
  );
}
function cF(n, e) {
  let { relative: t } = e === void 0 ? {} : e,
    { future: i } = j.useContext(Wh),
    { matches: r } = j.useContext(Z_),
    { pathname: s } = qE(),
    o = JSON.stringify(rF(r, i.v7_relativeSplatPath));
  return j.useMemo(() => sF(n, JSON.parse(o), s, t === "path"), [n, o, s, t]);
}
var fF = (function (n) {
    return (
      (n.UseBlocker = "useBlocker"),
      (n.UseRevalidator = "useRevalidator"),
      (n.UseNavigateStable = "useNavigate"),
      n
    );
  })(fF || {}),
  hF = (function (n) {
    return (
      (n.UseBlocker = "useBlocker"),
      (n.UseLoaderData = "useLoaderData"),
      (n.UseActionData = "useActionData"),
      (n.UseRouteError = "useRouteError"),
      (n.UseNavigation = "useNavigation"),
      (n.UseRouteLoaderData = "useRouteLoaderData"),
      (n.UseMatches = "useMatches"),
      (n.UseRevalidator = "useRevalidator"),
      (n.UseNavigateStable = "useNavigate"),
      (n.UseRouteId = "useRouteId"),
      n
    );
  })(hF || {});
function eV(n) {
  let e = j.useContext(lF);
  return e || vo(!1), e;
}
function tV(n) {
  let e = j.useContext(Z_);
  return e || vo(!1), e;
}
function nV(n) {
  let e = tV(),
    t = e.matches[e.matches.length - 1];
  return t.route.id || vo(!1), t.route.id;
}
function iV() {
  let { router: n } = eV(fF.UseNavigateStable),
    e = nV(hF.UseNavigateStable),
    t = j.useRef(!1);
  return (
    uF(() => {
      t.current = !0;
    }),
    j.useCallback(
      function (r, s) {
        s === void 0 && (s = {}),
          t.current &&
            (typeof r == "number"
              ? n.navigate(r)
              : n.navigate(r, My({ fromRouteId: e }, s)));
      },
      [n, e]
    )
  );
}
function rV(n, e) {
  n == null || n.v7_startTransition,
    (n == null ? void 0 : n.v7_relativeSplatPath) === void 0 &&
      (!e || e.v7_relativeSplatPath),
    e &&
      (e.v7_fetcherPersist,
      e.v7_normalizeFormMethod,
      e.v7_partialHydration,
      e.v7_skipActionErrorRevalidation);
}
function sV(n) {
  let {
    basename: e = "/",
    children: t = null,
    location: i,
    navigationType: r = Vu.Pop,
    navigator: s,
    static: o = !1,
    future: a,
  } = n;
  q_() && vo(!1);
  let l = e.replace(/^\/*/, "/"),
    u = j.useMemo(
      () => ({
        basename: l,
        navigator: s,
        static: o,
        future: My({ v7_relativeSplatPath: !1 }, a),
      }),
      [l, a, s, o]
    );
  typeof i == "string" && (i = Q_(i));
  let {
      pathname: c = "/",
      search: d = "",
      hash: p = "",
      state: m = null,
      key: v = "default",
    } = i,
    _ = j.useMemo(() => {
      let x = iF(c, l);
      return x == null
        ? null
        : {
            location: { pathname: x, search: d, hash: p, state: m, key: v },
            navigationType: r,
          };
    }, [l, c, d, p, m, v, r]);
  return _ == null
    ? null
    : j.createElement(
        Wh.Provider,
        { value: u },
        j.createElement(ZE.Provider, { children: t, value: _ })
      );
}
new Promise(() => {});
/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function WM() {
  return (
    (WM = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    WM.apply(this, arguments)
  );
}
function oV(n, e) {
  if (n == null) return {};
  var t = {},
    i = Object.keys(n),
    r,
    s;
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]);
  return t;
}
function aV(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function lV(n, e) {
  return n.button === 0 && (!e || e === "_self") && !aV(n);
}
const uV = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
    "viewTransition",
  ],
  cV = "6";
try {
  window.__reactRouterVersion = cV;
} catch {}
const fV = "startTransition",
  OP = R4[fV];
function hV(n) {
  let { basename: e, children: t, future: i, window: r } = n,
    s = j.useRef();
  s.current == null && (s.current = GG({ window: r, v5Compat: !0 }));
  let o = s.current,
    [a, l] = j.useState({ action: o.action, location: o.location }),
    { v7_startTransition: u } = i || {},
    c = j.useCallback(
      (d) => {
        u && OP ? OP(() => l(d)) : l(d);
      },
      [l, u]
    );
  return (
    j.useLayoutEffect(() => o.listen(c), [o, c]),
    j.useEffect(() => rV(i), [i]),
    j.createElement(sV, {
      basename: e,
      children: t,
      location: a.location,
      navigationType: a.action,
      navigator: o,
      future: i,
    })
  );
}
const dV =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  pV = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  mV = j.forwardRef(function (e, t) {
    let {
        onClick: i,
        relative: r,
        reloadDocument: s,
        replace: o,
        state: a,
        target: l,
        to: u,
        preventScrollReset: c,
        viewTransition: d,
      } = e,
      p = oV(e, uV),
      { basename: m } = j.useContext(Wh),
      v,
      _ = !1;
    if (typeof u == "string" && pV.test(u) && ((v = u), dV))
      try {
        let S = new URL(window.location.href),
          w = u.startsWith("//") ? new URL(S.protocol + u) : new URL(u),
          C = iF(w.pathname, m);
        w.origin === S.origin && C != null
          ? (u = C + w.search + w.hash)
          : (_ = !0);
      } catch {}
    let x = ZG(u, { relative: r }),
      g = gV(u, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: c,
        relative: r,
        viewTransition: d,
      });
    function A(S) {
      i && i(S), S.defaultPrevented || g(S);
    }
    return j.createElement(
      "a",
      WM({}, p, { href: v || x, onClick: _ || s ? i : A, ref: t, target: l })
    );
  });
var UP;
(function (n) {
  (n.UseScrollRestoration = "useScrollRestoration"),
    (n.UseSubmit = "useSubmit"),
    (n.UseSubmitFetcher = "useSubmitFetcher"),
    (n.UseFetcher = "useFetcher"),
    (n.useViewTransitionState = "useViewTransitionState");
})(UP || (UP = {}));
var kP;
(function (n) {
  (n.UseFetcher = "useFetcher"),
    (n.UseFetchers = "useFetchers"),
    (n.UseScrollRestoration = "useScrollRestoration");
})(kP || (kP = {}));
function gV(n, e) {
  let {
      target: t,
      replace: i,
      state: r,
      preventScrollReset: s,
      relative: o,
      viewTransition: a,
    } = e === void 0 ? {} : e,
    l = qG(),
    u = qE(),
    c = cF(n, { relative: o });
  return j.useCallback(
    (d) => {
      if (lV(d, t)) {
        d.preventDefault();
        let p = i !== void 0 ? i : Sy(u) === Sy(c);
        l(n, {
          replace: p,
          state: r,
          preventScrollReset: s,
          relative: o,
          viewTransition: a,
        });
      }
    },
    [u, l, c, i, r, t, n, s, o, a]
  );
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Xh = "172",
  Pu = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Bu = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  dF = 0,
  XM = 1,
  pF = 2,
  vV = 3,
  mF = 0,
  $_ = 1,
  mp = 2,
  uo = 3,
  Yo = 0,
  Ar = 1,
  Vs = 2,
  Ca = 0,
  nc = 1,
  JM = 2,
  jM = 3,
  YM = 4,
  gF = 5,
  gl = 100,
  vF = 101,
  yF = 102,
  _F = 103,
  xF = 104,
  AF = 200,
  SF = 201,
  MF = 202,
  wF = 203,
  wy = 204,
  Ey = 205,
  EF = 206,
  TF = 207,
  CF = 208,
  bF = 209,
  RF = 210,
  PF = 211,
  BF = 212,
  IF = 213,
  DF = 214,
  Ty = 0,
  Cy = 1,
  by = 2,
  xc = 3,
  Ry = 4,
  Py = 5,
  By = 6,
  Iy = 7,
  Um = 0,
  LF = 1,
  FF = 2,
  Vo = 0,
  NF = 1,
  OF = 2,
  UF = 3,
  $E = 4,
  kF = 5,
  zF = 6,
  HF = 7,
  KM = "attached",
  GF = "detached",
  ex = 300,
  Oa = 301,
  kl = 302,
  om = 303,
  am = 304,
  Jh = 306,
  zl = 1e3,
  fs = 1001,
  wh = 1002,
  bi = 1003,
  tx = 1004,
  yV = 1004,
  Wu = 1005,
  _V = 1005,
  Zn = 1006,
  ah = 1007,
  xV = 1007,
  Xs = 1008,
  AV = 1008,
  xo = 1009,
  eT = 1010,
  tT = 1011,
  Eh = 1012,
  nx = 1013,
  Ua = 1014,
  kr = 1015,
  jh = 1016,
  ix = 1017,
  rx = 1018,
  Ac = 1020,
  nT = 35902,
  iT = 1021,
  rT = 1022,
  $i = 1023,
  sT = 1024,
  oT = 1025,
  ic = 1026,
  Sc = 1027,
  sx = 1028,
  km = 1029,
  aT = 1030,
  ox = 1031,
  SV = 1032,
  ax = 1033,
  gp = 33776,
  vp = 33777,
  yp = 33778,
  _p = 33779,
  Dy = 35840,
  Ly = 35841,
  Fy = 35842,
  Ny = 35843,
  Oy = 36196,
  Uy = 37492,
  ky = 37496,
  zy = 37808,
  Hy = 37809,
  Gy = 37810,
  Vy = 37811,
  Wy = 37812,
  Xy = 37813,
  Jy = 37814,
  jy = 37815,
  Yy = 37816,
  Ky = 37817,
  Qy = 37818,
  Zy = 37819,
  qy = 37820,
  $y = 37821,
  xp = 36492,
  e_ = 36494,
  t_ = 36495,
  lT = 36283,
  n_ = 36284,
  i_ = 36285,
  r_ = 36286,
  VF = 2200,
  WF = 2201,
  XF = 2202,
  Th = 2300,
  Ch = 2301,
  Uv = 2302,
  Xu = 2400,
  Ju = 2401,
  lm = 2402,
  lx = 2500,
  uT = 2501,
  JF = 0,
  cT = 1,
  s_ = 2,
  jF = 3200,
  YF = 3201,
  MV = 3202,
  wV = 3203,
  Ql = 0,
  KF = 1,
  va = "",
  Fr = "srgb",
  Mc = "srgb-linear",
  um = "linear",
  pn = "srgb",
  EV = 0,
  Iu = 7680,
  TV = 7681,
  CV = 7682,
  bV = 7683,
  RV = 34055,
  PV = 34056,
  BV = 5386,
  IV = 512,
  DV = 513,
  LV = 514,
  FV = 515,
  NV = 516,
  OV = 517,
  UV = 518,
  QM = 519,
  QF = 512,
  ZF = 513,
  qF = 514,
  fT = 515,
  $F = 516,
  eN = 517,
  tN = 518,
  nN = 519,
  cm = 35044,
  rc = 35048,
  kV = 35040,
  zV = 35045,
  HV = 35049,
  GV = 35041,
  VV = 35046,
  WV = 35050,
  XV = 35042,
  JV = "100",
  ZM = "300 es",
  po = 2e3,
  fm = 2001;
let Zo = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
};
const Xi = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let zP = 1234567;
const sc = Math.PI / 180,
  bh = 180 / Math.PI;
function ms() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    Xi[n & 255] +
    Xi[(n >> 8) & 255] +
    Xi[(n >> 16) & 255] +
    Xi[(n >> 24) & 255] +
    "-" +
    Xi[e & 255] +
    Xi[(e >> 8) & 255] +
    "-" +
    Xi[((e >> 16) & 15) | 64] +
    Xi[(e >> 24) & 255] +
    "-" +
    Xi[(t & 63) | 128] +
    Xi[(t >> 8) & 255] +
    "-" +
    Xi[(t >> 16) & 255] +
    Xi[(t >> 24) & 255] +
    Xi[i & 255] +
    Xi[(i >> 8) & 255] +
    Xi[(i >> 16) & 255] +
    Xi[(i >> 24) & 255]
  ).toLowerCase();
}
function Rt(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function hT(n, e) {
  return ((n % e) + e) % e;
}
function jV(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function YV(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function Ap(n, e, t) {
  return (1 - t) * n + t * e;
}
function KV(n, e, t, i) {
  return Ap(n, e, 1 - Math.exp(-t * i));
}
function QV(n, e = 1) {
  return e - Math.abs(hT(n, e * 2) - e);
}
function ZV(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function qV(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function $V(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function e9(n, e) {
  return n + Math.random() * (e - n);
}
function t9(n) {
  return n * (0.5 - Math.random());
}
function n9(n) {
  n !== void 0 && (zP = n);
  let e = (zP += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function i9(n) {
  return n * sc;
}
function r9(n) {
  return n * bh;
}
function s9(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function o9(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function a9(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function l9(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    u = s((e + i) / 2),
    c = o((e + i) / 2),
    d = s((e - i) / 2),
    p = o((e - i) / 2),
    m = s((i - e) / 2),
    v = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * c, l * d, l * p, a * u);
      break;
    case "YZY":
      n.set(l * p, a * c, l * d, a * u);
      break;
    case "ZXZ":
      n.set(l * d, l * p, a * c, a * u);
      break;
    case "XZX":
      n.set(a * c, l * v, l * m, a * u);
      break;
    case "YXY":
      n.set(l * m, a * c, l * v, a * u);
      break;
    case "ZYZ":
      n.set(l * v, l * m, a * c, a * u);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function vr(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Ft(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const iN = {
  DEG2RAD: sc,
  RAD2DEG: bh,
  generateUUID: ms,
  clamp: Rt,
  euclideanModulo: hT,
  mapLinear: jV,
  inverseLerp: YV,
  lerp: Ap,
  damp: KV,
  pingpong: QV,
  smoothstep: ZV,
  smootherstep: qV,
  randInt: $V,
  randFloat: e9,
  randFloatSpread: t9,
  seededRandom: n9,
  degToRad: i9,
  radToDeg: r9,
  isPowerOfTwo: s9,
  ceilPowerOfTwo: o9,
  floorPowerOfTwo: a9,
  setQuaternionFromProperEuler: l9,
  normalize: Ft,
  denormalize: vr,
};
class Ae {
  constructor(e = 0, t = 0) {
    (Ae.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Rt(this.x, e.x, t.x)), (this.y = Rt(this.y, e.y, t.y)), this
    );
  }
  clampScalar(e, t) {
    return (this.x = Rt(this.x, e, t)), (this.y = Rt(this.y, e, t)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Rt(i, e, t));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Rt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class It {
  constructor(e, t, i, r, s, o, a, l, u) {
    (It.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, u);
  }
  set(e, t, i, r, s, o, a, l, u) {
    const c = this.elements;
    return (
      (c[0] = e),
      (c[1] = r),
      (c[2] = a),
      (c[3] = t),
      (c[4] = s),
      (c[5] = l),
      (c[6] = i),
      (c[7] = o),
      (c[8] = u),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      l = i[6],
      u = i[1],
      c = i[4],
      d = i[7],
      p = i[2],
      m = i[5],
      v = i[8],
      _ = r[0],
      x = r[3],
      g = r[6],
      A = r[1],
      S = r[4],
      w = r[7],
      C = r[2],
      b = r[5],
      P = r[8];
    return (
      (s[0] = o * _ + a * A + l * C),
      (s[3] = o * x + a * S + l * b),
      (s[6] = o * g + a * w + l * P),
      (s[1] = u * _ + c * A + d * C),
      (s[4] = u * x + c * S + d * b),
      (s[7] = u * g + c * w + d * P),
      (s[2] = p * _ + m * A + v * C),
      (s[5] = p * x + m * S + v * b),
      (s[8] = p * g + m * w + v * P),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      c = e[8];
    return (
      t * o * c - t * a * u - i * s * c + i * a * l + r * s * u - r * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      c = e[8],
      d = c * o - a * u,
      p = a * l - c * s,
      m = u * s - o * l,
      v = t * d + i * p + r * m;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / v;
    return (
      (e[0] = d * _),
      (e[1] = (r * u - c * i) * _),
      (e[2] = (a * i - r * o) * _),
      (e[3] = p * _),
      (e[4] = (c * t - r * l) * _),
      (e[5] = (r * s - a * t) * _),
      (e[6] = m * _),
      (e[7] = (i * l - u * t) * _),
      (e[8] = (o * t - i * s) * _),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s),
      u = Math.sin(s);
    return (
      this.set(
        i * l,
        i * u,
        -i * (l * o + u * a) + o + e,
        -r * u,
        r * l,
        -r * (-u * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(A1.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(A1.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(A1.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const A1 = new It();
function rN(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const u9 = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Wf(n, e) {
  return new u9[n](e);
}
function hm(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function sN() {
  const n = hm("canvas");
  return (n.style.display = "block"), n;
}
const HP = {};
function Cf(n) {
  n in HP || ((HP[n] = !0), console.warn(n));
}
function c9(n, e, t) {
  return new Promise(function (i, r) {
    function s() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          r();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(s, t);
          break;
        default:
          i();
      }
    }
    setTimeout(s, t);
  });
}
function f9(n) {
  const e = n.elements;
  (e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]);
}
function h9(n) {
  const e = n.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const GP = new It().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  VP = new It().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
function d9() {
  const n = {
      enabled: !0,
      workingColorSpace: Mc,
      spaces: {},
      convert: function (r, s, o) {
        return (
          this.enabled === !1 ||
            s === o ||
            !s ||
            !o ||
            (this.spaces[s].transfer === pn &&
              ((r.r = ba(r.r)), (r.g = ba(r.g)), (r.b = ba(r.b))),
            this.spaces[s].primaries !== this.spaces[o].primaries &&
              (r.applyMatrix3(this.spaces[s].toXYZ),
              r.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === pn &&
              ((r.r = lh(r.r)), (r.g = lh(r.g)), (r.b = lh(r.b)))),
          r
        );
      },
      fromWorkingColorSpace: function (r, s) {
        return this.convert(r, this.workingColorSpace, s);
      },
      toWorkingColorSpace: function (r, s) {
        return this.convert(r, s, this.workingColorSpace);
      },
      getPrimaries: function (r) {
        return this.spaces[r].primaries;
      },
      getTransfer: function (r) {
        return r === va ? um : this.spaces[r].transfer;
      },
      getLuminanceCoefficients: function (r, s = this.workingColorSpace) {
        return r.fromArray(this.spaces[s].luminanceCoefficients);
      },
      define: function (r) {
        Object.assign(this.spaces, r);
      },
      _getMatrix: function (r, s, o) {
        return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (r) {
        return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (r = this.workingColorSpace) {
        return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    i = [0.3127, 0.329];
  return (
    n.define({
      [Mc]: {
        primaries: e,
        whitePoint: i,
        transfer: um,
        toXYZ: GP,
        fromXYZ: VP,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: Fr },
        outputColorSpaceConfig: { drawingBufferColorSpace: Fr },
      },
      [Fr]: {
        primaries: e,
        whitePoint: i,
        transfer: pn,
        toXYZ: GP,
        fromXYZ: VP,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: Fr },
      },
    }),
    n
  );
}
const en = d9();
function ba(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function lh(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let rf;
class oN {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      rf === void 0 && (rf = hm("canvas")),
        (rf.width = e.width),
        (rf.height = e.height);
      const i = rf.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = rf);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = hm("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = ba(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(ba(t[i] / 255) * 255))
          : (t[i] = ba(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let p9 = 0;
class ju {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: p9++ }),
      (this.uuid = ms()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(S1(r[o].image)) : s.push(S1(r[o]));
      } else s = S1(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function S1(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? oN.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let m9 = 0;
class Pn extends Zo {
  constructor(
    e = Pn.DEFAULT_IMAGE,
    t = Pn.DEFAULT_MAPPING,
    i = fs,
    r = fs,
    s = Zn,
    o = Xs,
    a = $i,
    l = xo,
    u = Pn.DEFAULT_ANISOTROPY,
    c = va
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: m9++ }),
      (this.uuid = ms()),
      (this.name = ""),
      (this.source = new ju(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = u),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new Ae(0, 0)),
      (this.repeat = new Ae(1, 1)),
      (this.center = new Ae(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new It()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = c),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== ex) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case zl:
          e.x = e.x - Math.floor(e.x);
          break;
        case fs:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case wh:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case zl:
          e.y = e.y - Math.floor(e.y);
          break;
        case fs:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case wh:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Pn.DEFAULT_IMAGE = null;
Pn.DEFAULT_MAPPING = ex;
Pn.DEFAULT_ANISOTROPY = 1;
class tn {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (tn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements,
      u = l[0],
      c = l[4],
      d = l[8],
      p = l[1],
      m = l[5],
      v = l[9],
      _ = l[2],
      x = l[6],
      g = l[10];
    if (
      Math.abs(c - p) < 0.01 &&
      Math.abs(d - _) < 0.01 &&
      Math.abs(v - x) < 0.01
    ) {
      if (
        Math.abs(c + p) < 0.1 &&
        Math.abs(d + _) < 0.1 &&
        Math.abs(v + x) < 0.1 &&
        Math.abs(u + m + g - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const S = (u + 1) / 2,
        w = (m + 1) / 2,
        C = (g + 1) / 2,
        b = (c + p) / 4,
        P = (d + _) / 4,
        I = (v + x) / 4;
      return (
        S > w && S > C
          ? S < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(S)), (r = b / i), (s = P / i))
          : w > C
          ? w < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(w)), (i = b / r), (s = I / r))
          : C < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(C)), (i = P / s), (r = I / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let A = Math.sqrt(
      (x - v) * (x - v) + (d - _) * (d - _) + (p - c) * (p - c)
    );
    return (
      Math.abs(A) < 0.001 && (A = 1),
      (this.x = (x - v) / A),
      (this.y = (d - _) / A),
      (this.z = (p - c) / A),
      (this.w = Math.acos((u + m + g - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Rt(this.x, e.x, t.x)),
      (this.y = Rt(this.y, e.y, t.y)),
      (this.z = Rt(this.z, e.z, t.z)),
      (this.w = Rt(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Rt(this.x, e, t)),
      (this.y = Rt(this.y, e, t)),
      (this.z = Rt(this.z, e, t)),
      (this.w = Rt(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Rt(i, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class ux extends Zo {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new tn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new tn(0, 0, e, t));
    const r = { width: e, height: t, depth: 1 };
    i = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Zn,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      i
    );
    const s = new Pn(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.colorSpace
    );
    (s.flipY = !1),
      (s.generateMipmaps = i.generateMipmaps),
      (s.internalFormat = i.internalFormat),
      (this.textures = []);
    const o = i.count;
    for (let a = 0; a < o; a++)
      (this.textures[a] = s.clone()),
        (this.textures[a].isRenderTargetTexture = !0),
        (this.textures[a].renderTarget = this);
    (this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.resolveDepthBuffer = i.resolveDepthBuffer),
      (this.resolveStencilBuffer = i.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e);
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      (this.width = e), (this.height = t), (this.depth = i);
      for (let r = 0, s = this.textures.length; r < s; r++)
        (this.textures[r].image.width = e),
          (this.textures[r].image.height = t),
          (this.textures[r].image.depth = i);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let i = 0, r = e.textures.length; i < r; i++)
      (this.textures[i] = e.textures[i].clone()),
        (this.textures[i].isRenderTargetTexture = !0),
        (this.textures[i].renderTarget = this);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new ju(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ko extends ux {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), (this.isWebGLRenderTarget = !0);
  }
}
class zm extends Pn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = bi),
      (this.minFilter = bi),
      (this.wrapR = fs),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class g9 extends Ko {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = i),
      (this.texture = new zm(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class cx extends Pn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = bi),
      (this.minFilter = bi),
      (this.wrapR = fs),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class v9 extends Ko {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = i),
      (this.texture = new cx(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Ri {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0],
      u = i[r + 1],
      c = i[r + 2],
      d = i[r + 3];
    const p = s[o + 0],
      m = s[o + 1],
      v = s[o + 2],
      _ = s[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = u), (e[t + 2] = c), (e[t + 3] = d);
      return;
    }
    if (a === 1) {
      (e[t + 0] = p), (e[t + 1] = m), (e[t + 2] = v), (e[t + 3] = _);
      return;
    }
    if (d !== _ || l !== p || u !== m || c !== v) {
      let x = 1 - a;
      const g = l * p + u * m + c * v + d * _,
        A = g >= 0 ? 1 : -1,
        S = 1 - g * g;
      if (S > Number.EPSILON) {
        const C = Math.sqrt(S),
          b = Math.atan2(C, g * A);
        (x = Math.sin(x * b) / C), (a = Math.sin(a * b) / C);
      }
      const w = a * A;
      if (
        ((l = l * x + p * w),
        (u = u * x + m * w),
        (c = c * x + v * w),
        (d = d * x + _ * w),
        x === 1 - a)
      ) {
        const C = 1 / Math.sqrt(l * l + u * u + c * c + d * d);
        (l *= C), (u *= C), (c *= C), (d *= C);
      }
    }
    (e[t] = l), (e[t + 1] = u), (e[t + 2] = c), (e[t + 3] = d);
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      l = i[r + 1],
      u = i[r + 2],
      c = i[r + 3],
      d = s[o],
      p = s[o + 1],
      m = s[o + 2],
      v = s[o + 3];
    return (
      (e[t] = a * v + c * d + l * m - u * p),
      (e[t + 1] = l * v + c * p + u * d - a * m),
      (e[t + 2] = u * v + c * m + a * p - l * d),
      (e[t + 3] = c * v - a * d - l * p - u * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      u = a(i / 2),
      c = a(r / 2),
      d = a(s / 2),
      p = l(i / 2),
      m = l(r / 2),
      v = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = p * c * d + u * m * v),
          (this._y = u * m * d - p * c * v),
          (this._z = u * c * v + p * m * d),
          (this._w = u * c * d - p * m * v);
        break;
      case "YXZ":
        (this._x = p * c * d + u * m * v),
          (this._y = u * m * d - p * c * v),
          (this._z = u * c * v - p * m * d),
          (this._w = u * c * d + p * m * v);
        break;
      case "ZXY":
        (this._x = p * c * d - u * m * v),
          (this._y = u * m * d + p * c * v),
          (this._z = u * c * v + p * m * d),
          (this._w = u * c * d - p * m * v);
        break;
      case "ZYX":
        (this._x = p * c * d - u * m * v),
          (this._y = u * m * d + p * c * v),
          (this._z = u * c * v - p * m * d),
          (this._w = u * c * d + p * m * v);
        break;
      case "YZX":
        (this._x = p * c * d + u * m * v),
          (this._y = u * m * d + p * c * v),
          (this._z = u * c * v - p * m * d),
          (this._w = u * c * d - p * m * v);
        break;
      case "XZY":
        (this._x = p * c * d - u * m * v),
          (this._y = u * m * d - p * c * v),
          (this._z = u * c * v + p * m * d),
          (this._w = u * c * d + p * m * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      u = t[2],
      c = t[6],
      d = t[10],
      p = i + a + d;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / m),
        (this._x = (c - l) * m),
        (this._y = (s - u) * m),
        (this._z = (o - r) * m);
    } else if (i > a && i > d) {
      const m = 2 * Math.sqrt(1 + i - a - d);
      (this._w = (c - l) / m),
        (this._x = 0.25 * m),
        (this._y = (r + o) / m),
        (this._z = (s + u) / m);
    } else if (a > d) {
      const m = 2 * Math.sqrt(1 + a - i - d);
      (this._w = (s - u) / m),
        (this._x = (r + o) / m),
        (this._y = 0.25 * m),
        (this._z = (l + c) / m);
    } else {
      const m = 2 * Math.sqrt(1 + d - i - a);
      (this._w = (o - r) / m),
        (this._x = (s + u) / m),
        (this._y = (l + c) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Rt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      u = t._z,
      c = t._w;
    return (
      (this._x = i * c + o * a + r * u - s * l),
      (this._y = r * c + o * l + s * a - i * u),
      (this._z = s * c + o * u + i * l - r * a),
      (this._w = o * c - i * a - r * l - s * u),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * o + t * this._w),
        (this._x = m * i + t * this._x),
        (this._y = m * r + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this
      );
    }
    const u = Math.sqrt(l),
      c = Math.atan2(u, a),
      d = Math.sin((1 - t) * c) / u,
      p = Math.sin(t * c) / u;
    return (
      (this._w = o * d + this._w * p),
      (this._x = i * d + this._x * p),
      (this._y = r * d + this._y * p),
      (this._z = s * d + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      i = Math.random(),
      r = Math.sqrt(1 - i),
      s = Math.sqrt(i);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class z {
  constructor(e = 0, t = 0, i = 0) {
    (z.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(WP.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(WP.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      u = 2 * (o * r - a * i),
      c = 2 * (a * t - s * r),
      d = 2 * (s * i - o * t);
    return (
      (this.x = t + l * u + o * d - a * c),
      (this.y = i + l * c + a * u - s * d),
      (this.z = r + l * d + s * c - o * u),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Rt(this.x, e.x, t.x)),
      (this.y = Rt(this.y, e.y, t.y)),
      (this.z = Rt(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Rt(this.x, e, t)),
      (this.y = Rt(this.y, e, t)),
      (this.z = Rt(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Rt(i, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = r * l - s * a),
      (this.y = s * o - i * l),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return M1.copy(this).projectOnVector(e), this.sub(M1);
  }
  reflect(e) {
    return this.sub(M1.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Rt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      i = Math.sqrt(1 - t * t);
    return (
      (this.x = i * Math.cos(e)), (this.y = t), (this.z = i * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const M1 = new z(),
  WP = new Ri();
class er {
  constructor(
    e = new z(1 / 0, 1 / 0, 1 / 0),
    t = new z(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(ro.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(ro.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = ro.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, ro)
            : ro.fromBufferAttribute(s, o),
            ro.applyMatrix4(e.matrixWorld),
            this.expandByPoint(ro);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            p0.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            p0.copy(i.boundingBox)),
          p0.applyMatrix4(e.matrixWorld),
          this.union(p0);
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, ro),
      ro.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(wd),
      m0.subVectors(this.max, wd),
      sf.subVectors(e.a, wd),
      of.subVectors(e.b, wd),
      af.subVectors(e.c, wd),
      tl.subVectors(of, sf),
      nl.subVectors(af, of),
      cu.subVectors(sf, af);
    let t = [
      0,
      -tl.z,
      tl.y,
      0,
      -nl.z,
      nl.y,
      0,
      -cu.z,
      cu.y,
      tl.z,
      0,
      -tl.x,
      nl.z,
      0,
      -nl.x,
      cu.z,
      0,
      -cu.x,
      -tl.y,
      tl.x,
      0,
      -nl.y,
      nl.x,
      0,
      -cu.y,
      cu.x,
      0,
    ];
    return !w1(t, sf, of, af, m0) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !w1(t, sf, of, af, m0))
      ? !1
      : (g0.crossVectors(tl, nl),
        (t = [g0.x, g0.y, g0.z]),
        w1(t, sf, of, af, m0));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ro).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(ro).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (sa[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        sa[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        sa[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        sa[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        sa[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        sa[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        sa[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        sa[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(sa),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const sa = [
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
  ],
  ro = new z(),
  p0 = new er(),
  sf = new z(),
  of = new z(),
  af = new z(),
  tl = new z(),
  nl = new z(),
  cu = new z(),
  wd = new z(),
  m0 = new z(),
  g0 = new z(),
  fu = new z();
function w1(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    fu.fromArray(n, s);
    const a =
        r.x * Math.abs(fu.x) + r.y * Math.abs(fu.y) + r.z * Math.abs(fu.z),
      l = e.dot(fu),
      u = t.dot(fu),
      c = i.dot(fu);
    if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > a) return !1;
  }
  return !0;
}
const y9 = new er(),
  Ed = new z(),
  E1 = new z();
class Ni {
  constructor(e = new z(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : y9.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Ed.subVectors(e, this.center);
    const t = Ed.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector(Ed, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (E1.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Ed.copy(e.center).add(E1)),
            this.expandByPoint(Ed.copy(e.center).sub(E1))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const oa = new z(),
  T1 = new z(),
  v0 = new z(),
  il = new z(),
  C1 = new z(),
  y0 = new z(),
  b1 = new z();
class Fc {
  constructor(e = new z(), t = new z(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, oa)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = oa.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (oa.copy(this.origin).addScaledVector(this.direction, t),
        oa.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    T1.copy(e).add(t).multiplyScalar(0.5),
      v0.copy(t).sub(e).normalize(),
      il.copy(this.origin).sub(T1);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(v0),
      a = il.dot(this.direction),
      l = -il.dot(v0),
      u = il.lengthSq(),
      c = Math.abs(1 - o * o);
    let d, p, m, v;
    if (c > 0)
      if (((d = o * l - a), (p = o * a - l), (v = s * c), d >= 0))
        if (p >= -v)
          if (p <= v) {
            const _ = 1 / c;
            (d *= _),
              (p *= _),
              (m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + u);
          } else
            (p = s),
              (d = Math.max(0, -(o * p + a))),
              (m = -d * d + p * (p + 2 * l) + u);
        else
          (p = -s),
            (d = Math.max(0, -(o * p + a))),
            (m = -d * d + p * (p + 2 * l) + u);
      else
        p <= -v
          ? ((d = Math.max(0, -(-o * s + a))),
            (p = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + p * (p + 2 * l) + u))
          : p <= v
          ? ((d = 0),
            (p = Math.min(Math.max(-s, -l), s)),
            (m = p * (p + 2 * l) + u))
          : ((d = Math.max(0, -(o * s + a))),
            (p = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + p * (p + 2 * l) + u));
    else
      (p = o > 0 ? -s : s),
        (d = Math.max(0, -(o * p + a))),
        (m = -d * d + p * (p + 2 * l) + u);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, d),
      r && r.copy(T1).addScaledVector(v0, p),
      m
    );
  }
  intersectSphere(e, t) {
    oa.subVectors(e.center, this.origin);
    const i = oa.dot(this.direction),
      r = oa.dot(oa) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l;
    const u = 1 / this.direction.x,
      c = 1 / this.direction.y,
      d = 1 / this.direction.z,
      p = this.origin;
    return (
      u >= 0
        ? ((i = (e.min.x - p.x) * u), (r = (e.max.x - p.x) * u))
        : ((i = (e.max.x - p.x) * u), (r = (e.min.x - p.x) * u)),
      c >= 0
        ? ((s = (e.min.y - p.y) * c), (o = (e.max.y - p.y) * c))
        : ((s = (e.max.y - p.y) * c), (o = (e.min.y - p.y) * c)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      d >= 0
        ? ((a = (e.min.z - p.z) * d), (l = (e.max.z - p.z) * d))
        : ((a = (e.max.z - p.z) * d), (l = (e.min.z - p.z) * d)),
      i > l || a > r) ||
      ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, oa) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    C1.subVectors(t, e), y0.subVectors(i, e), b1.crossVectors(C1, y0);
    let o = this.direction.dot(b1),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    il.subVectors(this.origin, e);
    const l = a * this.direction.dot(y0.crossVectors(il, y0));
    if (l < 0) return null;
    const u = a * this.direction.dot(C1.cross(il));
    if (u < 0 || l + u > o) return null;
    const c = -a * il.dot(b1);
    return c < 0 ? null : this.at(c / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _t {
  constructor(e, t, i, r, s, o, a, l, u, c, d, p, m, v, _, x) {
    (_t.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, u, c, d, p, m, v, _, x);
  }
  set(e, t, i, r, s, o, a, l, u, c, d, p, m, v, _, x) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = i),
      (g[12] = r),
      (g[1] = s),
      (g[5] = o),
      (g[9] = a),
      (g[13] = l),
      (g[2] = u),
      (g[6] = c),
      (g[10] = d),
      (g[14] = p),
      (g[3] = m),
      (g[7] = v),
      (g[11] = _),
      (g[15] = x),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new _t().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / lf.setFromMatrixColumn(e, 0).length(),
      s = 1 / lf.setFromMatrixColumn(e, 1).length(),
      o = 1 / lf.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      l = Math.cos(r),
      u = Math.sin(r),
      c = Math.cos(s),
      d = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * c,
        m = o * d,
        v = a * c,
        _ = a * d;
      (t[0] = l * c),
        (t[4] = -l * d),
        (t[8] = u),
        (t[1] = m + v * u),
        (t[5] = p - _ * u),
        (t[9] = -a * l),
        (t[2] = _ - p * u),
        (t[6] = v + m * u),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const p = l * c,
        m = l * d,
        v = u * c,
        _ = u * d;
      (t[0] = p + _ * a),
        (t[4] = v * a - m),
        (t[8] = o * u),
        (t[1] = o * d),
        (t[5] = o * c),
        (t[9] = -a),
        (t[2] = m * a - v),
        (t[6] = _ + p * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const p = l * c,
        m = l * d,
        v = u * c,
        _ = u * d;
      (t[0] = p - _ * a),
        (t[4] = -o * d),
        (t[8] = v + m * a),
        (t[1] = m + v * a),
        (t[5] = o * c),
        (t[9] = _ - p * a),
        (t[2] = -o * u),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const p = o * c,
        m = o * d,
        v = a * c,
        _ = a * d;
      (t[0] = l * c),
        (t[4] = v * u - m),
        (t[8] = p * u + _),
        (t[1] = l * d),
        (t[5] = _ * u + p),
        (t[9] = m * u - v),
        (t[2] = -u),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const p = o * l,
        m = o * u,
        v = a * l,
        _ = a * u;
      (t[0] = l * c),
        (t[4] = _ - p * d),
        (t[8] = v * d + m),
        (t[1] = d),
        (t[5] = o * c),
        (t[9] = -a * c),
        (t[2] = -u * c),
        (t[6] = m * d + v),
        (t[10] = p - _ * d);
    } else if (e.order === "XZY") {
      const p = o * l,
        m = o * u,
        v = a * l,
        _ = a * u;
      (t[0] = l * c),
        (t[4] = -d),
        (t[8] = u * c),
        (t[1] = p * d + _),
        (t[5] = o * c),
        (t[9] = m * d - v),
        (t[2] = v * d - m),
        (t[6] = a * c),
        (t[10] = _ * d + p);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_9, e, x9);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      ts.subVectors(e, t),
      ts.lengthSq() === 0 && (ts.z = 1),
      ts.normalize(),
      rl.crossVectors(i, ts),
      rl.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (ts.x += 1e-4) : (ts.z += 1e-4),
        ts.normalize(),
        rl.crossVectors(i, ts)),
      rl.normalize(),
      _0.crossVectors(ts, rl),
      (r[0] = rl.x),
      (r[4] = _0.x),
      (r[8] = ts.x),
      (r[1] = rl.y),
      (r[5] = _0.y),
      (r[9] = ts.y),
      (r[2] = rl.z),
      (r[6] = _0.z),
      (r[10] = ts.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      l = i[8],
      u = i[12],
      c = i[1],
      d = i[5],
      p = i[9],
      m = i[13],
      v = i[2],
      _ = i[6],
      x = i[10],
      g = i[14],
      A = i[3],
      S = i[7],
      w = i[11],
      C = i[15],
      b = r[0],
      P = r[4],
      I = r[8],
      R = r[12],
      T = r[1],
      D = r[5],
      G = r[9],
      W = r[13],
      q = r[2],
      Z = r[6],
      K = r[10],
      te = r[14],
      O = r[3],
      Y = r[7],
      F = r[11],
      se = r[15];
    return (
      (s[0] = o * b + a * T + l * q + u * O),
      (s[4] = o * P + a * D + l * Z + u * Y),
      (s[8] = o * I + a * G + l * K + u * F),
      (s[12] = o * R + a * W + l * te + u * se),
      (s[1] = c * b + d * T + p * q + m * O),
      (s[5] = c * P + d * D + p * Z + m * Y),
      (s[9] = c * I + d * G + p * K + m * F),
      (s[13] = c * R + d * W + p * te + m * se),
      (s[2] = v * b + _ * T + x * q + g * O),
      (s[6] = v * P + _ * D + x * Z + g * Y),
      (s[10] = v * I + _ * G + x * K + g * F),
      (s[14] = v * R + _ * W + x * te + g * se),
      (s[3] = A * b + S * T + w * q + C * O),
      (s[7] = A * P + S * D + w * Z + C * Y),
      (s[11] = A * I + S * G + w * K + C * F),
      (s[15] = A * R + S * W + w * te + C * se),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      u = e[13],
      c = e[2],
      d = e[6],
      p = e[10],
      m = e[14],
      v = e[3],
      _ = e[7],
      x = e[11],
      g = e[15];
    return (
      v *
        (+s * l * d -
          r * u * d -
          s * a * p +
          i * u * p +
          r * a * m -
          i * l * m) +
      _ *
        (+t * l * m -
          t * u * p +
          s * o * p -
          r * o * m +
          r * u * c -
          s * l * c) +
      x *
        (+t * u * d -
          t * a * m -
          s * o * d +
          i * o * m +
          s * a * c -
          i * u * c) +
      g *
        (-r * a * c - t * l * d + t * a * p + r * o * d - i * o * p + i * l * c)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      c = e[8],
      d = e[9],
      p = e[10],
      m = e[11],
      v = e[12],
      _ = e[13],
      x = e[14],
      g = e[15],
      A = d * x * u - _ * p * u + _ * l * m - a * x * m - d * l * g + a * p * g,
      S = v * p * u - c * x * u - v * l * m + o * x * m + c * l * g - o * p * g,
      w = c * _ * u - v * d * u + v * a * m - o * _ * m - c * a * g + o * d * g,
      C = v * d * l - c * _ * l - v * a * p + o * _ * p + c * a * x - o * d * x,
      b = t * A + i * S + r * w + s * C;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / b;
    return (
      (e[0] = A * P),
      (e[1] =
        (_ * p * s -
          d * x * s -
          _ * r * m +
          i * x * m +
          d * r * g -
          i * p * g) *
        P),
      (e[2] =
        (a * x * s -
          _ * l * s +
          _ * r * u -
          i * x * u -
          a * r * g +
          i * l * g) *
        P),
      (e[3] =
        (d * l * s -
          a * p * s -
          d * r * u +
          i * p * u +
          a * r * m -
          i * l * m) *
        P),
      (e[4] = S * P),
      (e[5] =
        (c * x * s -
          v * p * s +
          v * r * m -
          t * x * m -
          c * r * g +
          t * p * g) *
        P),
      (e[6] =
        (v * l * s -
          o * x * s -
          v * r * u +
          t * x * u +
          o * r * g -
          t * l * g) *
        P),
      (e[7] =
        (o * p * s -
          c * l * s +
          c * r * u -
          t * p * u -
          o * r * m +
          t * l * m) *
        P),
      (e[8] = w * P),
      (e[9] =
        (v * d * s -
          c * _ * s -
          v * i * m +
          t * _ * m +
          c * i * g -
          t * d * g) *
        P),
      (e[10] =
        (o * _ * s -
          v * a * s +
          v * i * u -
          t * _ * u -
          o * i * g +
          t * a * g) *
        P),
      (e[11] =
        (c * a * s -
          o * d * s -
          c * i * u +
          t * d * u +
          o * i * m -
          t * a * m) *
        P),
      (e[12] = C * P),
      (e[13] =
        (c * _ * r -
          v * d * r +
          v * i * p -
          t * _ * p -
          c * i * x +
          t * d * x) *
        P),
      (e[14] =
        (v * a * r -
          o * _ * r -
          v * i * l +
          t * _ * l +
          o * i * x -
          t * a * x) *
        P),
      (e[15] =
        (o * d * r -
          c * a * r +
          c * i * l -
          t * d * l -
          o * i * p +
          t * a * p) *
        P),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      l = e.z,
      u = s * o,
      c = s * a;
    return (
      this.set(
        u * o + i,
        u * a - r * l,
        u * l + r * a,
        0,
        u * a + r * l,
        c * a + i,
        c * l - r * o,
        0,
        u * l - r * a,
        c * l + r * o,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      u = s + s,
      c = o + o,
      d = a + a,
      p = s * u,
      m = s * c,
      v = s * d,
      _ = o * c,
      x = o * d,
      g = a * d,
      A = l * u,
      S = l * c,
      w = l * d,
      C = i.x,
      b = i.y,
      P = i.z;
    return (
      (r[0] = (1 - (_ + g)) * C),
      (r[1] = (m + w) * C),
      (r[2] = (v - S) * C),
      (r[3] = 0),
      (r[4] = (m - w) * b),
      (r[5] = (1 - (p + g)) * b),
      (r[6] = (x + A) * b),
      (r[7] = 0),
      (r[8] = (v + S) * P),
      (r[9] = (x - A) * P),
      (r[10] = (1 - (p + _)) * P),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = lf.set(r[0], r[1], r[2]).length();
    const o = lf.set(r[4], r[5], r[6]).length(),
      a = lf.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      so.copy(this);
    const u = 1 / s,
      c = 1 / o,
      d = 1 / a;
    return (
      (so.elements[0] *= u),
      (so.elements[1] *= u),
      (so.elements[2] *= u),
      (so.elements[4] *= c),
      (so.elements[5] *= c),
      (so.elements[6] *= c),
      (so.elements[8] *= d),
      (so.elements[9] *= d),
      (so.elements[10] *= d),
      t.setFromRotationMatrix(so),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, s, o, a = po) {
    const l = this.elements,
      u = (2 * s) / (t - e),
      c = (2 * s) / (i - r),
      d = (t + e) / (t - e),
      p = (i + r) / (i - r);
    let m, v;
    if (a === po) (m = -(o + s) / (o - s)), (v = (-2 * o * s) / (o - s));
    else if (a === fm) (m = -o / (o - s)), (v = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = u),
      (l[4] = 0),
      (l[8] = d),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = c),
      (l[9] = p),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = m),
      (l[14] = v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, o, a = po) {
    const l = this.elements,
      u = 1 / (t - e),
      c = 1 / (i - r),
      d = 1 / (o - s),
      p = (t + e) * u,
      m = (i + r) * c;
    let v, _;
    if (a === po) (v = (o + s) * d), (_ = -2 * d);
    else if (a === fm) (v = s * d), (_ = -1 * d);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * u),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -p),
      (l[1] = 0),
      (l[5] = 2 * c),
      (l[9] = 0),
      (l[13] = -m),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = _),
      (l[14] = -v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const lf = new z(),
  so = new _t(),
  _9 = new z(0, 0, 0),
  x9 = new z(1, 1, 1),
  rl = new z(),
  _0 = new z(),
  ts = new z(),
  XP = new _t(),
  JP = new Ri();
class ys {
  constructor(e = 0, t = 0, i = 0, r = ys.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      l = r[1],
      u = r[5],
      c = r[9],
      d = r[2],
      p = r[6],
      m = r[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Rt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-c, m)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(p, u)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Rt(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._y = Math.atan2(a, m)), (this._z = Math.atan2(l, u)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Rt(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, m)), (this._z = Math.atan2(-o, u)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Rt(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, u)));
        break;
      case "YZX":
        (this._z = Math.asin(Rt(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-c, u)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-Rt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(p, u)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-c, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      XP.makeRotationFromQuaternion(e), this.setFromRotationMatrix(XP, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return JP.setFromEuler(this), this.setFromQuaternion(JP, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ys.DEFAULT_ORDER = "XYZ";
class oc {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let A9 = 0;
const jP = new z(),
  uf = new Ri(),
  aa = new _t(),
  x0 = new z(),
  Td = new z(),
  S9 = new z(),
  M9 = new Ri(),
  YP = new z(1, 0, 0),
  KP = new z(0, 1, 0),
  QP = new z(0, 0, 1),
  ZP = { type: "added" },
  w9 = { type: "removed" },
  cf = { type: "childadded", child: null },
  R1 = { type: "childremoved", child: null };
class qt extends Zo {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: A9++ }),
      (this.uuid = ms()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = qt.DEFAULT_UP.clone());
    const e = new z(),
      t = new ys(),
      i = new Ri(),
      r = new z(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new _t() },
        normalMatrix: { value: new It() },
      }),
      (this.matrix = new _t()),
      (this.matrixWorld = new _t()),
      (this.matrixAutoUpdate = qt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = qt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new oc()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return uf.setFromAxisAngle(e, t), this.quaternion.multiply(uf), this;
  }
  rotateOnWorldAxis(e, t) {
    return uf.setFromAxisAngle(e, t), this.quaternion.premultiply(uf), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(YP, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(KP, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(QP, e);
  }
  translateOnAxis(e, t) {
    return (
      jP.copy(e).applyQuaternion(this.quaternion),
      this.position.add(jP.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(YP, e);
  }
  translateY(e) {
    return this.translateOnAxis(KP, e);
  }
  translateZ(e) {
    return this.translateOnAxis(QP, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(aa.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? x0.copy(e) : x0.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Td.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? aa.lookAt(Td, x0, this.up)
        : aa.lookAt(x0, Td, this.up),
      this.quaternion.setFromRotationMatrix(aa),
      r &&
        (aa.extractRotation(r.matrixWorld),
        uf.setFromRotationMatrix(aa),
        this.quaternion.premultiply(uf.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(ZP),
            (cf.child = e),
            this.dispatchEvent(cf),
            (cf.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(w9),
        (R1.child = e),
        this.dispatchEvent(R1),
        (R1.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      aa.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), aa.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(aa),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(ZP),
      (cf.child = e),
      this.dispatchEvent(cf),
      (cf.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++)
      r[s].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Td, e, S9), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Td, M9, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) r[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = "BatchedMesh"),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.visibility = this._visibility),
        (r.active = this._active),
        (r.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (r.maxInstanceCount = this._maxInstanceCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.geometryCount = this._geometryCount),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray(),
          }));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let u = 0, c = l.length; u < c; u++) {
            const d = l[u];
            s(e.shapes, d);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, u = this.material.length; l < u; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        u = o(e.textures),
        c = o(e.images),
        d = o(e.shapes),
        p = o(e.skeletons),
        m = o(e.animations),
        v = o(e.nodes);
      a.length > 0 && (i.geometries = a),
        l.length > 0 && (i.materials = l),
        u.length > 0 && (i.textures = u),
        c.length > 0 && (i.images = c),
        d.length > 0 && (i.shapes = d),
        p.length > 0 && (i.skeletons = p),
        m.length > 0 && (i.animations = m),
        v.length > 0 && (i.nodes = v);
    }
    return (i.object = r), i;
    function o(a) {
      const l = [];
      for (const u in a) {
        const c = a[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
qt.DEFAULT_UP = new z(0, 1, 0);
qt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
qt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const oo = new z(),
  la = new z(),
  P1 = new z(),
  ua = new z(),
  ff = new z(),
  hf = new z(),
  qP = new z(),
  B1 = new z(),
  I1 = new z(),
  D1 = new z(),
  L1 = new tn(),
  F1 = new tn(),
  N1 = new tn();
class Or {
  constructor(e = new z(), t = new z(), i = new z()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), oo.subVectors(e, t), r.cross(oo);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    oo.subVectors(r, t), la.subVectors(i, t), P1.subVectors(e, t);
    const o = oo.dot(oo),
      a = oo.dot(la),
      l = oo.dot(P1),
      u = la.dot(la),
      c = la.dot(P1),
      d = o * u - a * a;
    if (d === 0) return s.set(0, 0, 0), null;
    const p = 1 / d,
      m = (u * l - a * c) * p,
      v = (o * c - a * l) * p;
    return s.set(1 - m - v, v, m);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, ua) === null
      ? !1
      : ua.x >= 0 && ua.y >= 0 && ua.x + ua.y <= 1;
  }
  static getInterpolation(e, t, i, r, s, o, a, l) {
    return this.getBarycoord(e, t, i, r, ua) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(s, ua.x),
        l.addScaledVector(o, ua.y),
        l.addScaledVector(a, ua.z),
        l);
  }
  static getInterpolatedAttribute(e, t, i, r, s, o) {
    return (
      L1.setScalar(0),
      F1.setScalar(0),
      N1.setScalar(0),
      L1.fromBufferAttribute(e, t),
      F1.fromBufferAttribute(e, i),
      N1.fromBufferAttribute(e, r),
      o.setScalar(0),
      o.addScaledVector(L1, s.x),
      o.addScaledVector(F1, s.y),
      o.addScaledVector(N1, s.z),
      o
    );
  }
  static isFrontFacing(e, t, i, r) {
    return oo.subVectors(i, t), la.subVectors(e, t), oo.cross(la).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      oo.subVectors(this.c, this.b),
      la.subVectors(this.a, this.b),
      oo.cross(la).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Or.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Or.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, r, s) {
    return Or.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return Or.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Or.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    ff.subVectors(r, i), hf.subVectors(s, i), B1.subVectors(e, i);
    const l = ff.dot(B1),
      u = hf.dot(B1);
    if (l <= 0 && u <= 0) return t.copy(i);
    I1.subVectors(e, r);
    const c = ff.dot(I1),
      d = hf.dot(I1);
    if (c >= 0 && d <= c) return t.copy(r);
    const p = l * d - c * u;
    if (p <= 0 && l >= 0 && c <= 0)
      return (o = l / (l - c)), t.copy(i).addScaledVector(ff, o);
    D1.subVectors(e, s);
    const m = ff.dot(D1),
      v = hf.dot(D1);
    if (v >= 0 && m <= v) return t.copy(s);
    const _ = m * u - l * v;
    if (_ <= 0 && u >= 0 && v <= 0)
      return (a = u / (u - v)), t.copy(i).addScaledVector(hf, a);
    const x = c * v - m * d;
    if (x <= 0 && d - c >= 0 && m - v >= 0)
      return (
        qP.subVectors(s, r),
        (a = (d - c) / (d - c + (m - v))),
        t.copy(r).addScaledVector(qP, a)
      );
    const g = 1 / (x + _ + p);
    return (
      (o = _ * g),
      (a = p * g),
      t.copy(i).addScaledVector(ff, o).addScaledVector(hf, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const aN = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  sl = { h: 0, s: 0, l: 0 },
  A0 = { h: 0, s: 0, l: 0 };
function O1(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class Ze {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
        ? this.setHex(r)
        : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Fr) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      en.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = en.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      en.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = en.workingColorSpace) {
    if (((e = hT(e, 1)), (t = Rt(t, 0, 1)), (i = Rt(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s;
      (this.r = O1(o, s, e + 1 / 3)),
        (this.g = O1(o, s, e)),
        (this.b = O1(o, s, e - 1 / 3));
    }
    return en.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = Fr) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Fr) {
    const i = aN[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = ba(e.r)), (this.g = ba(e.g)), (this.b = ba(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = lh(e.r)), (this.g = lh(e.g)), (this.b = lh(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Fr) {
    return (
      en.fromWorkingColorSpace(Ji.copy(this), e),
      Math.round(Rt(Ji.r * 255, 0, 255)) * 65536 +
        Math.round(Rt(Ji.g * 255, 0, 255)) * 256 +
        Math.round(Rt(Ji.b * 255, 0, 255))
    );
  }
  getHexString(e = Fr) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = en.workingColorSpace) {
    en.fromWorkingColorSpace(Ji.copy(this), t);
    const i = Ji.r,
      r = Ji.g,
      s = Ji.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let l, u;
    const c = (a + o) / 2;
    if (a === o) (l = 0), (u = 0);
    else {
      const d = o - a;
      switch (((u = c <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
        case i:
          l = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / d + 2;
          break;
        case s:
          l = (i - r) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = u), (e.l = c), e;
  }
  getRGB(e, t = en.workingColorSpace) {
    return (
      en.fromWorkingColorSpace(Ji.copy(this), t),
      (e.r = Ji.r),
      (e.g = Ji.g),
      (e.b = Ji.b),
      e
    );
  }
  getStyle(e = Fr) {
    en.fromWorkingColorSpace(Ji.copy(this), e);
    const t = Ji.r,
      i = Ji.g,
      r = Ji.b;
    return e !== Fr
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(
          r * 255
        )})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(sl), this.setHSL(sl.h + e, sl.s + t, sl.l + i);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(sl), e.getHSL(A0);
    const i = Ap(sl.h, A0.h, t),
      r = Ap(sl.s, A0.s, t),
      s = Ap(sl.l, A0.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Ji = new Ze();
Ze.NAMES = aN;
let E9 = 0;
class mi extends Zo {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: E9++ }),
      (this.uuid = ms()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = nc),
      (this.side = Yo),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = wy),
      (this.blendDst = Ey),
      (this.blendEquation = gl),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Ze(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = xc),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = QM),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Iu),
      (this.stencilZFail = Iu),
      (this.stencilZPass = Iu),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (i.dispersion = this.dispersion),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (i.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== nc && (i.blending = this.blending),
      this.side !== Yo && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== wy && (i.blendSrc = this.blendSrc),
      this.blendDst !== Ey && (i.blendDst = this.blendDst),
      this.blendEquation !== gl && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== xc && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== QM && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Iu && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== Iu && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Iu && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class hs extends mi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Ze(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ys()),
      (this.combine = Um),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const ya = T9();
function T9() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const u = l - 127;
    u < -27
      ? ((i[l] = 0), (i[l | 256] = 32768), (r[l] = 24), (r[l | 256] = 24))
      : u < -14
      ? ((i[l] = 1024 >> (-u - 14)),
        (i[l | 256] = (1024 >> (-u - 14)) | 32768),
        (r[l] = -u - 1),
        (r[l | 256] = -u - 1))
      : u <= 15
      ? ((i[l] = (u + 15) << 10),
        (i[l | 256] = ((u + 15) << 10) | 32768),
        (r[l] = 13),
        (r[l | 256] = 13))
      : u < 128
      ? ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 24), (r[l | 256] = 24))
      : ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 13), (r[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let u = l << 13,
      c = 0;
    for (; !(u & 8388608); ) (u <<= 1), (c -= 8388608);
    (u &= -8388609), (c += 947912704), (s[l] = u | c);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function Dr(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = Rt(n, -65504, 65504)),
    (ya.floatView[0] = n);
  const e = ya.uint32View[0],
    t = (e >> 23) & 511;
  return ya.baseTable[t] + ((e & 8388607) >> ya.shiftTable[t]);
}
function Qd(n) {
  const e = n >> 10;
  return (
    (ya.uint32View[0] =
      ya.mantissaTable[ya.offsetTable[e] + (n & 1023)] + ya.exponentTable[e]),
    ya.floatView[0]
  );
}
const C9 = { toHalfFloat: Dr, fromHalfFloat: Qd },
  ni = new z(),
  S0 = new Ae();
class rn {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = cm),
      (this.updateRanges = []),
      (this.gpuType = kr),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        S0.fromBufferAttribute(this, t),
          S0.applyMatrix3(e),
          this.setXY(t, S0.x, S0.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        ni.fromBufferAttribute(this, t),
          ni.applyMatrix3(e),
          this.setXYZ(t, ni.x, ni.y, ni.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ni.fromBufferAttribute(this, t),
        ni.applyMatrix4(e),
        this.setXYZ(t, ni.x, ni.y, ni.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ni.fromBufferAttribute(this, t),
        ni.applyNormalMatrix(e),
        this.setXYZ(t, ni.x, ni.y, ni.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ni.fromBufferAttribute(this, t),
        ni.transformDirection(e),
        this.setXYZ(t, ni.x, ni.y, ni.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = vr(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = Ft(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Ft(t, this.array)), (i = Ft(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ft(t, this.array)),
        (i = Ft(i, this.array)),
        (r = Ft(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ft(t, this.array)),
        (i = Ft(i, this.array)),
        (r = Ft(r, this.array)),
        (s = Ft(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== cm && (e.usage = this.usage),
      e
    );
  }
}
class b9 extends rn {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class R9 extends rn {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class P9 extends rn {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class B9 extends rn {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class dT extends rn {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class I9 extends rn {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class pT extends rn {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class D9 extends rn {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Qd(this.array[e * this.itemSize]);
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.array[e * this.itemSize] = Dr(t)),
      this
    );
  }
  getY(e) {
    let t = Qd(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.array[e * this.itemSize + 1] = Dr(t)),
      this
    );
  }
  getZ(e) {
    let t = Qd(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.array[e * this.itemSize + 2] = Dr(t)),
      this
    );
  }
  getW(e) {
    let t = Qd(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.array[e * this.itemSize + 3] = Dr(t)),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Ft(t, this.array)), (i = Ft(i, this.array))),
      (this.array[e + 0] = Dr(t)),
      (this.array[e + 1] = Dr(i)),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ft(t, this.array)),
        (i = Ft(i, this.array)),
        (r = Ft(r, this.array))),
      (this.array[e + 0] = Dr(t)),
      (this.array[e + 1] = Dr(i)),
      (this.array[e + 2] = Dr(r)),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ft(t, this.array)),
        (i = Ft(i, this.array)),
        (r = Ft(r, this.array)),
        (s = Ft(s, this.array))),
      (this.array[e + 0] = Dr(t)),
      (this.array[e + 1] = Dr(i)),
      (this.array[e + 2] = Dr(r)),
      (this.array[e + 3] = Dr(s)),
      this
    );
  }
}
class ht extends rn {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let L9 = 0;
const Ds = new _t(),
  U1 = new qt(),
  df = new z(),
  ns = new er(),
  Cd = new er(),
  Mi = new z();
class Lt extends Zo {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: L9++ }),
      (this.uuid = ms()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (rN(e) ? pT : dT)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new It().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Ds.makeRotationFromQuaternion(e), this.applyMatrix4(Ds), this;
  }
  rotateX(e) {
    return Ds.makeRotationX(e), this.applyMatrix4(Ds), this;
  }
  rotateY(e) {
    return Ds.makeRotationY(e), this.applyMatrix4(Ds), this;
  }
  rotateZ(e) {
    return Ds.makeRotationZ(e), this.applyMatrix4(Ds), this;
  }
  translate(e, t, i) {
    return Ds.makeTranslation(e, t, i), this.applyMatrix4(Ds), this;
  }
  scale(e, t, i) {
    return Ds.makeScale(e, t, i), this.applyMatrix4(Ds), this;
  }
  lookAt(e) {
    return U1.lookAt(e), U1.updateMatrix(), this.applyMatrix4(U1.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(df).negate(),
      this.translate(df.x, df.y, df.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const i = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const o = e[r];
        i.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new ht(i, 3));
    } else {
      const i = Math.min(e.length, t.count);
      for (let r = 0; r < i; r++) {
        const s = e[r];
        t.setXYZ(r, s.x, s.y, s.z || 0);
      }
      e.length > t.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
        ),
        (t.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new er());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new z(-1 / 0, -1 / 0, -1 / 0),
          new z(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          ns.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Mi.addVectors(this.boundingBox.min, ns.min),
                this.boundingBox.expandByPoint(Mi),
                Mi.addVectors(this.boundingBox.max, ns.max),
                this.boundingBox.expandByPoint(Mi))
              : (this.boundingBox.expandByPoint(ns.min),
                this.boundingBox.expandByPoint(ns.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ni());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new z(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((ns.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          Cd.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Mi.addVectors(ns.min, Cd.min),
                ns.expandByPoint(Mi),
                Mi.addVectors(ns.max, Cd.max),
                ns.expandByPoint(Mi))
              : (ns.expandByPoint(Cd.min), ns.expandByPoint(Cd.max));
        }
      ns.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Mi.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Mi)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let u = 0, c = a.count; u < c; u++)
            Mi.fromBufferAttribute(a, u),
              l && (df.fromBufferAttribute(e, u), Mi.add(df)),
              (r = Math.max(r, i.distanceToSquared(Mi)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = t.position,
      r = t.normal,
      s = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new rn(new Float32Array(4 * i.count), 4));
    const o = this.getAttribute("tangent"),
      a = [],
      l = [];
    for (let I = 0; I < i.count; I++) (a[I] = new z()), (l[I] = new z());
    const u = new z(),
      c = new z(),
      d = new z(),
      p = new Ae(),
      m = new Ae(),
      v = new Ae(),
      _ = new z(),
      x = new z();
    function g(I, R, T) {
      u.fromBufferAttribute(i, I),
        c.fromBufferAttribute(i, R),
        d.fromBufferAttribute(i, T),
        p.fromBufferAttribute(s, I),
        m.fromBufferAttribute(s, R),
        v.fromBufferAttribute(s, T),
        c.sub(u),
        d.sub(u),
        m.sub(p),
        v.sub(p);
      const D = 1 / (m.x * v.y - v.x * m.y);
      isFinite(D) &&
        (_.copy(c)
          .multiplyScalar(v.y)
          .addScaledVector(d, -m.y)
          .multiplyScalar(D),
        x
          .copy(d)
          .multiplyScalar(m.x)
          .addScaledVector(c, -v.x)
          .multiplyScalar(D),
        a[I].add(_),
        a[R].add(_),
        a[T].add(_),
        l[I].add(x),
        l[R].add(x),
        l[T].add(x));
    }
    let A = this.groups;
    A.length === 0 && (A = [{ start: 0, count: e.count }]);
    for (let I = 0, R = A.length; I < R; ++I) {
      const T = A[I],
        D = T.start,
        G = T.count;
      for (let W = D, q = D + G; W < q; W += 3)
        g(e.getX(W + 0), e.getX(W + 1), e.getX(W + 2));
    }
    const S = new z(),
      w = new z(),
      C = new z(),
      b = new z();
    function P(I) {
      C.fromBufferAttribute(r, I), b.copy(C);
      const R = a[I];
      S.copy(R),
        S.sub(C.multiplyScalar(C.dot(R))).normalize(),
        w.crossVectors(b, R);
      const D = w.dot(l[I]) < 0 ? -1 : 1;
      o.setXYZW(I, S.x, S.y, S.z, D);
    }
    for (let I = 0, R = A.length; I < R; ++I) {
      const T = A[I],
        D = T.start,
        G = T.count;
      for (let W = D, q = D + G; W < q; W += 3)
        P(e.getX(W + 0)), P(e.getX(W + 1)), P(e.getX(W + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new rn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let p = 0, m = i.count; p < m; p++) i.setXYZ(p, 0, 0, 0);
      const r = new z(),
        s = new z(),
        o = new z(),
        a = new z(),
        l = new z(),
        u = new z(),
        c = new z(),
        d = new z();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const v = e.getX(p + 0),
            _ = e.getX(p + 1),
            x = e.getX(p + 2);
          r.fromBufferAttribute(t, v),
            s.fromBufferAttribute(t, _),
            o.fromBufferAttribute(t, x),
            c.subVectors(o, s),
            d.subVectors(r, s),
            c.cross(d),
            a.fromBufferAttribute(i, v),
            l.fromBufferAttribute(i, _),
            u.fromBufferAttribute(i, x),
            a.add(c),
            l.add(c),
            u.add(c),
            i.setXYZ(v, a.x, a.y, a.z),
            i.setXYZ(_, l.x, l.y, l.z),
            i.setXYZ(x, u.x, u.y, u.z);
        }
      else
        for (let p = 0, m = t.count; p < m; p += 3)
          r.fromBufferAttribute(t, p + 0),
            s.fromBufferAttribute(t, p + 1),
            o.fromBufferAttribute(t, p + 2),
            c.subVectors(o, s),
            d.subVectors(r, s),
            c.cross(d),
            i.setXYZ(p + 0, c.x, c.y, c.z),
            i.setXYZ(p + 1, c.x, c.y, c.z),
            i.setXYZ(p + 2, c.x, c.y, c.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      Mi.fromBufferAttribute(e, t),
        Mi.normalize(),
        e.setXYZ(t, Mi.x, Mi.y, Mi.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const u = a.array,
        c = a.itemSize,
        d = a.normalized,
        p = new u.constructor(l.length * c);
      let m = 0,
        v = 0;
      for (let _ = 0, x = l.length; _ < x; _++) {
        a.isInterleavedBufferAttribute
          ? (m = l[_] * a.data.stride + a.offset)
          : (m = l[_] * c);
        for (let g = 0; g < c; g++) p[v++] = u[m++];
      }
      return new rn(p, c, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new Lt(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const l = r[a],
        u = e(l, i);
      t.setAttribute(a, u);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        u = s[a];
      for (let c = 0, d = u.length; c < d; c++) {
        const p = u[c],
          m = e(p, i);
        l.push(m);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a];
      t.addGroup(u.start, u.count, u.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const u in l) l[u] !== void 0 && (e[u] = l[u]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const u = i[l];
      e.data.attributes[l] = u.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const u = this.morphAttributes[l],
        c = [];
      for (let d = 0, p = u.length; d < p; d++) {
        const m = u[d];
        c.push(m.toJSON(e.data));
      }
      c.length > 0 && ((r[l] = c), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const u in r) {
      const c = r[u];
      this.setAttribute(u, c.clone(t));
    }
    const s = e.morphAttributes;
    for (const u in s) {
      const c = [],
        d = s[u];
      for (let p = 0, m = d.length; p < m; p++) c.push(d[p].clone(t));
      this.morphAttributes[u] = c;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let u = 0, c = o.length; u < c; u++) {
      const d = o[u];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const $P = new _t(),
  hu = new Fc(),
  M0 = new Ni(),
  e2 = new z(),
  w0 = new z(),
  E0 = new z(),
  T0 = new z(),
  k1 = new z(),
  C0 = new z(),
  t2 = new z(),
  b0 = new z();
class qn extends qt {
  constructor(e = new Lt(), t = new hs()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      C0.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const c = a[l],
          d = s[l];
        c !== 0 &&
          (k1.fromBufferAttribute(d, e),
          o ? C0.addScaledVector(k1, c) : C0.addScaledVector(k1.sub(t), c));
      }
      t.add(C0);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      M0.copy(i.boundingSphere),
      M0.applyMatrix4(s),
      hu.copy(e.ray).recast(e.near),
      !(
        M0.containsPoint(hu.origin) === !1 &&
        (hu.intersectSphere(M0, e2) === null ||
          hu.origin.distanceToSquared(e2) > (e.far - e.near) ** 2)
      ) &&
        ($P.copy(s).invert(),
        hu.copy(e.ray).applyMatrix4($P),
        !(i.boundingBox !== null && hu.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, hu)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      u = s.attributes.uv,
      c = s.attributes.uv1,
      d = s.attributes.normal,
      p = s.groups,
      m = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let v = 0, _ = p.length; v < _; v++) {
          const x = p[v],
            g = o[x.materialIndex],
            A = Math.max(x.start, m.start),
            S = Math.min(
              a.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let w = A, C = S; w < C; w += 3) {
            const b = a.getX(w),
              P = a.getX(w + 1),
              I = a.getX(w + 2);
            (r = R0(this, g, e, i, u, c, d, b, P, I)),
              r &&
                ((r.faceIndex = Math.floor(w / 3)),
                (r.face.materialIndex = x.materialIndex),
                t.push(r));
          }
        }
      else {
        const v = Math.max(0, m.start),
          _ = Math.min(a.count, m.start + m.count);
        for (let x = v, g = _; x < g; x += 3) {
          const A = a.getX(x),
            S = a.getX(x + 1),
            w = a.getX(x + 2);
          (r = R0(this, o, e, i, u, c, d, A, S, w)),
            r && ((r.faceIndex = Math.floor(x / 3)), t.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let v = 0, _ = p.length; v < _; v++) {
          const x = p[v],
            g = o[x.materialIndex],
            A = Math.max(x.start, m.start),
            S = Math.min(
              l.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let w = A, C = S; w < C; w += 3) {
            const b = w,
              P = w + 1,
              I = w + 2;
            (r = R0(this, g, e, i, u, c, d, b, P, I)),
              r &&
                ((r.faceIndex = Math.floor(w / 3)),
                (r.face.materialIndex = x.materialIndex),
                t.push(r));
          }
        }
      else {
        const v = Math.max(0, m.start),
          _ = Math.min(l.count, m.start + m.count);
        for (let x = v, g = _; x < g; x += 3) {
          const A = x,
            S = x + 1,
            w = x + 2;
          (r = R0(this, o, e, i, u, c, d, A, S, w)),
            r && ((r.faceIndex = Math.floor(x / 3)), t.push(r));
        }
      }
  }
}
function F9(n, e, t, i, r, s, o, a) {
  let l;
  if (
    (e.side === Ar
      ? (l = i.intersectTriangle(o, s, r, !0, a))
      : (l = i.intersectTriangle(r, s, o, e.side === Yo, a)),
    l === null)
  )
    return null;
  b0.copy(a), b0.applyMatrix4(n.matrixWorld);
  const u = t.ray.origin.distanceTo(b0);
  return u < t.near || u > t.far
    ? null
    : { distance: u, point: b0.clone(), object: n };
}
function R0(n, e, t, i, r, s, o, a, l, u) {
  n.getVertexPosition(a, w0),
    n.getVertexPosition(l, E0),
    n.getVertexPosition(u, T0);
  const c = F9(n, e, t, i, w0, E0, T0, t2);
  if (c) {
    const d = new z();
    Or.getBarycoord(t2, w0, E0, T0, d),
      r && (c.uv = Or.getInterpolatedAttribute(r, a, l, u, d, new Ae())),
      s && (c.uv1 = Or.getInterpolatedAttribute(s, a, l, u, d, new Ae())),
      o &&
        ((c.normal = Or.getInterpolatedAttribute(o, a, l, u, d, new z())),
        c.normal.dot(i.direction) > 0 && c.normal.multiplyScalar(-1));
    const p = { a, b: l, c: u, normal: new z(), materialIndex: 0 };
    Or.getNormal(w0, E0, T0, p.normal), (c.face = p), (c.barycoord = d);
  }
  return c;
}
class Nc extends Lt {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      u = [],
      c = [],
      d = [];
    let p = 0,
      m = 0;
    v("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      v("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      v("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      v("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      v("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      v("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new ht(u, 3)),
      this.setAttribute("normal", new ht(c, 3)),
      this.setAttribute("uv", new ht(d, 2));
    function v(_, x, g, A, S, w, C, b, P, I, R) {
      const T = w / P,
        D = C / I,
        G = w / 2,
        W = C / 2,
        q = b / 2,
        Z = P + 1,
        K = I + 1;
      let te = 0,
        O = 0;
      const Y = new z();
      for (let F = 0; F < K; F++) {
        const se = F * D - W;
        for (let Me = 0; Me < Z; Me++) {
          const De = Me * T - G;
          (Y[_] = De * A),
            (Y[x] = se * S),
            (Y[g] = q),
            u.push(Y.x, Y.y, Y.z),
            (Y[_] = 0),
            (Y[x] = 0),
            (Y[g] = b > 0 ? 1 : -1),
            c.push(Y.x, Y.y, Y.z),
            d.push(Me / P),
            d.push(1 - F / I),
            (te += 1);
        }
      }
      for (let F = 0; F < I; F++)
        for (let se = 0; se < P; se++) {
          const Me = p + se + Z * F,
            De = p + se + Z * (F + 1),
            re = p + (se + 1) + Z * (F + 1),
            xe = p + (se + 1) + Z * F;
          l.push(Me, De, xe), l.push(De, re, xe), (O += 6);
        }
      a.addGroup(m, O, R), (m += O), (p += te);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Nc(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Rh(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
        ? (e[t][i] = r.slice())
        : (e[t][i] = r);
    }
  }
  return e;
}
function fr(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = Rh(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function N9(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function lN(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : en.workingColorSpace;
}
const uN = { clone: Rh, merge: fr };
var O9 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  U9 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ao extends mi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = O9),
      (this.fragmentShader = U9),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Rh(e.uniforms)),
      (this.uniformsGroups = N9(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[r] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
        : (t.uniforms[r] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Hm extends qt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new _t()),
      (this.projectionMatrix = new _t()),
      (this.projectionMatrixInverse = new _t()),
      (this.coordinateSystem = po);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ol = new z(),
  n2 = new Ae(),
  i2 = new Ae();
class bn extends Hm {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = bh * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(sc * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return bh * 2 * Math.atan(Math.tan(sc * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    ol.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(ol.x, ol.y).multiplyScalar(-e / ol.z),
      ol.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(ol.x, ol.y).multiplyScalar(-e / ol.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, n2, i2), t.subVectors(i2, n2);
  }
  setViewOffset(e, t, i, r, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(sc * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        u = o.fullHeight;
      (s += (o.offsetX * r) / l),
        (t -= (o.offsetY * i) / u),
        (r *= o.width / l),
        (i *= o.height / u);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const pf = -90,
  mf = 1;
class mT extends qt {
  constructor(e, t, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const r = new bn(pf, mf, e, t);
    (r.layers = this.layers), this.add(r);
    const s = new bn(pf, mf, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new bn(pf, mf, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new bn(pf, mf, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new bn(pf, mf, e, t);
    (l.layers = this.layers), this.add(l);
    const u = new bn(pf, mf, e, t);
    (u.layers = this.layers), this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, o, a, l] = t;
    for (const u of t) this.remove(u);
    if (e === po)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === fm)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const u of t) this.add(u), u.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, l, u, c] = this.children,
      d = e.getRenderTarget(),
      p = e.getActiveCubeFace(),
      m = e.getActiveMipmapLevel(),
      v = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(t, s),
      e.setRenderTarget(i, 1, r),
      e.render(t, o),
      e.setRenderTarget(i, 2, r),
      e.render(t, a),
      e.setRenderTarget(i, 3, r),
      e.render(t, l),
      e.setRenderTarget(i, 4, r),
      e.render(t, u),
      (i.texture.generateMipmaps = _),
      e.setRenderTarget(i, 5, r),
      e.render(t, c),
      e.setRenderTarget(d, p, m),
      (e.xr.enabled = v),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class Gm extends Pn {
  constructor(e, t, i, r, s, o, a, l, u, c) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Oa),
      super(e, t, i, r, s, o, a, l, u, c),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class gT extends Ko {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    (this.texture = new Gm(
      r,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Zn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Nc(5, 5, 5),
      s = new Ao({
        name: "CubemapFromEquirect",
        uniforms: Rh(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Ar,
        blending: Ca,
      });
    s.uniforms.tEquirect.value = t;
    const o = new qn(r, s),
      a = t.minFilter;
    return (
      t.minFilter === Xs && (t.minFilter = Zn),
      new mT(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
class fx {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Ze(e)),
      (this.density = t);
  }
  clone() {
    return new fx(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class hx {
  constructor(e, t = 1, i = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Ze(e)),
      (this.near = t),
      (this.far = i);
  }
  clone() {
    return new hx(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class vT extends qt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new ys()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new ys()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class Vm {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = cm),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = ms());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ms()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ms()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const lr = new z();
class Hl {
  constructor(e, t, i, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      lr.fromBufferAttribute(this, t),
        lr.applyMatrix4(e),
        this.setXYZ(t, lr.x, lr.y, lr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      lr.fromBufferAttribute(this, t),
        lr.applyNormalMatrix(e),
        this.setXYZ(t, lr.x, lr.y, lr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      lr.fromBufferAttribute(this, t),
        lr.transformDirection(e),
        this.setXYZ(t, lr.x, lr.y, lr.z);
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (i = vr(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = Ft(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = i),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Ft(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = vr(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = vr(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = vr(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = vr(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Ft(t, this.array)), (i = Ft(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Ft(t, this.array)),
        (i = Ft(i, this.array)),
        (r = Ft(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Ft(t, this.array)),
        (i = Ft(i, this.array)),
        (r = Ft(r, this.array)),
        (s = Ft(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new rn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Hl(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class yT extends mi {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Ze(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let gf;
const bd = new z(),
  vf = new z(),
  yf = new z(),
  _f = new Ae(),
  Rd = new Ae(),
  cN = new _t(),
  P0 = new z(),
  Pd = new z(),
  B0 = new z(),
  r2 = new Ae(),
  z1 = new Ae(),
  s2 = new Ae();
class fN extends qt {
  constructor(e = new yT()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), gf === void 0)
    ) {
      gf = new Lt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new Vm(t, 5);
      gf.setIndex([0, 1, 2, 0, 2, 3]),
        gf.setAttribute("position", new Hl(i, 3, 0, !1)),
        gf.setAttribute("uv", new Hl(i, 2, 3, !1));
    }
    (this.geometry = gf), (this.material = e), (this.center = new Ae(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      vf.setFromMatrixScale(this.matrixWorld),
      cN.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      yf.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        vf.multiplyScalar(-yf.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
    const o = this.center;
    I0(P0.set(-0.5, -0.5, 0), yf, o, vf, r, s),
      I0(Pd.set(0.5, -0.5, 0), yf, o, vf, r, s),
      I0(B0.set(0.5, 0.5, 0), yf, o, vf, r, s),
      r2.set(0, 0),
      z1.set(1, 0),
      s2.set(1, 1);
    let a = e.ray.intersectTriangle(P0, Pd, B0, !1, bd);
    if (
      a === null &&
      (I0(Pd.set(-0.5, 0.5, 0), yf, o, vf, r, s),
      z1.set(0, 1),
      (a = e.ray.intersectTriangle(P0, B0, Pd, !1, bd)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(bd);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: bd.clone(),
        uv: Or.getInterpolation(bd, P0, Pd, B0, r2, z1, s2, new Ae()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function I0(n, e, t, i, r, s) {
  _f.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((Rd.x = s * _f.x - r * _f.y), (Rd.y = r * _f.x + s * _f.y))
      : Rd.copy(_f),
    n.copy(e),
    (n.x += Rd.x),
    (n.y += Rd.y),
    n.applyMatrix4(cN);
}
const D0 = new z(),
  o2 = new z();
class hN extends qt {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: i, object: e }),
      this.add(e),
      this
    );
  }
  removeLevel(e) {
    const t = this.levels;
    for (let i = 0; i < t.length; i++)
      if (t[i].distance === e) {
        const r = t.splice(i, 1);
        return this.remove(r[0].object), !0;
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      D0.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(D0);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      D0.setFromMatrixPosition(e.matrixWorld),
        o2.setFromMatrixPosition(this.matrixWorld);
      const i = D0.distanceTo(o2) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), i >= o))
          (t[r - 1].object.visible = !1), (t[r].object.visible = !0);
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const a2 = new z(),
  l2 = new tn(),
  u2 = new tn(),
  k9 = new z(),
  c2 = new _t(),
  L0 = new z(),
  H1 = new Ni(),
  f2 = new _t(),
  G1 = new Fc();
class _T extends qn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = KM),
      (this.bindMatrix = new _t()),
      (this.bindMatrixInverse = new _t()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new er()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, L0), this.boundingBox.expandByPoint(L0);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Ni()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, L0), this.boundingSphere.expandByPoint(L0);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      H1.copy(this.boundingSphere),
      H1.applyMatrix4(r),
      e.ray.intersectsSphere(H1) !== !1 &&
        (f2.copy(r).invert(),
        G1.copy(e.ray).applyMatrix4(f2),
        !(
          this.boundingBox !== null && G1.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, G1)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new tn(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === KM
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === GF
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    l2.fromBufferAttribute(r.attributes.skinIndex, e),
      u2.fromBufferAttribute(r.attributes.skinWeight, e),
      a2.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = u2.getComponent(s);
      if (o !== 0) {
        const a = l2.getComponent(s);
        c2.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(k9.copy(a2).applyMatrix4(c2), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class dx extends qt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Wo extends Pn {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, u = bi, c = bi, d, p) {
    super(null, o, a, l, u, c, r, s, d, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const h2 = new _t(),
  z9 = new _t();
class Wm {
  constructor(e = [], t = []) {
    (this.uuid = ms()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new _t());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new _t();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : z9;
      h2.multiplyMatrices(a, t[s]), h2.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Wm(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Wo(t, e, e, $i, kr);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new dx())),
        this.bones.push(o),
        this.boneInverses.push(new _t().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class wc extends rn {
  constructor(e, t, i, r = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const xf = new _t(),
  d2 = new _t(),
  F0 = [],
  p2 = new er(),
  H9 = new _t(),
  Bd = new qn(),
  Id = new Ni();
class xT extends qn {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new wc(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let r = 0; r < i; r++) this.setMatrixAt(r, H9);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new er()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, xf),
        p2.copy(e.boundingBox).applyMatrix4(xf),
        this.boundingBox.union(p2);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Ni()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, xf),
        Id.copy(e.boundingSphere).applyMatrix4(xf),
        this.boundingSphere.union(Id);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = this.morphTexture.source.data.data,
      s = i.length + 1,
      o = e * s + 1;
    for (let a = 0; a < i.length; a++) i[a] = r[o + a];
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((Bd.geometry = this.geometry),
      (Bd.material = this.material),
      Bd.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Id.copy(this.boundingSphere),
        Id.applyMatrix4(i),
        e.ray.intersectsSphere(Id) !== !1))
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, xf),
          d2.multiplyMatrices(i, xf),
          (Bd.matrixWorld = d2),
          Bd.raycast(e, F0);
        for (let o = 0, a = F0.length; o < a; o++) {
          const l = F0[o];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        F0.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new wc(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = i.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Wo(
        new Float32Array(r * this.count),
        r,
        this.count,
        sx,
        kr
      ));
    const s = this.morphTexture.source.data.data;
    let o = 0;
    for (let u = 0; u < i.length; u++) o += i[u];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      l = r * e;
    (s[l] = a), s.set(i, l + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
const V1 = new z(),
  G9 = new z(),
  V9 = new It();
class ma {
  constructor(e = new z(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = V1.subVectors(i, t).cross(G9.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(V1),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || V9.getNormalMatrix(e),
      r = this.coplanarPoint(V1).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const du = new Ni(),
  N0 = new z();
class Xm {
  constructor(
    e = new ma(),
    t = new ma(),
    i = new ma(),
    r = new ma(),
    s = new ma(),
    o = new ma()
  ) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = po) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      l = r[3],
      u = r[4],
      c = r[5],
      d = r[6],
      p = r[7],
      m = r[8],
      v = r[9],
      _ = r[10],
      x = r[11],
      g = r[12],
      A = r[13],
      S = r[14],
      w = r[15];
    if (
      (i[0].setComponents(l - s, p - u, x - m, w - g).normalize(),
      i[1].setComponents(l + s, p + u, x + m, w + g).normalize(),
      i[2].setComponents(l + o, p + c, x + v, w + A).normalize(),
      i[3].setComponents(l - o, p - c, x - v, w - A).normalize(),
      i[4].setComponents(l - a, p - d, x - _, w - S).normalize(),
      t === po)
    )
      i[5].setComponents(l + a, p + d, x + _, w + S).normalize();
    else if (t === fm) i[5].setComponents(a, d, _, S).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        du.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        du.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(du);
  }
  intersectsSprite(e) {
    return (
      du.center.set(0, 0, 0),
      (du.radius = 0.7071067811865476),
      du.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(du)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((N0.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (N0.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (N0.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(N0) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function W1(n, e) {
  return n - e;
}
function W9(n, e) {
  return n.z - e.z;
}
function X9(n, e) {
  return e.z - n.z;
}
class J9 {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, i, r) {
    const s = this.pool,
      o = this.list;
    this.index >= s.length &&
      s.push({ start: -1, count: -1, z: -1, index: -1 });
    const a = s[this.index];
    o.push(a),
      this.index++,
      (a.start = e),
      (a.count = t),
      (a.z = i),
      (a.index = r);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Ir = new _t(),
  j9 = new Ze(1, 1, 1),
  X1 = new Xm(),
  O0 = new er(),
  pu = new Ni(),
  Dd = new z(),
  m2 = new z(),
  Y9 = new z(),
  J1 = new J9(),
  ji = new qn(),
  U0 = [];
function K9(n, e, t = 0) {
  const i = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const r = n.count;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < i; o++)
        e.setComponent(s + t, o, n.getComponent(s, o));
  } else e.array.set(n.array, t * i);
  e.needsUpdate = !0;
}
function mu(n, e) {
  if (n.constructor !== e.constructor) {
    const t = Math.min(n.length, e.length);
    for (let i = 0; i < t; i++) e[i] = n[i];
  } else {
    const t = Math.min(n.length, e.length);
    e.set(new n.constructor(n.buffer, 0, t));
  }
}
class dN extends qn {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  constructor(e, t, i = t * 2, r) {
    super(new Lt(), r),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = i),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      i = new Wo(t, e, e, $i, kr);
    this._matricesTexture = i;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      i = new Wo(t, e, e, km, Ua);
    this._indirectTexture = i;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      i = new Wo(t, e, e, $i, kr);
    (i.colorSpace = en.workingColorSpace), (this._colorsTexture = i);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      i = this._maxVertexCount,
      r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const s in e.attributes) {
        const o = e.getAttribute(s),
          { array: a, itemSize: l, normalized: u } = o,
          c = new a.constructor(i * l),
          d = new rn(c, l, u);
        t.setAttribute(s, d);
      }
      if (e.getIndex() !== null) {
        const s = i > 65535 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new rn(s, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".'
      );
    for (const i in t.attributes) {
      if (!e.hasAttribute(i))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`
        );
      const r = e.getAttribute(i),
        s = t.getAttribute(i);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error(
          "THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`
      );
  }
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`
      );
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new er());
    const e = this.boundingBox,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let i = 0, r = t.length; i < r; i++) {
      if (t[i].active === !1) continue;
      const s = t[i].geometryIndex;
      this.getMatrixAt(i, Ir),
        this.getBoundingBoxAt(s, O0).applyMatrix4(Ir),
        e.union(O0);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ni());
    const e = this.boundingSphere,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let i = 0, r = t.length; i < r; i++) {
      if (t[i].active === !1) continue;
      const s = t[i].geometryIndex;
      this.getMatrixAt(i, Ir),
        this.getBoundingSphereAt(s, pu).applyMatrix4(Ir),
        e.union(pu);
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const i = { visible: !0, active: !0, geometryIndex: e };
    let r = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(W1),
        (r = this._availableInstanceIds.shift()),
        (this._instanceInfo[r] = i))
      : ((r = this._instanceInfo.length), this._instanceInfo.push(i));
    const s = this._matricesTexture;
    Ir.identity().toArray(s.image.data, r * 16), (s.needsUpdate = !0);
    const o = this._colorsTexture;
    return (
      o && (j9.toArray(o.image.data, r * 4), (o.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      r
    );
  }
  addGeometry(e, t = -1, i = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const r = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      s = this._geometryInfo;
    (r.vertexStart = this._nextVertexStart),
      (r.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t);
    const o = e.getIndex();
    if (
      (o !== null &&
        ((r.indexStart = this._nextIndexStart),
        (r.reservedIndexCount = i === -1 ? o.count : i)),
      (r.indexStart !== -1 &&
        r.indexStart + r.reservedIndexCount > this._maxIndexCount) ||
        r.vertexStart + r.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    let l;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(W1),
          (l = this._availableGeometryIds.shift()),
          (s[l] = r))
        : ((l = this._geometryCount), this._geometryCount++, s.push(r)),
      this.setGeometryAt(l, e),
      (this._nextIndexStart = r.indexStart + r.reservedIndexCount),
      (this._nextVertexStart = r.vertexStart + r.reservedVertexCount),
      l
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const i = this.geometry,
      r = i.getIndex() !== null,
      s = i.getIndex(),
      o = t.getIndex(),
      a = this._geometryInfo[e];
    if (
      (r && o.count > a.reservedIndexCount) ||
      t.attributes.position.count > a.reservedVertexCount
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const l = a.vertexStart,
      u = a.reservedVertexCount;
    a.vertexCount = t.getAttribute("position").count;
    for (const c in i.attributes) {
      const d = t.getAttribute(c),
        p = i.getAttribute(c);
      K9(d, p, l);
      const m = d.itemSize;
      for (let v = d.count, _ = u; v < _; v++) {
        const x = l + v;
        for (let g = 0; g < m; g++) p.setComponent(x, g, 0);
      }
      (p.needsUpdate = !0), p.addUpdateRange(l * m, u * m);
    }
    if (r) {
      const c = a.indexStart,
        d = a.reservedIndexCount;
      a.indexCount = t.getIndex().count;
      for (let p = 0; p < o.count; p++) s.setX(c + p, l + o.getX(p));
      for (let p = o.count, m = d; p < m; p++) s.setX(c + p, l);
      (s.needsUpdate = !0), s.addUpdateRange(c, a.reservedIndexCount);
    }
    return (
      (a.start = r ? a.indexStart : a.vertexStart),
      (a.count = r ? a.indexCount : a.vertexCount),
      (a.boundingBox = null),
      t.boundingBox !== null && (a.boundingBox = t.boundingBox.clone()),
      (a.boundingSphere = null),
      t.boundingSphere !== null &&
        (a.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    );
  }
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1) return this;
    const i = this._instanceInfo;
    for (let r = 0, s = i.length; r < s; r++)
      i[r].geometryIndex === e && this.deleteInstance(r);
    return (
      (t[e].active = !1),
      this._availableGeometryIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let e = 0,
      t = 0;
    const i = this._geometryInfo,
      r = i
        .map((o, a) => a)
        .sort((o, a) => i[o].vertexStart - i[a].vertexStart),
      s = this.geometry;
    for (let o = 0, a = i.length; o < a; o++) {
      const l = r[o],
        u = i[l];
      if (u.active !== !1) {
        if (s.index !== null) {
          if (u.indexStart !== t) {
            const { indexStart: c, vertexStart: d, reservedIndexCount: p } = u,
              m = s.index,
              v = m.array,
              _ = e - d;
            for (let x = c; x < c + p; x++) v[x] = v[x] + _;
            m.array.copyWithin(t, c, c + p),
              m.addUpdateRange(t, p),
              (u.indexStart = t);
          }
          t += u.reservedIndexCount;
        }
        if (u.vertexStart !== e) {
          const { vertexStart: c, reservedVertexCount: d } = u,
            p = s.attributes;
          for (const m in p) {
            const v = p[m],
              { array: _, itemSize: x } = v;
            _.copyWithin(e * x, c * x, (c + d) * x),
              v.addUpdateRange(e * x, d * x);
          }
          u.vertexStart = e;
        }
        (e += u.reservedVertexCount),
          (u.start = s.index ? u.indexStart : u.vertexStart),
          (this._nextIndexStart = s.index
            ? u.indexStart + u.reservedIndexCount
            : 0),
          (this._nextVertexStart = u.vertexStart + u.reservedVertexCount);
      }
    }
    return this;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const i = this.geometry,
      r = this._geometryInfo[e];
    if (r.boundingBox === null) {
      const s = new er(),
        o = i.index,
        a = i.attributes.position;
      for (let l = r.start, u = r.start + r.count; l < u; l++) {
        let c = l;
        o && (c = o.getX(c)), s.expandByPoint(Dd.fromBufferAttribute(a, c));
      }
      r.boundingBox = s;
    }
    return t.copy(r.boundingBox), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const i = this.geometry,
      r = this._geometryInfo[e];
    if (r.boundingSphere === null) {
      const s = new Ni();
      this.getBoundingBoxAt(e, O0), O0.getCenter(s.center);
      const o = i.index,
        a = i.attributes.position;
      let l = 0;
      for (let u = r.start, c = r.start + r.count; u < c; u++) {
        let d = u;
        o && (d = o.getX(d)),
          Dd.fromBufferAttribute(a, d),
          (l = Math.max(l, s.center.distanceToSquared(Dd)));
      }
      (s.radius = Math.sqrt(l)), (r.boundingSphere = s);
    }
    return t.copy(r.boundingSphere), t;
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const i = this._matricesTexture,
      r = this._matricesTexture.image.data;
    return t.toArray(r, e * 16), (i.needsUpdate = !0), this;
  }
  getMatrixAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._matricesTexture.image.data, e * 16)
    );
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._colorsTexture.image.data, e * 4)
    );
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t),
          (this._visibilityChanged = !0),
          this)
    );
  }
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    );
  }
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const i = this._geometryInfo[e];
    return (
      (t.vertexStart = i.vertexStart),
      (t.vertexCount = i.vertexCount),
      (t.reservedVertexCount = i.reservedVertexCount),
      (t.indexStart = i.indexStart),
      (t.indexCount = i.indexCount),
      (t.reservedIndexCount = i.reservedIndexCount),
      (t.start = i.start),
      (t.count = i.count),
      t
    );
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      i = this._instanceInfo;
    for (t.sort(W1); t[t.length - 1] === i.length; ) i.pop(), t.pop();
    if (e < i.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`
      );
    const r = new Int32Array(e),
      s = new Int32Array(e);
    mu(this._multiDrawCounts, r),
      mu(this._multiDrawStarts, s),
      (this._multiDrawCounts = r),
      (this._multiDrawStarts = s),
      (this._maxInstanceCount = e);
    const o = this._indirectTexture,
      a = this._matricesTexture,
      l = this._colorsTexture;
    o.dispose(),
      this._initIndirectTexture(),
      mu(o.image.data, this._indirectTexture.image.data),
      a.dispose(),
      this._initMatricesTexture(),
      mu(a.image.data, this._matricesTexture.image.data),
      l &&
        (l.dispose(),
        this._initColorsTexture(),
        mu(l.image.data, this._colorsTexture.image.data));
  }
  setGeometrySize(e, t) {
    const i = [...this._geometryInfo].filter((a) => a.active);
    if (Math.max(...i.map((a) => a.vertexStart + a.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`
      );
    if (
      this.geometry.index &&
      Math.max(...i.map((l) => l.indexStart + l.reservedIndexCount)) > t
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`
      );
    const s = this.geometry;
    s.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new Lt()),
        this._initializeGeometry(s));
    const o = this.geometry;
    s.index && mu(s.index.array, o.index.array);
    for (const a in s.attributes)
      mu(s.attributes[a].array, o.attributes[a].array);
  }
  raycast(e, t) {
    const i = this._instanceInfo,
      r = this._geometryInfo,
      s = this.matrixWorld,
      o = this.geometry;
    (ji.material = this.material),
      (ji.geometry.index = o.index),
      (ji.geometry.attributes = o.attributes),
      ji.geometry.boundingBox === null && (ji.geometry.boundingBox = new er()),
      ji.geometry.boundingSphere === null &&
        (ji.geometry.boundingSphere = new Ni());
    for (let a = 0, l = i.length; a < l; a++) {
      if (!i[a].visible || !i[a].active) continue;
      const u = i[a].geometryIndex,
        c = r[u];
      ji.geometry.setDrawRange(c.start, c.count),
        this.getMatrixAt(a, ji.matrixWorld).premultiply(s),
        this.getBoundingBoxAt(u, ji.geometry.boundingBox),
        this.getBoundingSphereAt(u, ji.geometry.boundingSphere),
        ji.raycast(e, U0);
      for (let d = 0, p = U0.length; d < p; d++) {
        const m = U0[d];
        (m.object = this), (m.batchId = a), t.push(m);
      }
      U0.length = 0;
    }
    (ji.material = null),
      (ji.geometry.index = null),
      (ji.geometry.attributes = {}),
      ji.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere:
          t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    );
  }
  onBeforeRender(e, t, i, r, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const o = r.getIndex(),
      a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
      l = this._instanceInfo,
      u = this._multiDrawStarts,
      c = this._multiDrawCounts,
      d = this._geometryInfo,
      p = this.perObjectFrustumCulled,
      m = this._indirectTexture,
      v = m.image.data;
    p &&
      (Ir.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(
        this.matrixWorld
      ),
      X1.setFromProjectionMatrix(Ir, e.coordinateSystem));
    let _ = 0;
    if (this.sortObjects) {
      Ir.copy(this.matrixWorld).invert(),
        Dd.setFromMatrixPosition(i.matrixWorld).applyMatrix4(Ir),
        m2
          .set(0, 0, -1)
          .transformDirection(i.matrixWorld)
          .transformDirection(Ir);
      for (let A = 0, S = l.length; A < S; A++)
        if (l[A].visible && l[A].active) {
          const w = l[A].geometryIndex;
          this.getMatrixAt(A, Ir),
            this.getBoundingSphereAt(w, pu).applyMatrix4(Ir);
          let C = !1;
          if ((p && (C = !X1.intersectsSphere(pu)), !C)) {
            const b = d[w],
              P = Y9.subVectors(pu.center, Dd).dot(m2);
            J1.push(b.start, b.count, P, A);
          }
        }
      const x = J1.list,
        g = this.customSort;
      g === null ? x.sort(s.transparent ? X9 : W9) : g.call(this, x, i);
      for (let A = 0, S = x.length; A < S; A++) {
        const w = x[A];
        (u[_] = w.start * a), (c[_] = w.count), (v[_] = w.index), _++;
      }
      J1.reset();
    } else
      for (let x = 0, g = l.length; x < g; x++)
        if (l[x].visible && l[x].active) {
          const A = l[x].geometryIndex;
          let S = !1;
          if (
            (p &&
              (this.getMatrixAt(x, Ir),
              this.getBoundingSphereAt(A, pu).applyMatrix4(Ir),
              (S = !X1.intersectsSphere(pu))),
            !S)
          ) {
            const w = d[A];
            (u[_] = w.start * a), (c[_] = w.count), (v[_] = x), _++;
          }
        }
    (m.needsUpdate = !0),
      (this._multiDrawCount = _),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, i, r, s, o) {
    this.onBeforeRender(e, null, r, s, o);
  }
}
class ir extends mi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Ze(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const o_ = new z(),
  a_ = new z(),
  g2 = new _t(),
  Ld = new Fc(),
  k0 = new Ni(),
  j1 = new z(),
  v2 = new z();
class ka extends qt {
  constructor(e = new Lt(), t = new ir()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        o_.fromBufferAttribute(t, r - 1),
          a_.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += o_.distanceTo(a_));
      e.setAttribute("lineDistance", new ht(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      k0.copy(i.boundingSphere),
      k0.applyMatrix4(r),
      (k0.radius += s),
      e.ray.intersectsSphere(k0) === !1)
    )
      return;
    g2.copy(r).invert(), Ld.copy(e.ray).applyMatrix4(g2);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      u = this.isLineSegments ? 2 : 1,
      c = i.index,
      p = i.attributes.position;
    if (c !== null) {
      const m = Math.max(0, o.start),
        v = Math.min(c.count, o.start + o.count);
      for (let _ = m, x = v - 1; _ < x; _ += u) {
        const g = c.getX(_),
          A = c.getX(_ + 1),
          S = z0(this, e, Ld, l, g, A);
        S && t.push(S);
      }
      if (this.isLineLoop) {
        const _ = c.getX(v - 1),
          x = c.getX(m),
          g = z0(this, e, Ld, l, _, x);
        g && t.push(g);
      }
    } else {
      const m = Math.max(0, o.start),
        v = Math.min(p.count, o.start + o.count);
      for (let _ = m, x = v - 1; _ < x; _ += u) {
        const g = z0(this, e, Ld, l, _, _ + 1);
        g && t.push(g);
      }
      if (this.isLineLoop) {
        const _ = z0(this, e, Ld, l, v - 1, m);
        _ && t.push(_);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function z0(n, e, t, i, r, s) {
  const o = n.geometry.attributes.position;
  if (
    (o_.fromBufferAttribute(o, r),
    a_.fromBufferAttribute(o, s),
    t.distanceSqToSegment(o_, a_, j1, v2) > i)
  )
    return;
  j1.applyMatrix4(n.matrixWorld);
  const l = e.ray.origin.distanceTo(j1);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      point: v2.clone().applyMatrix4(n.matrixWorld),
      index: r,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: n,
    };
}
const y2 = new z(),
  _2 = new z();
class So extends ka {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        y2.fromBufferAttribute(t, r),
          _2.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + y2.distanceTo(_2));
      e.setAttribute("lineDistance", new ht(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class AT extends ka {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Jm extends mi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Ze(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const x2 = new _t(),
  qM = new Fc(),
  H0 = new Ni(),
  G0 = new z();
let ST = class extends qt {
  constructor(e = new Lt(), t = new Jm()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      H0.copy(i.boundingSphere),
      H0.applyMatrix4(r),
      (H0.radius += s),
      e.ray.intersectsSphere(H0) === !1)
    )
      return;
    x2.copy(r).invert(), qM.copy(e.ray).applyMatrix4(x2);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      u = i.index,
      d = i.attributes.position;
    if (u !== null) {
      const p = Math.max(0, o.start),
        m = Math.min(u.count, o.start + o.count);
      for (let v = p, _ = m; v < _; v++) {
        const x = u.getX(v);
        G0.fromBufferAttribute(d, x), A2(G0, x, l, r, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start),
        m = Math.min(d.count, o.start + o.count);
      for (let v = p, _ = m; v < _; v++)
        G0.fromBufferAttribute(d, v), A2(G0, v, l, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
};
function A2(n, e, t, i, r, s, o) {
  const a = qM.distanceSqToPoint(n);
  if (a < t) {
    const l = new z();
    qM.closestPointToPoint(n, l), l.applyMatrix4(i);
    const u = r.ray.origin.distanceTo(l);
    if (u < r.near || u > r.far) return;
    s.push({
      distance: u,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o,
    });
  }
}
class Sa extends qt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
class Q9 extends Pn {
  constructor(e, t, i, r, s, o, a, l, u) {
    super(e, t, i, r, s, o, a, l, u),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : Zn),
      (this.magFilter = s !== void 0 ? s : Zn),
      (this.generateMipmaps = !1);
    const c = this;
    function d() {
      (c.needsUpdate = !0), e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class Z9 extends Pn {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = bi),
      (this.minFilter = bi),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class px extends Pn {
  constructor(e, t, i, r, s, o, a, l, u, c, d, p) {
    super(null, o, a, l, u, c, r, s, d, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class q9 extends px {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = fs),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class $9 extends px {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, Oa),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class e5 extends Pn {
  constructor(e, t, i, r, s, o, a, l, u) {
    super(e, t, i, r, s, o, a, l, u),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class MT extends Pn {
  constructor(e, t, i, r, s, o, a, l, u, c = ic) {
    if (c !== ic && c !== Sc)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && c === ic && (i = Ua),
      i === void 0 && c === Sc && (i = Ac),
      super(null, r, s, o, a, l, c, i, u),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : bi),
      (this.minFilter = l !== void 0 ? l : bi),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class Mo {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      r = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? (o = t) : (o = e * i[s - 1]);
    let a = 0,
      l = s - 1,
      u;
    for (; a <= l; )
      if (((r = Math.floor(a + (l - a) / 2)), (u = i[r] - o), u < 0)) a = r + 1;
      else if (u > 0) l = r - 1;
      else {
        l = r;
        break;
      }
    if (((r = l), i[r] === o)) return r / (s - 1);
    const c = i[r],
      p = i[r + 1] - c,
      m = (o - c) / p;
    return (r + m) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r),
      a = this.getPoint(s),
      l = t || (o.isVector2 ? new Ae() : new z());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new z(),
      r = [],
      s = [],
      o = [],
      a = new z(),
      l = new _t();
    for (let m = 0; m <= e; m++) {
      const v = m / e;
      r[m] = this.getTangentAt(v, new z());
    }
    (s[0] = new z()), (o[0] = new z());
    let u = Number.MAX_VALUE;
    const c = Math.abs(r[0].x),
      d = Math.abs(r[0].y),
      p = Math.abs(r[0].z);
    c <= u && ((u = c), i.set(1, 0, 0)),
      d <= u && ((u = d), i.set(0, 1, 0)),
      p <= u && i.set(0, 0, 1),
      a.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], a),
      o[0].crossVectors(r[0], s[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((s[m] = s[m - 1].clone()),
        (o[m] = o[m - 1].clone()),
        a.crossVectors(r[m - 1], r[m]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const v = Math.acos(Rt(r[m - 1].dot(r[m]), -1, 1));
        s[m].applyMatrix4(l.makeRotationAxis(a, v));
      }
      o[m].crossVectors(r[m], s[m]);
    }
    if (t === !0) {
      let m = Math.acos(Rt(s[0].dot(s[e]), -1, 1));
      (m /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
      for (let v = 1; v <= e; v++)
        s[v].applyMatrix4(l.makeRotationAxis(r[v], m * v)),
          o[v].crossVectors(r[v], s[v]);
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class mx extends Mo {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, t = new Ae()) {
    const i = t,
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r));
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a),
      u = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const c = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        p = l - this.aX,
        m = u - this.aY;
      (l = p * c - m * d + this.aX), (u = p * d + m * c + this.aY);
    }
    return i.set(l, u);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class pN extends mx {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function wT() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0;
  function r(s, o, a, l) {
    (n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - l),
      (i = 2 * s - 2 * o + a + l);
  }
  return {
    initCatmullRom: function (s, o, a, l, u) {
      r(o, a, u * (a - s), u * (l - o));
    },
    initNonuniformCatmullRom: function (s, o, a, l, u, c, d) {
      let p = (o - s) / u - (a - s) / (u + c) + (a - o) / c,
        m = (a - o) / c - (l - o) / (c + d) + (l - a) / d;
      (p *= c), (m *= c), r(o, a, p, m);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + i * a;
    },
  };
}
const V0 = new z(),
  Y1 = new wT(),
  K1 = new wT(),
  Q1 = new wT();
class mN extends Mo {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r);
  }
  getPoint(e, t = new z()) {
    const i = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
    let u, c;
    this.closed || a > 0
      ? (u = r[(a - 1) % s])
      : (V0.subVectors(r[0], r[1]).add(r[0]), (u = V0));
    const d = r[a % s],
      p = r[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (c = r[(a + 2) % s])
        : (V0.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (c = V0)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(u.distanceToSquared(d), m),
        _ = Math.pow(d.distanceToSquared(p), m),
        x = Math.pow(p.distanceToSquared(c), m);
      _ < 1e-4 && (_ = 1),
        v < 1e-4 && (v = _),
        x < 1e-4 && (x = _),
        Y1.initNonuniformCatmullRom(u.x, d.x, p.x, c.x, v, _, x),
        K1.initNonuniformCatmullRom(u.y, d.y, p.y, c.y, v, _, x),
        Q1.initNonuniformCatmullRom(u.z, d.z, p.z, c.z, v, _, x);
    } else
      this.curveType === "catmullrom" &&
        (Y1.initCatmullRom(u.x, d.x, p.x, c.x, this.tension),
        K1.initCatmullRom(u.y, d.y, p.y, c.y, this.tension),
        Q1.initCatmullRom(u.z, d.z, p.z, c.z, this.tension));
    return i.set(Y1.calc(l), K1.calc(l), Q1.calc(l)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new z().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function S2(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    o = (r - t) * 0.5,
    a = n * n,
    l = n * a;
  return (
    (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
  );
}
function t5(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function n5(n, e) {
  return 2 * (1 - n) * n * e;
}
function i5(n, e) {
  return n * n * e;
}
function Sp(n, e, t, i) {
  return t5(n, e) + n5(n, t) + i5(n, i);
}
function r5(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function s5(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function o5(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function a5(n, e) {
  return n * n * n * e;
}
function Mp(n, e, t, i, r) {
  return r5(n, e) + s5(n, t) + o5(n, i) + a5(n, r);
}
class ET extends Mo {
  constructor(e = new Ae(), t = new Ae(), i = new Ae(), r = new Ae()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new Ae()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return i.set(Mp(e, r.x, s.x, o.x, a.x), Mp(e, r.y, s.y, o.y, a.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class gN extends Mo {
  constructor(e = new z(), t = new z(), i = new z(), r = new z()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new z()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      i.set(
        Mp(e, r.x, s.x, o.x, a.x),
        Mp(e, r.y, s.y, o.y, a.y),
        Mp(e, r.z, s.z, o.z, a.z)
      ),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class TT extends Mo {
  constructor(e = new Ae(), t = new Ae()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new Ae()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Ae()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class vN extends Mo {
  constructor(e = new z(), t = new z()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new z()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new z()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class CT extends Mo {
  constructor(e = new Ae(), t = new Ae(), i = new Ae()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new Ae()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return i.set(Sp(e, r.x, s.x, o.x), Sp(e, r.y, s.y, o.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class bT extends Mo {
  constructor(e = new z(), t = new z(), i = new z()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new z()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      i.set(Sp(e, r.x, s.x, o.x), Sp(e, r.y, s.y, o.y), Sp(e, r.z, s.z, o.z)), i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class RT extends Mo {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new Ae()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      l = r[o === 0 ? o : o - 1],
      u = r[o],
      c = r[o > r.length - 2 ? r.length - 1 : o + 1],
      d = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(S2(a, l.x, u.x, c.x, d.x), S2(a, l.y, u.y, c.y, d.y)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new Ae().fromArray(r));
    }
    return this;
  }
}
var l_ = Object.freeze({
  __proto__: null,
  ArcCurve: pN,
  CatmullRomCurve3: mN,
  CubicBezierCurve: ET,
  CubicBezierCurve3: gN,
  EllipseCurve: mx,
  LineCurve: TT,
  LineCurve3: vN,
  QuadraticBezierCurve: CT,
  QuadraticBezierCurve3: bT,
  SplineCurve: RT,
});
class yN extends Mo {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new l_[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i,
          a = this.curves[s],
          l = a.getLength(),
          u = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(u, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      (t += this.curves[i].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        l = o.getPoints(a);
      for (let u = 0; u < l.length; u++) {
        const c = l[u];
        (i && i.equals(c)) || (t.push(c), (i = c));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new l_[r.type]().fromJSON(r));
    }
    return this;
  }
}
class dm extends yN {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Ae()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new TT(this.currentPoint.clone(), new Ae(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new CT(this.currentPoint.clone(), new Ae(e, t), new Ae(i, r));
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new ET(
      this.currentPoint.clone(),
      new Ae(e, t),
      new Ae(i, r),
      new Ae(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new RT(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, t + l, i, r, s, o), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, a, l) {
    const u = this.currentPoint.x,
      c = this.currentPoint.y;
    return this.absellipse(e + u, t + c, i, r, s, o, a, l), this;
  }
  absellipse(e, t, i, r, s, o, a, l) {
    const u = new mx(e, t, i, r, s, o, a, l);
    if (this.curves.length > 0) {
      const d = u.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(u);
    const c = u.getPoint(1);
    return this.currentPoint.copy(c), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class jm extends Lt {
  constructor(
    e = [new Ae(0, -0.5), new Ae(0.5, 0), new Ae(0, 0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = Rt(r, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      l = [],
      u = [],
      c = 1 / t,
      d = new z(),
      p = new Ae(),
      m = new z(),
      v = new z(),
      _ = new z();
    let x = 0,
      g = 0;
    for (let A = 0; A <= e.length - 1; A++)
      switch (A) {
        case 0:
          (x = e[A + 1].x - e[A].x),
            (g = e[A + 1].y - e[A].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            _.copy(m),
            m.normalize(),
            l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(_.x, _.y, _.z);
          break;
        default:
          (x = e[A + 1].x - e[A].x),
            (g = e[A + 1].y - e[A].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            v.copy(m),
            (m.x += _.x),
            (m.y += _.y),
            (m.z += _.z),
            m.normalize(),
            l.push(m.x, m.y, m.z),
            _.copy(v);
      }
    for (let A = 0; A <= t; A++) {
      const S = i + A * c * r,
        w = Math.sin(S),
        C = Math.cos(S);
      for (let b = 0; b <= e.length - 1; b++) {
        (d.x = e[b].x * w),
          (d.y = e[b].y),
          (d.z = e[b].x * C),
          o.push(d.x, d.y, d.z),
          (p.x = A / t),
          (p.y = b / (e.length - 1)),
          a.push(p.x, p.y);
        const P = l[3 * b + 0] * w,
          I = l[3 * b + 1],
          R = l[3 * b + 0] * C;
        u.push(P, I, R);
      }
    }
    for (let A = 0; A < t; A++)
      for (let S = 0; S < e.length - 1; S++) {
        const w = S + A * e.length,
          C = w,
          b = w + e.length,
          P = w + e.length + 1,
          I = w + 1;
        s.push(C, b, I), s.push(P, I, b);
      }
    this.setIndex(s),
      this.setAttribute("position", new ht(o, 3)),
      this.setAttribute("uv", new ht(a, 2)),
      this.setAttribute("normal", new ht(u, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new jm(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class gx extends jm {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new dm();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(i), r),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: i,
        radialSegments: r,
      });
  }
  static fromJSON(e) {
    return new gx(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class vx extends Lt {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t));
    const s = [],
      o = [],
      a = [],
      l = [],
      u = new z(),
      c = new Ae();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const m = i + (d / t) * r;
      (u.x = e * Math.cos(m)),
        (u.y = e * Math.sin(m)),
        o.push(u.x, u.y, u.z),
        a.push(0, 0, 1),
        (c.x = (o[p] / e + 1) / 2),
        (c.y = (o[p + 1] / e + 1) / 2),
        l.push(c.x, c.y);
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new ht(o, 3)),
      this.setAttribute("normal", new ht(a, 3)),
      this.setAttribute("uv", new ht(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new vx(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Yh extends Lt {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 32,
    s = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
    const u = this;
    (r = Math.floor(r)), (s = Math.floor(s));
    const c = [],
      d = [],
      p = [],
      m = [];
    let v = 0;
    const _ = [],
      x = i / 2;
    let g = 0;
    A(),
      o === !1 && (e > 0 && S(!0), t > 0 && S(!1)),
      this.setIndex(c),
      this.setAttribute("position", new ht(d, 3)),
      this.setAttribute("normal", new ht(p, 3)),
      this.setAttribute("uv", new ht(m, 2));
    function A() {
      const w = new z(),
        C = new z();
      let b = 0;
      const P = (t - e) / i;
      for (let I = 0; I <= s; I++) {
        const R = [],
          T = I / s,
          D = T * (t - e) + e;
        for (let G = 0; G <= r; G++) {
          const W = G / r,
            q = W * l + a,
            Z = Math.sin(q),
            K = Math.cos(q);
          (C.x = D * Z),
            (C.y = -T * i + x),
            (C.z = D * K),
            d.push(C.x, C.y, C.z),
            w.set(Z, P, K).normalize(),
            p.push(w.x, w.y, w.z),
            m.push(W, 1 - T),
            R.push(v++);
        }
        _.push(R);
      }
      for (let I = 0; I < r; I++)
        for (let R = 0; R < s; R++) {
          const T = _[R][I],
            D = _[R + 1][I],
            G = _[R + 1][I + 1],
            W = _[R][I + 1];
          (e > 0 || R !== 0) && (c.push(T, D, W), (b += 3)),
            (t > 0 || R !== s - 1) && (c.push(D, G, W), (b += 3));
        }
      u.addGroup(g, b, 0), (g += b);
    }
    function S(w) {
      const C = v,
        b = new Ae(),
        P = new z();
      let I = 0;
      const R = w === !0 ? e : t,
        T = w === !0 ? 1 : -1;
      for (let G = 1; G <= r; G++)
        d.push(0, x * T, 0), p.push(0, T, 0), m.push(0.5, 0.5), v++;
      const D = v;
      for (let G = 0; G <= r; G++) {
        const q = (G / r) * l + a,
          Z = Math.cos(q),
          K = Math.sin(q);
        (P.x = R * K),
          (P.y = x * T),
          (P.z = R * Z),
          d.push(P.x, P.y, P.z),
          p.push(0, T, 0),
          (b.x = Z * 0.5 + 0.5),
          (b.y = K * 0.5 * T + 0.5),
          m.push(b.x, b.y),
          v++;
      }
      for (let G = 0; G < r; G++) {
        const W = C + G,
          q = D + G;
        w === !0 ? c.push(q, q + 1, W) : c.push(q + 1, q, W), (I += 3);
      }
      u.addGroup(g, I, w === !0 ? 1 : 2), (g += I);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yh(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class yx extends Yh {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new yx(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Zl extends Lt {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
    const s = [],
      o = [];
    a(r),
      u(i),
      c(),
      this.setAttribute("position", new ht(s, 3)),
      this.setAttribute("normal", new ht(s.slice(), 3)),
      this.setAttribute("uv", new ht(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(A) {
      const S = new z(),
        w = new z(),
        C = new z();
      for (let b = 0; b < t.length; b += 3)
        m(t[b + 0], S), m(t[b + 1], w), m(t[b + 2], C), l(S, w, C, A);
    }
    function l(A, S, w, C) {
      const b = C + 1,
        P = [];
      for (let I = 0; I <= b; I++) {
        P[I] = [];
        const R = A.clone().lerp(w, I / b),
          T = S.clone().lerp(w, I / b),
          D = b - I;
        for (let G = 0; G <= D; G++)
          G === 0 && I === b
            ? (P[I][G] = R)
            : (P[I][G] = R.clone().lerp(T, G / D));
      }
      for (let I = 0; I < b; I++)
        for (let R = 0; R < 2 * (b - I) - 1; R++) {
          const T = Math.floor(R / 2);
          R % 2 === 0
            ? (p(P[I][T + 1]), p(P[I + 1][T]), p(P[I][T]))
            : (p(P[I][T + 1]), p(P[I + 1][T + 1]), p(P[I + 1][T]));
        }
    }
    function u(A) {
      const S = new z();
      for (let w = 0; w < s.length; w += 3)
        (S.x = s[w + 0]),
          (S.y = s[w + 1]),
          (S.z = s[w + 2]),
          S.normalize().multiplyScalar(A),
          (s[w + 0] = S.x),
          (s[w + 1] = S.y),
          (s[w + 2] = S.z);
    }
    function c() {
      const A = new z();
      for (let S = 0; S < s.length; S += 3) {
        (A.x = s[S + 0]), (A.y = s[S + 1]), (A.z = s[S + 2]);
        const w = x(A) / 2 / Math.PI + 0.5,
          C = g(A) / Math.PI + 0.5;
        o.push(w, 1 - C);
      }
      v(), d();
    }
    function d() {
      for (let A = 0; A < o.length; A += 6) {
        const S = o[A + 0],
          w = o[A + 2],
          C = o[A + 4],
          b = Math.max(S, w, C),
          P = Math.min(S, w, C);
        b > 0.9 &&
          P < 0.1 &&
          (S < 0.2 && (o[A + 0] += 1),
          w < 0.2 && (o[A + 2] += 1),
          C < 0.2 && (o[A + 4] += 1));
      }
    }
    function p(A) {
      s.push(A.x, A.y, A.z);
    }
    function m(A, S) {
      const w = A * 3;
      (S.x = e[w + 0]), (S.y = e[w + 1]), (S.z = e[w + 2]);
    }
    function v() {
      const A = new z(),
        S = new z(),
        w = new z(),
        C = new z(),
        b = new Ae(),
        P = new Ae(),
        I = new Ae();
      for (let R = 0, T = 0; R < s.length; R += 9, T += 6) {
        A.set(s[R + 0], s[R + 1], s[R + 2]),
          S.set(s[R + 3], s[R + 4], s[R + 5]),
          w.set(s[R + 6], s[R + 7], s[R + 8]),
          b.set(o[T + 0], o[T + 1]),
          P.set(o[T + 2], o[T + 3]),
          I.set(o[T + 4], o[T + 5]),
          C.copy(A).add(S).add(w).divideScalar(3);
        const D = x(C);
        _(b, T + 0, A, D), _(P, T + 2, S, D), _(I, T + 4, w, D);
      }
    }
    function _(A, S, w, C) {
      C < 0 && A.x === 1 && (o[S] = A.x - 1),
        w.x === 0 && w.z === 0 && (o[S] = C / 2 / Math.PI + 0.5);
    }
    function x(A) {
      return Math.atan2(A.z, -A.x);
    }
    function g(A) {
      return Math.atan2(-A.y, Math.sqrt(A.x * A.x + A.z * A.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Zl(e.vertices, e.indices, e.radius, e.details);
  }
}
class _x extends Zl {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new _x(e.radius, e.detail);
  }
}
const W0 = new z(),
  X0 = new z(),
  Z1 = new z(),
  J0 = new Or();
class _N extends Lt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(sc * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        l = o ? o.count : a.count,
        u = [0, 0, 0],
        c = ["a", "b", "c"],
        d = new Array(3),
        p = {},
        m = [];
      for (let v = 0; v < l; v += 3) {
        o
          ? ((u[0] = o.getX(v)), (u[1] = o.getX(v + 1)), (u[2] = o.getX(v + 2)))
          : ((u[0] = v), (u[1] = v + 1), (u[2] = v + 2));
        const { a: _, b: x, c: g } = J0;
        if (
          (_.fromBufferAttribute(a, u[0]),
          x.fromBufferAttribute(a, u[1]),
          g.fromBufferAttribute(a, u[2]),
          J0.getNormal(Z1),
          (d[0] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(
            _.z * r
          )}`),
          (d[1] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(
            x.z * r
          )}`),
          (d[2] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(
            g.z * r
          )}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let A = 0; A < 3; A++) {
            const S = (A + 1) % 3,
              w = d[A],
              C = d[S],
              b = J0[c[A]],
              P = J0[c[S]],
              I = `${w}_${C}`,
              R = `${C}_${w}`;
            R in p && p[R]
              ? (Z1.dot(p[R].normal) <= s &&
                  (m.push(b.x, b.y, b.z), m.push(P.x, P.y, P.z)),
                (p[R] = null))
              : I in p ||
                (p[I] = { index0: u[A], index1: u[S], normal: Z1.clone() });
          }
      }
      for (const v in p)
        if (p[v]) {
          const { index0: _, index1: x } = p[v];
          W0.fromBufferAttribute(a, _),
            X0.fromBufferAttribute(a, x),
            m.push(W0.x, W0.y, W0.z),
            m.push(X0.x, X0.y, X0.z);
        }
      this.setAttribute("position", new ht(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class ac extends dm {
  constructor(e) {
    super(e), (this.uuid = ms()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new dm().fromJSON(r));
    }
    return this;
  }
}
const l5 = {
  triangulate: function (n, e, t = 2) {
    const i = e && e.length,
      r = i ? e[0] * t : n.length;
    let s = xN(n, 0, r, t, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, l, u, c, d, p, m;
    if ((i && (s = d5(n, e, s, t)), n.length > 80 * t)) {
      (a = u = n[0]), (l = c = n[1]);
      for (let v = t; v < r; v += t)
        (d = n[v]),
          (p = n[v + 1]),
          d < a && (a = d),
          p < l && (l = p),
          d > u && (u = d),
          p > c && (c = p);
      (m = Math.max(u - a, c - l)), (m = m !== 0 ? 32767 / m : 0);
    }
    return pm(s, o, t, a, l, m, 0), o;
  },
};
function xN(n, e, t, i, r) {
  let s, o;
  if (r === w5(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = M2(s, n[s], n[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = M2(s, n[s], n[s + 1], o);
  return o && xx(o, o.next) && (gm(o), (o = o.next)), o;
}
function Ec(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    i;
  do
    if (
      ((i = !1), !t.steiner && (xx(t, t.next) || Fn(t.prev, t, t.next) === 0))
    ) {
      if ((gm(t), (t = e = t.prev), t === t.next)) break;
      i = !0;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function pm(n, e, t, i, r, s, o) {
  if (!n) return;
  !o && s && y5(n, i, r, s);
  let a = n,
    l,
    u;
  for (; n.prev !== n.next; ) {
    if (((l = n.prev), (u = n.next), s ? c5(n, i, r, s) : u5(n))) {
      e.push((l.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((u.i / t) | 0),
        gm(n),
        (n = u.next),
        (a = u.next);
      continue;
    }
    if (((n = u), n === a)) {
      o
        ? o === 1
          ? ((n = f5(Ec(n), e, t)), pm(n, e, t, i, r, s, 2))
          : o === 2 && h5(n, e, t, i, r, s)
        : pm(Ec(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function u5(n) {
  const e = n.prev,
    t = n,
    i = n.next;
  if (Fn(e, t, i) >= 0) return !1;
  const r = e.x,
    s = t.x,
    o = i.x,
    a = e.y,
    l = t.y,
    u = i.y,
    c = r < s ? (r < o ? r : o) : s < o ? s : o,
    d = a < l ? (a < u ? a : u) : l < u ? l : u,
    p = r > s ? (r > o ? r : o) : s > o ? s : o,
    m = a > l ? (a > u ? a : u) : l > u ? l : u;
  let v = i.next;
  for (; v !== e; ) {
    if (
      v.x >= c &&
      v.x <= p &&
      v.y >= d &&
      v.y <= m &&
      Xf(r, a, s, l, o, u, v.x, v.y) &&
      Fn(v.prev, v, v.next) >= 0
    )
      return !1;
    v = v.next;
  }
  return !0;
}
function c5(n, e, t, i) {
  const r = n.prev,
    s = n,
    o = n.next;
  if (Fn(r, s, o) >= 0) return !1;
  const a = r.x,
    l = s.x,
    u = o.x,
    c = r.y,
    d = s.y,
    p = o.y,
    m = a < l ? (a < u ? a : u) : l < u ? l : u,
    v = c < d ? (c < p ? c : p) : d < p ? d : p,
    _ = a > l ? (a > u ? a : u) : l > u ? l : u,
    x = c > d ? (c > p ? c : p) : d > p ? d : p,
    g = $M(m, v, e, t, i),
    A = $M(_, x, e, t, i);
  let S = n.prevZ,
    w = n.nextZ;
  for (; S && S.z >= g && w && w.z <= A; ) {
    if (
      (S.x >= m &&
        S.x <= _ &&
        S.y >= v &&
        S.y <= x &&
        S !== r &&
        S !== o &&
        Xf(a, c, l, d, u, p, S.x, S.y) &&
        Fn(S.prev, S, S.next) >= 0) ||
      ((S = S.prevZ),
      w.x >= m &&
        w.x <= _ &&
        w.y >= v &&
        w.y <= x &&
        w !== r &&
        w !== o &&
        Xf(a, c, l, d, u, p, w.x, w.y) &&
        Fn(w.prev, w, w.next) >= 0)
    )
      return !1;
    w = w.nextZ;
  }
  for (; S && S.z >= g; ) {
    if (
      S.x >= m &&
      S.x <= _ &&
      S.y >= v &&
      S.y <= x &&
      S !== r &&
      S !== o &&
      Xf(a, c, l, d, u, p, S.x, S.y) &&
      Fn(S.prev, S, S.next) >= 0
    )
      return !1;
    S = S.prevZ;
  }
  for (; w && w.z <= A; ) {
    if (
      w.x >= m &&
      w.x <= _ &&
      w.y >= v &&
      w.y <= x &&
      w !== r &&
      w !== o &&
      Xf(a, c, l, d, u, p, w.x, w.y) &&
      Fn(w.prev, w, w.next) >= 0
    )
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function f5(n, e, t) {
  let i = n;
  do {
    const r = i.prev,
      s = i.next.next;
    !xx(r, s) &&
      AN(r, i, i.next, s) &&
      mm(r, s) &&
      mm(s, r) &&
      (e.push((r.i / t) | 0),
      e.push((i.i / t) | 0),
      e.push((s.i / t) | 0),
      gm(i),
      gm(i.next),
      (i = n = s)),
      (i = i.next);
  } while (i !== n);
  return Ec(i);
}
function h5(n, e, t, i, r, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && A5(o, a)) {
        let l = SN(o, a);
        (o = Ec(o, o.next)),
          (l = Ec(l, l.next)),
          pm(o, e, t, i, r, s, 0),
          pm(l, e, t, i, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function d5(n, e, t, i) {
  const r = [];
  let s, o, a, l, u;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (l = s < o - 1 ? e[s + 1] * i : n.length),
      (u = xN(n, a, l, i, !1)),
      u === u.next && (u.steiner = !0),
      r.push(x5(u));
  for (r.sort(p5), s = 0; s < r.length; s++) t = m5(r[s], t);
  return t;
}
function p5(n, e) {
  return n.x - e.x;
}
function m5(n, e) {
  const t = g5(n, e);
  if (!t) return e;
  const i = SN(t, n);
  return Ec(i, i.next), Ec(t, t.next);
}
function g5(n, e) {
  let t = e,
    i = -1 / 0,
    r;
  const s = n.x,
    o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        p <= s &&
        p > i &&
        ((i = p), (r = t.x < t.next.x ? t : t.next), p === s)
      )
        return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const a = r,
    l = r.x,
    u = r.y;
  let c = 1 / 0,
    d;
  t = r;
  do
    s >= t.x &&
      t.x >= l &&
      s !== t.x &&
      Xf(o < u ? s : i, o, l, u, o < u ? i : s, o, t.x, t.y) &&
      ((d = Math.abs(o - t.y) / (s - t.x)),
      mm(t, n) &&
        (d < c || (d === c && (t.x > r.x || (t.x === r.x && v5(r, t))))) &&
        ((r = t), (c = d))),
      (t = t.next);
  while (t !== a);
  return r;
}
function v5(n, e) {
  return Fn(n.prev, n, e.prev) < 0 && Fn(e.next, n, n.next) < 0;
}
function y5(n, e, t, i) {
  let r = n;
  do
    r.z === 0 && (r.z = $M(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next);
  while (r !== n);
  (r.prevZ.nextZ = null), (r.prevZ = null), _5(r);
}
function _5(n) {
  let e,
    t,
    i,
    r,
    s,
    o,
    a,
    l,
    u = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < u && (a++, (i = i.nextZ), !!i); e++);
      for (l = u; a > 0 || (l > 0 && i); )
        a !== 0 && (l === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), l--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r);
      t = i;
    }
    (s.nextZ = null), (u *= 2);
  } while (o > 1);
  return n;
}
function $M(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function x5(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function Xf(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (i - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (r - o) * (i - a)
  );
}
function A5(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !S5(n, e) &&
    ((mm(n, e) &&
      mm(e, n) &&
      M5(n, e) &&
      (Fn(n.prev, n, e.prev) || Fn(n, e.prev, e))) ||
      (xx(n, e) && Fn(n.prev, n, n.next) > 0 && Fn(e.prev, e, e.next) > 0))
  );
}
function Fn(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function xx(n, e) {
  return n.x === e.x && n.y === e.y;
}
function AN(n, e, t, i) {
  const r = Y0(Fn(n, e, t)),
    s = Y0(Fn(n, e, i)),
    o = Y0(Fn(t, i, n)),
    a = Y0(Fn(t, i, e));
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && j0(n, t, e)) ||
    (s === 0 && j0(n, i, e)) ||
    (o === 0 && j0(t, n, i)) ||
    (a === 0 && j0(t, e, i))
  );
}
function j0(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function Y0(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function S5(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      AN(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function mm(n, e) {
  return Fn(n.prev, n, n.next) < 0
    ? Fn(n, e, n.next) >= 0 && Fn(n, n.prev, e) >= 0
    : Fn(n, e, n.prev) < 0 || Fn(n, n.next, e) < 0;
}
function M5(n, e) {
  let t = n,
    i = !1;
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next);
  while (t !== n);
  return i;
}
function SN(n, e) {
  const t = new ew(n.i, n.x, n.y),
    i = new ew(e.i, e.x, e.y),
    r = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function M2(n, e, t, i) {
  const r = new ew(n, e, t);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function gm(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function ew(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function w5(n, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i)
    (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
  return r;
}
class Xo {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Xo.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = [];
    w2(e), E2(i, e);
    let o = e.length;
    t.forEach(w2);
    for (let l = 0; l < t.length; l++)
      r.push(o), (o += t[l].length), E2(i, t[l]);
    const a = l5.triangulate(i, r);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function w2(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function E2(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class Ax extends Lt {
  constructor(
    e = new ac([
      new Ae(0.5, 0.5),
      new Ae(-0.5, 0.5),
      new Ae(-0.5, -0.5),
      new Ae(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const i = this,
      r = [],
      s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a];
      o(u);
    }
    this.setAttribute("position", new ht(r, 3)),
      this.setAttribute("uv", new ht(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const l = [],
        u = t.curveSegments !== void 0 ? t.curveSegments : 12,
        c = t.steps !== void 0 ? t.steps : 1,
        d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        m = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        v = t.bevelSize !== void 0 ? t.bevelSize : m - 0.1,
        _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const g = t.extrudePath,
        A = t.UVGenerator !== void 0 ? t.UVGenerator : E5;
      let S,
        w = !1,
        C,
        b,
        P,
        I;
      g &&
        ((S = g.getSpacedPoints(c)),
        (w = !0),
        (p = !1),
        (C = g.computeFrenetFrames(c, !1)),
        (b = new z()),
        (P = new z()),
        (I = new z())),
        p || ((x = 0), (m = 0), (v = 0), (_ = 0));
      const R = a.extractPoints(u);
      let T = R.shape;
      const D = R.holes;
      if (!Xo.isClockWise(T)) {
        T = T.reverse();
        for (let de = 0, ce = D.length; de < ce; de++) {
          const k = D[de];
          Xo.isClockWise(k) && (D[de] = k.reverse());
        }
      }
      const W = Xo.triangulateShape(T, D),
        q = T;
      for (let de = 0, ce = D.length; de < ce; de++) {
        const k = D[de];
        T = T.concat(k);
      }
      function Z(de, ce, k) {
        return (
          ce || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          de.clone().addScaledVector(ce, k)
        );
      }
      const K = T.length,
        te = W.length;
      function O(de, ce, k) {
        let Ve, we, J;
        const Te = de.x - ce.x,
          st = de.y - ce.y,
          Le = k.x - de.x,
          U = k.y - de.y,
          L = Te * Te + st * st,
          ie = Te * U - st * Le;
        if (Math.abs(ie) > Number.EPSILON) {
          const fe = Math.sqrt(L),
            ye = Math.sqrt(Le * Le + U * U),
            me = ce.x - st / fe,
            Pe = ce.y + Te / fe,
            Ie = k.x - U / ye,
            ze = k.y + Le / ye,
            Mt = ((Ie - me) * U - (ze - Pe) * Le) / (Te * U - st * Le);
          (Ve = me + Te * Mt - de.x), (we = Pe + st * Mt - de.y);
          const Re = Ve * Ve + we * we;
          if (Re <= 2) return new Ae(Ve, we);
          J = Math.sqrt(Re / 2);
        } else {
          let fe = !1;
          Te > Number.EPSILON
            ? Le > Number.EPSILON && (fe = !0)
            : Te < -Number.EPSILON
            ? Le < -Number.EPSILON && (fe = !0)
            : Math.sign(st) === Math.sign(U) && (fe = !0),
            fe
              ? ((Ve = -st), (we = Te), (J = Math.sqrt(L)))
              : ((Ve = Te), (we = st), (J = Math.sqrt(L / 2)));
        }
        return new Ae(Ve / J, we / J);
      }
      const Y = [];
      for (
        let de = 0, ce = q.length, k = ce - 1, Ve = de + 1;
        de < ce;
        de++, k++, Ve++
      )
        k === ce && (k = 0),
          Ve === ce && (Ve = 0),
          (Y[de] = O(q[de], q[k], q[Ve]));
      const F = [];
      let se,
        Me = Y.concat();
      for (let de = 0, ce = D.length; de < ce; de++) {
        const k = D[de];
        se = [];
        for (
          let Ve = 0, we = k.length, J = we - 1, Te = Ve + 1;
          Ve < we;
          Ve++, J++, Te++
        )
          J === we && (J = 0),
            Te === we && (Te = 0),
            (se[Ve] = O(k[Ve], k[J], k[Te]));
        F.push(se), (Me = Me.concat(se));
      }
      for (let de = 0; de < x; de++) {
        const ce = de / x,
          k = m * Math.cos((ce * Math.PI) / 2),
          Ve = v * Math.sin((ce * Math.PI) / 2) + _;
        for (let we = 0, J = q.length; we < J; we++) {
          const Te = Z(q[we], Y[we], Ve);
          Se(Te.x, Te.y, -k);
        }
        for (let we = 0, J = D.length; we < J; we++) {
          const Te = D[we];
          se = F[we];
          for (let st = 0, Le = Te.length; st < Le; st++) {
            const U = Z(Te[st], se[st], Ve);
            Se(U.x, U.y, -k);
          }
        }
      }
      const De = v + _;
      for (let de = 0; de < K; de++) {
        const ce = p ? Z(T[de], Me[de], De) : T[de];
        w
          ? (P.copy(C.normals[0]).multiplyScalar(ce.x),
            b.copy(C.binormals[0]).multiplyScalar(ce.y),
            I.copy(S[0]).add(P).add(b),
            Se(I.x, I.y, I.z))
          : Se(ce.x, ce.y, 0);
      }
      for (let de = 1; de <= c; de++)
        for (let ce = 0; ce < K; ce++) {
          const k = p ? Z(T[ce], Me[ce], De) : T[ce];
          w
            ? (P.copy(C.normals[de]).multiplyScalar(k.x),
              b.copy(C.binormals[de]).multiplyScalar(k.y),
              I.copy(S[de]).add(P).add(b),
              Se(I.x, I.y, I.z))
            : Se(k.x, k.y, (d / c) * de);
        }
      for (let de = x - 1; de >= 0; de--) {
        const ce = de / x,
          k = m * Math.cos((ce * Math.PI) / 2),
          Ve = v * Math.sin((ce * Math.PI) / 2) + _;
        for (let we = 0, J = q.length; we < J; we++) {
          const Te = Z(q[we], Y[we], Ve);
          Se(Te.x, Te.y, d + k);
        }
        for (let we = 0, J = D.length; we < J; we++) {
          const Te = D[we];
          se = F[we];
          for (let st = 0, Le = Te.length; st < Le; st++) {
            const U = Z(Te[st], se[st], Ve);
            w ? Se(U.x, U.y + S[c - 1].y, S[c - 1].x + k) : Se(U.x, U.y, d + k);
          }
        }
      }
      re(), xe();
      function re() {
        const de = r.length / 3;
        if (p) {
          let ce = 0,
            k = K * ce;
          for (let Ve = 0; Ve < te; Ve++) {
            const we = W[Ve];
            Xe(we[2] + k, we[1] + k, we[0] + k);
          }
          (ce = c + x * 2), (k = K * ce);
          for (let Ve = 0; Ve < te; Ve++) {
            const we = W[Ve];
            Xe(we[0] + k, we[1] + k, we[2] + k);
          }
        } else {
          for (let ce = 0; ce < te; ce++) {
            const k = W[ce];
            Xe(k[2], k[1], k[0]);
          }
          for (let ce = 0; ce < te; ce++) {
            const k = W[ce];
            Xe(k[0] + K * c, k[1] + K * c, k[2] + K * c);
          }
        }
        i.addGroup(de, r.length / 3 - de, 0);
      }
      function xe() {
        const de = r.length / 3;
        let ce = 0;
        Ce(q, ce), (ce += q.length);
        for (let k = 0, Ve = D.length; k < Ve; k++) {
          const we = D[k];
          Ce(we, ce), (ce += we.length);
        }
        i.addGroup(de, r.length / 3 - de, 1);
      }
      function Ce(de, ce) {
        let k = de.length;
        for (; --k >= 0; ) {
          const Ve = k;
          let we = k - 1;
          we < 0 && (we = de.length - 1);
          for (let J = 0, Te = c + x * 2; J < Te; J++) {
            const st = K * J,
              Le = K * (J + 1),
              U = ce + Ve + st,
              L = ce + we + st,
              ie = ce + we + Le,
              fe = ce + Ve + Le;
            et(U, L, ie, fe);
          }
        }
      }
      function Se(de, ce, k) {
        l.push(de), l.push(ce), l.push(k);
      }
      function Xe(de, ce, k) {
        Ye(de), Ye(ce), Ye(k);
        const Ve = r.length / 3,
          we = A.generateTopUV(i, r, Ve - 3, Ve - 2, Ve - 1);
        Fe(we[0]), Fe(we[1]), Fe(we[2]);
      }
      function et(de, ce, k, Ve) {
        Ye(de), Ye(ce), Ye(Ve), Ye(ce), Ye(k), Ye(Ve);
        const we = r.length / 3,
          J = A.generateSideWallUV(i, r, we - 6, we - 3, we - 2, we - 1);
        Fe(J[0]), Fe(J[1]), Fe(J[3]), Fe(J[1]), Fe(J[2]), Fe(J[3]);
      }
      function Ye(de) {
        r.push(l[de * 3 + 0]), r.push(l[de * 3 + 1]), r.push(l[de * 3 + 2]);
      }
      function Fe(de) {
        s.push(de.x), s.push(de.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options;
    return T5(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return (
      r !== void 0 && (e.options.extrudePath = new l_[r.type]().fromJSON(r)),
      new Ax(i, e.options)
    );
  }
}
const E5 = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[i * 3],
      l = e[i * 3 + 1],
      u = e[r * 3],
      c = e[r * 3 + 1];
    return [new Ae(s, o), new Ae(a, l), new Ae(u, c)];
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[t * 3 + 2],
      u = e[i * 3],
      c = e[i * 3 + 1],
      d = e[i * 3 + 2],
      p = e[r * 3],
      m = e[r * 3 + 1],
      v = e[r * 3 + 2],
      _ = e[s * 3],
      x = e[s * 3 + 1],
      g = e[s * 3 + 2];
    return Math.abs(a - c) < Math.abs(o - u)
      ? [new Ae(o, 1 - l), new Ae(u, 1 - d), new Ae(p, 1 - v), new Ae(_, 1 - g)]
      : [
          new Ae(a, 1 - l),
          new Ae(c, 1 - d),
          new Ae(m, 1 - v),
          new Ae(x, 1 - g),
        ];
  },
};
function T5(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Sx extends Zl {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Sx(e.radius, e.detail);
  }
}
class Ym extends Zl {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(i, r, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Ym(e.radius, e.detail);
  }
}
class Kh extends Lt {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      l = Math.floor(r),
      u = a + 1,
      c = l + 1,
      d = e / a,
      p = t / l,
      m = [],
      v = [],
      _ = [],
      x = [];
    for (let g = 0; g < c; g++) {
      const A = g * p - o;
      for (let S = 0; S < u; S++) {
        const w = S * d - s;
        v.push(w, -A, 0), _.push(0, 0, 1), x.push(S / a), x.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let A = 0; A < a; A++) {
        const S = A + u * g,
          w = A + u * (g + 1),
          C = A + 1 + u * (g + 1),
          b = A + 1 + u * g;
        m.push(S, w, b), m.push(w, C, b);
      }
    this.setIndex(m),
      this.setAttribute("position", new ht(v, 3)),
      this.setAttribute("normal", new ht(_, 3)),
      this.setAttribute("uv", new ht(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Kh(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Mx extends Lt {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r));
    const a = [],
      l = [],
      u = [],
      c = [];
    let d = e;
    const p = (t - e) / r,
      m = new z(),
      v = new Ae();
    for (let _ = 0; _ <= r; _++) {
      for (let x = 0; x <= i; x++) {
        const g = s + (x / i) * o;
        (m.x = d * Math.cos(g)),
          (m.y = d * Math.sin(g)),
          l.push(m.x, m.y, m.z),
          u.push(0, 0, 1),
          (v.x = (m.x / t + 1) / 2),
          (v.y = (m.y / t + 1) / 2),
          c.push(v.x, v.y);
      }
      d += p;
    }
    for (let _ = 0; _ < r; _++) {
      const x = _ * (i + 1);
      for (let g = 0; g < i; g++) {
        const A = g + x,
          S = A,
          w = A + i + 1,
          C = A + i + 2,
          b = A + 1;
        a.push(S, w, b), a.push(w, C, b);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new ht(l, 3)),
      this.setAttribute("normal", new ht(u, 3)),
      this.setAttribute("uv", new ht(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Mx(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class wx extends Lt {
  constructor(
    e = new ac([new Ae(0, 0.5), new Ae(-0.5, -0.5), new Ae(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const i = [],
      r = [],
      s = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) u(e);
    else
      for (let c = 0; c < e.length; c++)
        u(e[c]), this.addGroup(a, l, c), (a += l), (l = 0);
    this.setIndex(i),
      this.setAttribute("position", new ht(r, 3)),
      this.setAttribute("normal", new ht(s, 3)),
      this.setAttribute("uv", new ht(o, 2));
    function u(c) {
      const d = r.length / 3,
        p = c.extractPoints(t);
      let m = p.shape;
      const v = p.holes;
      Xo.isClockWise(m) === !1 && (m = m.reverse());
      for (let x = 0, g = v.length; x < g; x++) {
        const A = v[x];
        Xo.isClockWise(A) === !0 && (v[x] = A.reverse());
      }
      const _ = Xo.triangulateShape(m, v);
      for (let x = 0, g = v.length; x < g; x++) {
        const A = v[x];
        m = m.concat(A);
      }
      for (let x = 0, g = m.length; x < g; x++) {
        const A = m[x];
        r.push(A.x, A.y, 0), s.push(0, 0, 1), o.push(A.x, A.y);
      }
      for (let x = 0, g = _.length; x < g; x++) {
        const A = _[x],
          S = A[0] + d,
          w = A[1] + d,
          C = A[2] + d;
        i.push(S, w, C), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return C5(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new wx(i, e.curveSegments);
  }
}
function C5(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class Km extends Lt {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)));
    const l = Math.min(o + a, Math.PI);
    let u = 0;
    const c = [],
      d = new z(),
      p = new z(),
      m = [],
      v = [],
      _ = [],
      x = [];
    for (let g = 0; g <= i; g++) {
      const A = [],
        S = g / i;
      let w = 0;
      g === 0 && o === 0
        ? (w = 0.5 / t)
        : g === i && l === Math.PI && (w = -0.5 / t);
      for (let C = 0; C <= t; C++) {
        const b = C / t;
        (d.x = -e * Math.cos(r + b * s) * Math.sin(o + S * a)),
          (d.y = e * Math.cos(o + S * a)),
          (d.z = e * Math.sin(r + b * s) * Math.sin(o + S * a)),
          v.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          _.push(p.x, p.y, p.z),
          x.push(b + w, 1 - S),
          A.push(u++);
      }
      c.push(A);
    }
    for (let g = 0; g < i; g++)
      for (let A = 0; A < t; A++) {
        const S = c[g][A + 1],
          w = c[g][A],
          C = c[g + 1][A],
          b = c[g + 1][A + 1];
        (g !== 0 || o > 0) && m.push(S, w, b),
          (g !== i - 1 || l < Math.PI) && m.push(w, C, b);
      }
    this.setIndex(m),
      this.setAttribute("position", new ht(v, 3)),
      this.setAttribute("normal", new ht(_, 3)),
      this.setAttribute("uv", new ht(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Km(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Ex extends Zl {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(i, r, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Ex(e.radius, e.detail);
  }
}
class Tx extends Lt {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const o = [],
      a = [],
      l = [],
      u = [],
      c = new z(),
      d = new z(),
      p = new z();
    for (let m = 0; m <= i; m++)
      for (let v = 0; v <= r; v++) {
        const _ = (v / r) * s,
          x = (m / i) * Math.PI * 2;
        (d.x = (e + t * Math.cos(x)) * Math.cos(_)),
          (d.y = (e + t * Math.cos(x)) * Math.sin(_)),
          (d.z = t * Math.sin(x)),
          a.push(d.x, d.y, d.z),
          (c.x = e * Math.cos(_)),
          (c.y = e * Math.sin(_)),
          p.subVectors(d, c).normalize(),
          l.push(p.x, p.y, p.z),
          u.push(v / r),
          u.push(m / i);
      }
    for (let m = 1; m <= i; m++)
      for (let v = 1; v <= r; v++) {
        const _ = (r + 1) * m + v - 1,
          x = (r + 1) * (m - 1) + v - 1,
          g = (r + 1) * (m - 1) + v,
          A = (r + 1) * m + v;
        o.push(_, x, A), o.push(x, g, A);
      }
    this.setIndex(o),
      this.setAttribute("position", new ht(a, 3)),
      this.setAttribute("normal", new ht(l, 3)),
      this.setAttribute("uv", new ht(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Tx(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Cx extends Lt {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const a = [],
      l = [],
      u = [],
      c = [],
      d = new z(),
      p = new z(),
      m = new z(),
      v = new z(),
      _ = new z(),
      x = new z(),
      g = new z();
    for (let S = 0; S <= i; ++S) {
      const w = (S / i) * s * Math.PI * 2;
      A(w, s, o, e, m),
        A(w + 0.01, s, o, e, v),
        x.subVectors(v, m),
        g.addVectors(v, m),
        _.crossVectors(x, g),
        g.crossVectors(_, x),
        _.normalize(),
        g.normalize();
      for (let C = 0; C <= r; ++C) {
        const b = (C / r) * Math.PI * 2,
          P = -t * Math.cos(b),
          I = t * Math.sin(b);
        (d.x = m.x + (P * g.x + I * _.x)),
          (d.y = m.y + (P * g.y + I * _.y)),
          (d.z = m.z + (P * g.z + I * _.z)),
          l.push(d.x, d.y, d.z),
          p.subVectors(d, m).normalize(),
          u.push(p.x, p.y, p.z),
          c.push(S / i),
          c.push(C / r);
      }
    }
    for (let S = 1; S <= i; S++)
      for (let w = 1; w <= r; w++) {
        const C = (r + 1) * (S - 1) + (w - 1),
          b = (r + 1) * S + (w - 1),
          P = (r + 1) * S + w,
          I = (r + 1) * (S - 1) + w;
        a.push(C, b, I), a.push(b, P, I);
      }
    this.setIndex(a),
      this.setAttribute("position", new ht(l, 3)),
      this.setAttribute("normal", new ht(u, 3)),
      this.setAttribute("uv", new ht(c, 2));
    function A(S, w, C, b, P) {
      const I = Math.cos(S),
        R = Math.sin(S),
        T = (C / w) * S,
        D = Math.cos(T);
      (P.x = b * (2 + D) * 0.5 * I),
        (P.y = b * (2 + D) * R * 0.5),
        (P.z = b * Math.sin(T) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Cx(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class bx extends Lt {
  constructor(
    e = new bT(new z(-1, -1, 0), new z(-1, 1, 0), new z(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      });
    const o = e.computeFrenetFrames(t, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new z(),
      l = new z(),
      u = new Ae();
    let c = new z();
    const d = [],
      p = [],
      m = [],
      v = [];
    _(),
      this.setIndex(v),
      this.setAttribute("position", new ht(d, 3)),
      this.setAttribute("normal", new ht(p, 3)),
      this.setAttribute("uv", new ht(m, 2));
    function _() {
      for (let S = 0; S < t; S++) x(S);
      x(s === !1 ? t : 0), A(), g();
    }
    function x(S) {
      c = e.getPointAt(S / t, c);
      const w = o.normals[S],
        C = o.binormals[S];
      for (let b = 0; b <= r; b++) {
        const P = (b / r) * Math.PI * 2,
          I = Math.sin(P),
          R = -Math.cos(P);
        (l.x = R * w.x + I * C.x),
          (l.y = R * w.y + I * C.y),
          (l.z = R * w.z + I * C.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (a.x = c.x + i * l.x),
          (a.y = c.y + i * l.y),
          (a.z = c.z + i * l.z),
          d.push(a.x, a.y, a.z);
      }
    }
    function g() {
      for (let S = 1; S <= t; S++)
        for (let w = 1; w <= r; w++) {
          const C = (r + 1) * (S - 1) + (w - 1),
            b = (r + 1) * S + (w - 1),
            P = (r + 1) * S + w,
            I = (r + 1) * (S - 1) + w;
          v.push(C, b, I), v.push(b, P, I);
        }
    }
    function A() {
      for (let S = 0; S <= t; S++)
        for (let w = 0; w <= r; w++)
          (u.x = S / t), (u.y = w / r), m.push(u.x, u.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new bx(
      new l_[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class MN extends Lt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new z(),
        s = new z();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let u = 0, c = l.length; u < c; ++u) {
          const d = l[u],
            p = d.start,
            m = d.count;
          for (let v = p, _ = p + m; v < _; v += 3)
            for (let x = 0; x < 3; x++) {
              const g = a.getX(v + x),
                A = a.getX(v + ((x + 1) % 3));
              r.fromBufferAttribute(o, g),
                s.fromBufferAttribute(o, A),
                T2(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let u = 0; u < 3; u++) {
            const c = 3 * a + u,
              d = 3 * a + ((u + 1) % 3);
            r.fromBufferAttribute(o, c),
              s.fromBufferAttribute(o, d),
              T2(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new ht(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function T2(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var C2 = Object.freeze({
  __proto__: null,
  BoxGeometry: Nc,
  CapsuleGeometry: gx,
  CircleGeometry: vx,
  ConeGeometry: yx,
  CylinderGeometry: Yh,
  DodecahedronGeometry: _x,
  EdgesGeometry: _N,
  ExtrudeGeometry: Ax,
  IcosahedronGeometry: Sx,
  LatheGeometry: jm,
  OctahedronGeometry: Ym,
  PlaneGeometry: Kh,
  PolyhedronGeometry: Zl,
  RingGeometry: Mx,
  ShapeGeometry: wx,
  SphereGeometry: Km,
  TetrahedronGeometry: Ex,
  TorusGeometry: Tx,
  TorusKnotGeometry: Cx,
  TubeGeometry: bx,
  WireframeGeometry: MN,
});
class wN extends mi {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Ze(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class EN extends Ao {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class Qm extends mi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = "MeshStandardMaterial"),
      (this.defines = { STANDARD: "" }),
      (this.color = new Ze(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ze(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ql),
      (this.normalScale = new Ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ys()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class eo extends Qm {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Ae(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Rt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Ze(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Ze(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Ze(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class TN extends mi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Ze(16777215)),
      (this.specular = new Ze(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ze(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ql),
      (this.normalScale = new Ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ys()),
      (this.combine = Um),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class CN extends mi {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Ze(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ze(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ql),
      (this.normalScale = new Ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class bN extends mi {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ql),
      (this.normalScale = new Ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class RN extends mi {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Ze(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ze(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ql),
      (this.normalScale = new Ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ys()),
      (this.combine = Um),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class PT extends mi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = jF),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class BT extends mi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
class PN extends mi {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Ze(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Ql),
      (this.normalScale = new Ae(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class BN extends ir {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function Yu(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function IN(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function DN(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function tw(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) r[o++] = n[a + l];
  }
  return r;
}
function IT(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[r++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++]);
      while (s !== void 0);
    else
      do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]);
      while (s !== void 0);
}
function b5(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const u = s.tracks[l],
      c = u.getValueSize(),
      d = [],
      p = [];
    for (let m = 0; m < u.times.length; ++m) {
      const v = u.times[m] * r;
      if (!(v < t || v >= i)) {
        d.push(u.times[m]);
        for (let _ = 0; _ < c; ++_) p.push(u.values[m * c + _]);
      }
    }
    d.length !== 0 &&
      ((u.times = Yu(d, u.times.constructor)),
      (u.values = Yu(p, u.values.constructor)),
      o.push(u));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function R5(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length,
    s = e / i;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const u = n.tracks.find(function (g) {
      return g.name === a.name && g.ValueTypeName === l;
    });
    if (u === void 0) continue;
    let c = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (c = d / 3);
    let p = 0;
    const m = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    const v = a.times.length - 1;
    let _;
    if (s <= a.times[0]) {
      const g = c,
        A = d - c;
      _ = a.values.slice(g, A);
    } else if (s >= a.times[v]) {
      const g = v * d + c,
        A = g + d - c;
      _ = a.values.slice(g, A);
    } else {
      const g = a.createInterpolant(),
        A = c,
        S = d - c;
      g.evaluate(s), (_ = g.resultBuffer.slice(A, S));
    }
    l === "quaternion" &&
      new Ri().fromArray(_).normalize().conjugate().toArray(_);
    const x = u.times.length;
    for (let g = 0; g < x; ++g) {
      const A = g * m + p;
      if (l === "quaternion")
        Ri.multiplyQuaternionsFlat(u.values, A, _, 0, u.values, A);
      else {
        const S = m - p * 2;
        for (let w = 0; w < S; ++w) u.values[A + w] -= _[w];
      }
    }
  }
  return (n.blendMode = uT), n;
}
const P5 = {
  convertArray: Yu,
  isTypedArray: IN,
  getKeyframeOrder: DN,
  sortedArray: tw,
  flattenJSON: IT,
  subclip: b5,
  makeClipAdditive: R5,
};
class Qh {
  constructor(e, t, i, r) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === l) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            (o = i), (i = 0);
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < t[a] ? (o = a) : (i = a + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class LN extends Qh {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Xu, endingEnd: Xu });
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Ju:
          (s = e), (a = 2 * t - i);
          break;
        case lm:
          (s = r.length - 2), (a = t + r[s] - r[s + 1]);
          break;
        default:
          (s = e), (a = i);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ju:
          (o = e), (l = 2 * i - t);
          break;
        case lm:
          (o = 1), (l = i + r[1] - r[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const u = (i - t) * 0.5,
      c = this.valueSize;
    (this._weightPrev = u / (t - a)),
      (this._weightNext = u / (l - i)),
      (this._offsetPrev = s * c),
      (this._offsetNext = o * c);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      u = l - a,
      c = this._offsetPrev,
      d = this._offsetNext,
      p = this._weightPrev,
      m = this._weightNext,
      v = (i - t) / (r - t),
      _ = v * v,
      x = _ * v,
      g = -p * x + 2 * p * _ - p * v,
      A = (1 + p) * x + (-1.5 - 2 * p) * _ + (-0.5 + p) * v + 1,
      S = (-1 - m) * x + (1.5 + m) * _ + 0.5 * v,
      w = m * x - m * _;
    for (let C = 0; C !== a; ++C)
      s[C] = g * o[c + C] + A * o[u + C] + S * o[l + C] + w * o[d + C];
    return s;
  }
}
class DT extends Qh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      u = l - a,
      c = (i - t) / (r - t),
      d = 1 - c;
    for (let p = 0; p !== a; ++p) s[p] = o[u + p] * d + o[l + p] * c;
    return s;
  }
}
class FN extends Qh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class wo {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = Yu(t, this.TimeBufferType)),
      (this.values = Yu(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: Yu(e.times, Array),
        values: Yu(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new FN(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new DT(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new LN(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Th:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Ch:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Uv:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Th;
      case this.InterpolantFactoryMethodLinear:
        return Ch;
      case this.InterpolantFactoryMethodSmooth:
        return Uv;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = i.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (r !== void 0 && IN(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const u = r[a];
        if (isNaN(u)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            u
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === Uv,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const u = e[a],
        c = e[a + 1];
      if (u !== c && (a !== 1 || u !== e[0]))
        if (r) l = !0;
        else {
          const d = a * i,
            p = d - i,
            m = d + i;
          for (let v = 0; v !== i; ++v) {
            const _ = t[d + v];
            if (_ !== t[p + v] || _ !== t[m + v]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * i,
            p = o * i;
          for (let m = 0; m !== i; ++m) t[p + m] = t[d + m];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, u = 0; u !== i; ++u) t[l + u] = t[a + u];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, t);
    return (r.createInterpolant = this.createInterpolant), r;
  }
}
wo.prototype.TimeBufferType = Float32Array;
wo.prototype.ValueBufferType = Float32Array;
wo.prototype.DefaultInterpolation = Ch;
class Oc extends wo {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
Oc.prototype.ValueTypeName = "bool";
Oc.prototype.ValueBufferType = Array;
Oc.prototype.DefaultInterpolation = Th;
Oc.prototype.InterpolantFactoryMethodLinear = void 0;
Oc.prototype.InterpolantFactoryMethodSmooth = void 0;
class LT extends wo {}
LT.prototype.ValueTypeName = "color";
class Tc extends wo {}
Tc.prototype.ValueTypeName = "number";
class NN extends Qh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (i - t) / (r - t);
    let u = e * a;
    for (let c = u + a; u !== c; u += 4) Ri.slerpFlat(s, 0, o, u - a, o, u, l);
    return s;
  }
}
class Cc extends wo {
  InterpolantFactoryMethodLinear(e) {
    return new NN(this.times, this.values, this.getValueSize(), e);
  }
}
Cc.prototype.ValueTypeName = "quaternion";
Cc.prototype.InterpolantFactoryMethodSmooth = void 0;
class Uc extends wo {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
Uc.prototype.ValueTypeName = "string";
Uc.prototype.ValueBufferType = Array;
Uc.prototype.DefaultInterpolation = Th;
Uc.prototype.InterpolantFactoryMethodLinear = void 0;
Uc.prototype.InterpolantFactoryMethodSmooth = void 0;
class bc extends wo {}
bc.prototype.ValueTypeName = "vector";
class Ph {
  constructor(e = "", t = -1, i = [], r = lx) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = ms()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(I5(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(wo.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        u = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0);
      const c = DN(l);
      (l = tw(l, 1, c)),
        (u = tw(u, 1, c)),
        !r && l[0] === 0 && (l.push(s), u.push(u[0])),
        o.push(
          new Tc(".morphTargetInfluences[" + t[a].name + "]", l, u).scale(1 / i)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a],
        c = u.name.match(s);
      if (c && c.length > 1) {
        const d = c[1];
        let p = r[d];
        p || (r[d] = p = []), p.push(u);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (d, p, m, v, _) {
        if (m.length !== 0) {
          const x = [],
            g = [];
          IT(m, x, g, v), x.length !== 0 && _.push(new d(p, x, g));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const u = e.hierarchy || [];
    for (let d = 0; d < u.length; d++) {
      const p = u[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let v;
          for (v = 0; v < p.length; v++)
            if (p[v].morphTargets)
              for (let _ = 0; _ < p[v].morphTargets.length; _++)
                m[p[v].morphTargets[_]] = -1;
          for (const _ in m) {
            const x = [],
              g = [];
            for (let A = 0; A !== p[v].morphTargets.length; ++A) {
              const S = p[v];
              x.push(S.time), g.push(S.morphTarget === _ ? 1 : 0);
            }
            r.push(new Tc(".morphTargetInfluence[" + _ + "]", x, g));
          }
          l = m.length * o;
        } else {
          const m = ".bones[" + t[d].name + "]";
          i(bc, m + ".position", p, "pos", r),
            i(Cc, m + ".quaternion", p, "rot", r),
            i(bc, m + ".scale", p, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function B5(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Tc;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return bc;
    case "color":
      return LT;
    case "quaternion":
      return Cc;
    case "bool":
    case "boolean":
      return Oc;
    case "string":
      return Uc;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function I5(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = B5(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    IT(n.keys, t, i, "value"), (n.times = t), (n.values = i);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Ma = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class FT {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const u = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (c) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(c, o, a), (s = !0);
      }),
      (this.itemEnd = function (c) {
        o++,
          r.onProgress !== void 0 && r.onProgress(c, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (c) {
        r.onError !== void 0 && r.onError(c);
      }),
      (this.resolveURL = function (c) {
        return l ? l(c) : c;
      }),
      (this.setURLModifier = function (c) {
        return (l = c), this;
      }),
      (this.addHandler = function (c, d) {
        return u.push(c, d), this;
      }),
      (this.removeHandler = function (c) {
        const d = u.indexOf(c);
        return d !== -1 && u.splice(d, 2), this;
      }),
      (this.getHandler = function (c) {
        for (let d = 0, p = u.length; d < p; d += 2) {
          const m = u[d],
            v = u[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(c))) return v;
        }
        return null;
      });
  }
}
const Jf = new FT();
class rr {
  constructor(e) {
    (this.manager = e !== void 0 ? e : Jf),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
rr.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const ca = {};
class D5 extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class _s extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = Ma.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (ca[e] !== void 0) {
      ca[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    (ca[e] = []), ca[e].push({ onLoad: t, onProgress: i, onError: r });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((u) => {
        if (u.status === 200 || u.status === 0) {
          if (
            (u.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              u.body === void 0 ||
              u.body.getReader === void 0)
          )
            return u;
          const c = ca[e],
            d = u.body.getReader(),
            p = u.headers.get("X-File-Size") || u.headers.get("Content-Length"),
            m = p ? parseInt(p) : 0,
            v = m !== 0;
          let _ = 0;
          const x = new ReadableStream({
            start(g) {
              A();
              function A() {
                d.read().then(
                  ({ done: S, value: w }) => {
                    if (S) g.close();
                    else {
                      _ += w.byteLength;
                      const C = new ProgressEvent("progress", {
                        lengthComputable: v,
                        loaded: _,
                        total: m,
                      });
                      for (let b = 0, P = c.length; b < P; b++) {
                        const I = c[b];
                        I.onProgress && I.onProgress(C);
                      }
                      g.enqueue(w), A();
                    }
                  },
                  (S) => {
                    g.error(S);
                  }
                );
              }
            },
          });
          return new Response(x);
        } else
          throw new D5(
            `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,
            u
          );
      })
      .then((u) => {
        switch (l) {
          case "arraybuffer":
            return u.arrayBuffer();
          case "blob":
            return u.blob();
          case "document":
            return u.text().then((c) => new DOMParser().parseFromString(c, a));
          case "json":
            return u.json();
          default:
            if (a === void 0) return u.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                p = d && d[1] ? d[1].toLowerCase() : void 0,
                m = new TextDecoder(p);
              return u.arrayBuffer().then((v) => m.decode(v));
            }
        }
      })
      .then((u) => {
        Ma.add(e, u);
        const c = ca[e];
        delete ca[e];
        for (let d = 0, p = c.length; d < p; d++) {
          const m = c[d];
          m.onLoad && m.onLoad(u);
        }
      })
      .catch((u) => {
        const c = ca[e];
        if (c === void 0) throw (this.manager.itemError(e), u);
        delete ca[e];
        for (let d = 0, p = c.length; d < p; d++) {
          const m = c[d];
          m.onError && m.onError(u);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class L5 extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new _s(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = Ph.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class F5 extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = [],
      a = new px(),
      l = new _s(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials);
    let u = 0;
    function c(d) {
      l.load(
        e[d],
        function (p) {
          const m = s.parse(p, !0);
          (o[d] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (u += 1),
            u === 6 &&
              (m.mipmapCount === 1 && (a.minFilter = Zn),
              (a.image = o),
              (a.format = m.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        i,
        r
      );
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) c(d);
    else
      l.load(
        e,
        function (d) {
          const p = s.parse(d, !0);
          if (p.isCubemap) {
            const m = p.mipmaps.length / p.mipmapCount;
            for (let v = 0; v < m; v++) {
              o[v] = { mipmaps: [] };
              for (let _ = 0; _ < p.mipmapCount; _++)
                o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + _]),
                  (o[v].format = p.format),
                  (o[v].width = p.width),
                  (o[v].height = p.height);
            }
            a.image = o;
          } else
            (a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (a.minFilter = Zn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        i,
        r
      );
    return a;
  }
}
class vm extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Ma.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = hm("img");
    function l() {
      c(), Ma.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function u(d) {
      c(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function c() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", u, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", u, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class N5 extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Gm();
    s.colorSpace = Fr;
    const o = new vm(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(u) {
      o.load(
        e[u],
        function (c) {
          (s.images[u] = c), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        r
      );
    }
    for (let u = 0; u < e.length; ++u) l(u);
    return s;
  }
}
class O5 extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Wo(),
      a = new _s(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          let u;
          try {
            u = s.parse(l);
          } catch (c) {
            if (r !== void 0) r(c);
            else {
              console.error(c);
              return;
            }
          }
          u.image !== void 0
            ? (o.image = u.image)
            : u.data !== void 0 &&
              ((o.image.width = u.width),
              (o.image.height = u.height),
              (o.image.data = u.data)),
            (o.wrapS = u.wrapS !== void 0 ? u.wrapS : fs),
            (o.wrapT = u.wrapT !== void 0 ? u.wrapT : fs),
            (o.magFilter = u.magFilter !== void 0 ? u.magFilter : Zn),
            (o.minFilter = u.minFilter !== void 0 ? u.minFilter : Zn),
            (o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1),
            u.colorSpace !== void 0 && (o.colorSpace = u.colorSpace),
            u.flipY !== void 0 && (o.flipY = u.flipY),
            u.format !== void 0 && (o.format = u.format),
            u.type !== void 0 && (o.type = u.type),
            u.mipmaps !== void 0 &&
              ((o.mipmaps = u.mipmaps), (o.minFilter = Xs)),
            u.mipmapCount === 1 && (o.minFilter = Zn),
            u.generateMipmaps !== void 0 &&
              (o.generateMipmaps = u.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, u);
        },
        i,
        r
      ),
      o
    );
  }
}
class ON extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Pn(),
      o = new vm(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        i,
        r
      ),
      s
    );
  }
}
class ql extends qt {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Ze(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class UN extends ql {
  constructor(e, t, i) {
    super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(qt.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Ze(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const q1 = new _t(),
  b2 = new z(),
  R2 = new z();
class NT {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Ae(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new _t()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Xm()),
      (this._frameExtents = new Ae(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new tn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    b2.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(b2),
      R2.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(R2),
      t.updateMatrixWorld(),
      q1.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(q1),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(q1);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class U5 extends NT {
  constructor() {
    super(new bn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = bh * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class OT extends ql {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(qt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new qt()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new U5());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const P2 = new _t(),
  Fd = new z(),
  $1 = new z();
class k5 extends NT {
  constructor() {
    super(new bn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Ae(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new tn(2, 1, 1, 1),
        new tn(0, 1, 1, 1),
        new tn(3, 1, 1, 1),
        new tn(1, 1, 1, 1),
        new tn(3, 0, 1, 1),
        new tn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new z(1, 0, 0),
        new z(-1, 0, 0),
        new z(0, 0, 1),
        new z(0, 0, -1),
        new z(0, 1, 0),
        new z(0, -1, 0),
      ]),
      (this._cubeUps = [
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 0, 1),
        new z(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Fd.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Fd),
      $1.copy(i.position),
      $1.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt($1),
      i.updateMatrixWorld(),
      r.makeTranslation(-Fd.x, -Fd.y, -Fd.z),
      P2.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(P2);
  }
}
class UT extends ql {
  constructor(e, t, i = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new k5());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class yo extends Hm {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + t,
      l = r - t;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += u * this.view.offsetX),
        (o = s + u * this.view.width),
        (a -= c * this.view.offsetY),
        (l = a - c * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class z5 extends NT {
  constructor() {
    super(new yo(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class kT extends ql {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(qt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new qt()),
      (this.shadow = new z5());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class kN extends ql {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class zN extends ql {
  constructor(e, t, i = 10, r = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = i),
      (this.height = r);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class HN {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new z());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * i),
      t.addScaledVector(o[4], 1.092548 * (i * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (i * s)),
      t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * i),
      t.addScaledVector(o[4], 2 * 0.429043 * i * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * i * s),
      t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r));
  }
}
class GN extends ql {
  constructor(e = new HN(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class Rx extends rr {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, i, r) {
    const s = this,
      o = new _s(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const r = this.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new Ze().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (r.dispersion = e.dispersion),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (r.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (r.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        r.blendColor !== void 0 &&
        r.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== void 0 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((r.uniforms[s] = {}), o.type)) {
          case "t":
            r.uniforms[s].value = i(o.value);
            break;
          case "c":
            r.uniforms[s].value = new Ze().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new Ae().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new z().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new tn().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new It().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new _t().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (r.lights = e.lights),
      e.clipping !== void 0 && (r.clipping = e.clipping),
      e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new Ae().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapRotation !== void 0 &&
        r.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new Ae().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  createMaterialFromType(e) {
    return Rx.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: wN,
      SpriteMaterial: yT,
      RawShaderMaterial: EN,
      ShaderMaterial: Ao,
      PointsMaterial: Jm,
      MeshPhysicalMaterial: eo,
      MeshStandardMaterial: Qm,
      MeshPhongMaterial: TN,
      MeshToonMaterial: CN,
      MeshNormalMaterial: bN,
      MeshLambertMaterial: RN,
      MeshDepthMaterial: PT,
      MeshDistanceMaterial: BT,
      MeshBasicMaterial: hs,
      MeshMatcapMaterial: PN,
      LineDashedMaterial: BN,
      LineBasicMaterial: ir,
      Material: mi,
    };
    return new t[e]();
  }
}
class Il {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class VN extends Lt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class WN extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new _s(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = {},
      i = {};
    function r(m, v) {
      if (t[v] !== void 0) return t[v];
      const x = m.interleavedBuffers[v],
        g = s(m, x.buffer),
        A = Wf(x.type, g),
        S = new Vm(A, x.stride);
      return (S.uuid = x.uuid), (t[v] = S), S;
    }
    function s(m, v) {
      if (i[v] !== void 0) return i[v];
      const x = m.arrayBuffers[v],
        g = new Uint32Array(x).buffer;
      return (i[v] = g), g;
    }
    const o = e.isInstancedBufferGeometry ? new VN() : new Lt(),
      a = e.data.index;
    if (a !== void 0) {
      const m = Wf(a.type, a.array);
      o.setIndex(new rn(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const v = l[m];
      let _;
      if (v.isInterleavedBufferAttribute) {
        const x = r(e.data, v.data);
        _ = new Hl(x, v.itemSize, v.offset, v.normalized);
      } else {
        const x = Wf(v.type, v.array),
          g = v.isInstancedBufferAttribute ? wc : rn;
        _ = new g(x, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (_.name = v.name),
        v.usage !== void 0 && _.setUsage(v.usage),
        o.setAttribute(m, _);
    }
    const u = e.data.morphAttributes;
    if (u)
      for (const m in u) {
        const v = u[m],
          _ = [];
        for (let x = 0, g = v.length; x < g; x++) {
          const A = v[x];
          let S;
          if (A.isInterleavedBufferAttribute) {
            const w = r(e.data, A.data);
            S = new Hl(w, A.itemSize, A.offset, A.normalized);
          } else {
            const w = Wf(A.type, A.array);
            S = new rn(w, A.itemSize, A.normalized);
          }
          A.name !== void 0 && (S.name = A.name), _.push(S);
        }
        o.morphAttributes[m] = _;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, v = d.length; m !== v; ++m) {
        const _ = d[m];
        o.addGroup(_.start, _.count, _.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const m = new z();
      p.center !== void 0 && m.fromArray(p.center),
        (o.boundingSphere = new Ni(m, p.radius));
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    );
  }
}
class H5 extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = this.path === "" ? Il.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new _s(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let u = null;
          try {
            u = JSON.parse(l);
          } catch (d) {
            r !== void 0 && r(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              );
            return;
          }
          const c = u.metadata;
          if (
            c === void 0 ||
            c.type === void 0 ||
            c.type.toLowerCase() === "geometry"
          ) {
            r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(u, t);
        },
        i,
        r
      );
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === "" ? Il.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new _s(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(u);
      }),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      u = this.parseObject(e.object, s, l, a, i),
      c = this.parseSkeletons(e.skeletons, u);
    if ((this.bindSkeletons(u, c), this.bindLightTargets(u), t !== void 0)) {
      let d = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(u);
    }
    return u;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      l = this.parseObject(e.object, r, a, o, t),
      u = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, u), this.bindLightTargets(l), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new ac().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new Wm().fromJSON(e[s], r);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new WN();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(l);
            break;
          default:
            l.type in C2
              ? (a = C2[l.type].fromJSON(l, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (i[l.uuid] = a);
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {},
      r = {};
    if (e !== void 0) {
      const s = new Rx();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
          (r[l.uuid] = i[l.uuid]);
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = Ph.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this,
      r = {};
    let s;
    function o(l) {
      return (
        i.manager.itemStart(l),
        s.load(
          l,
          function () {
            i.manager.itemEnd(l);
          },
          void 0,
          function () {
            i.manager.itemError(l), i.manager.itemEnd(l);
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l,
          c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : i.resourcePath + u;
        return o(c);
      } else
        return l.data
          ? { data: Wf(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new FT(t);
      (s = new vm(l)), s.setCrossOrigin(this.crossOrigin);
      for (let u = 0, c = e.length; u < c; u++) {
        const d = e[u],
          p = d.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, _ = p.length; v < _; v++) {
            const x = p[v],
              g = a(x);
            g !== null &&
              (g instanceof HTMLImageElement
                ? m.push(g)
                : m.push(new Wo(g.data, g.width, g.height)));
          }
          r[d.uuid] = new ju(m);
        } else {
          const m = a(d.url);
          r[d.uuid] = new ju(m);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(l);
      } else
        return o.data
          ? { data: Wf(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (r = new vm(this.manager)), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o],
          u = l.url;
        if (Array.isArray(u)) {
          const c = [];
          for (let d = 0, p = u.length; d < p; d++) {
            const m = u[d],
              v = await s(m);
            v !== null &&
              (v instanceof HTMLImageElement
                ? c.push(v)
                : c.push(new Wo(v.data, v.width, v.height)));
          }
          i[l.uuid] = new ju(c);
        } else {
          const c = await s(l.url);
          i[l.uuid] = new ju(c);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image],
          u = l.data;
        let c;
        Array.isArray(u)
          ? ((c = new Gm()), u.length === 6 && (c.needsUpdate = !0))
          : (u && u.data ? (c = new Wo()) : (c = new Pn()),
            u && (c.needsUpdate = !0)),
          (c.source = l),
          (c.uuid = a.uuid),
          a.name !== void 0 && (c.name = a.name),
          a.mapping !== void 0 && (c.mapping = i(a.mapping, G5)),
          a.channel !== void 0 && (c.channel = a.channel),
          a.offset !== void 0 && c.offset.fromArray(a.offset),
          a.repeat !== void 0 && c.repeat.fromArray(a.repeat),
          a.center !== void 0 && c.center.fromArray(a.center),
          a.rotation !== void 0 && (c.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((c.wrapS = i(a.wrap[0], B2)), (c.wrapT = i(a.wrap[1], B2))),
          a.format !== void 0 && (c.format = a.format),
          a.internalFormat !== void 0 && (c.internalFormat = a.internalFormat),
          a.type !== void 0 && (c.type = a.type),
          a.colorSpace !== void 0 && (c.colorSpace = a.colorSpace),
          a.minFilter !== void 0 && (c.minFilter = i(a.minFilter, I2)),
          a.magFilter !== void 0 && (c.magFilter = i(a.magFilter, I2)),
          a.anisotropy !== void 0 && (c.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (c.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (c.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (c.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (c.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (c.compareFunction = a.compareFunction),
          a.userData !== void 0 && (c.userData = a.userData),
          (r[a.uuid] = c);
      }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function a(p) {
      return (
        t[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        t[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, _ = p.length; v < _; v++) {
            const x = p[v];
            i[x] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", x),
              m.push(i[x]);
          }
          return m;
        }
        return (
          i[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          i[p]
        );
      }
    }
    function u(p) {
      return (
        r[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        r[p]
      );
    }
    let c, d;
    switch (e.type) {
      case "Scene":
        (o = new vT()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Ze(e.background))
              : (o.background = u(e.background))),
          e.environment !== void 0 && (o.environment = u(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new hx(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new fx(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            o.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (o.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            o.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (o = new bn(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new yo(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new kN(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (o = new kT(e.color, e.intensity)), (o.target = e.target || "");
        break;
      case "PointLight":
        o = new UT(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new zN(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (o = new OT(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (o.target = e.target || "");
        break;
      case "HemisphereLight":
        o = new UN(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new GN().fromJSON(e);
        break;
      case "SkinnedMesh":
        (c = a(e.geometry)),
          (d = l(e.material)),
          (o = new _T(c, d)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (c = a(e.geometry)), (d = l(e.material)), (o = new qn(c, d));
        break;
      case "InstancedMesh":
        (c = a(e.geometry)), (d = l(e.material));
        const p = e.count,
          m = e.instanceMatrix,
          v = e.instanceColor;
        (o = new xT(c, d, p)),
          (o.instanceMatrix = new wc(new Float32Array(m.array), 16)),
          v !== void 0 &&
            (o.instanceColor = new wc(new Float32Array(v.array), v.itemSize));
        break;
      case "BatchedMesh":
        (c = a(e.geometry)),
          (d = l(e.material)),
          (o = new dN(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            d
          )),
          (o.geometry = c),
          (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (o.sortObjects = e.sortObjects),
          (o._drawRanges = e.drawRanges),
          (o._reservedRanges = e.reservedRanges),
          (o._visibility = e.visibility),
          (o._active = e.active),
          (o._bounds = e.bounds.map((_) => {
            const x = new er();
            x.min.fromArray(_.boxMin), x.max.fromArray(_.boxMax);
            const g = new Ni();
            return (
              (g.radius = _.sphereRadius),
              g.center.fromArray(_.sphereCenter),
              {
                boxInitialized: _.boxInitialized,
                box: x,
                sphereInitialized: _.sphereInitialized,
                sphere: g,
              }
            );
          })),
          (o._maxInstanceCount = e.maxInstanceCount),
          (o._maxVertexCount = e.maxVertexCount),
          (o._maxIndexCount = e.maxIndexCount),
          (o._geometryInitialized = e.geometryInitialized),
          (o._geometryCount = e.geometryCount),
          (o._matricesTexture = u(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (o._colorsTexture = u(e.colorsTexture.uuid));
        break;
      case "LOD":
        o = new hN();
        break;
      case "Line":
        o = new ka(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new AT(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new So(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new ST(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new fN(l(e.material));
        break;
      case "Group":
        o = new Sa();
        break;
      case "Bone":
        o = new dx();
        break;
      default:
        o = new qt();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (o.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        o.add(this.parseObject(p[m], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const v = p[m];
        o.animations.push(s[v]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const v = p[m],
          _ = o.getObjectByProperty("uuid", v.object);
        _ !== void 0 && o.addLevel(_, v.distance, v.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton];
          r === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                i.skeleton
              )
            : i.bind(r, i.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const i = t.target,
          r = e.getObjectByProperty("uuid", i);
        r !== void 0 ? (t.target = r) : (t.target = new qt());
      }
    });
  }
}
const G5 = {
    UVMapping: ex,
    CubeReflectionMapping: Oa,
    CubeRefractionMapping: kl,
    EquirectangularReflectionMapping: om,
    EquirectangularRefractionMapping: am,
    CubeUVReflectionMapping: Jh,
  },
  B2 = {
    RepeatWrapping: zl,
    ClampToEdgeWrapping: fs,
    MirroredRepeatWrapping: wh,
  },
  I2 = {
    NearestFilter: bi,
    NearestMipmapNearestFilter: tx,
    NearestMipmapLinearFilter: Wu,
    LinearFilter: Zn,
    LinearMipmapNearestFilter: ah,
    LinearMipmapLinearFilter: Xs,
  };
class XN extends rr {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Ma.get(e);
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((u) => {
          t && t(u), s.manager.itemEnd(e);
        }).catch((u) => {
          r && r(u);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    const l = fetch(e, a)
      .then(function (u) {
        return u.blob();
      })
      .then(function (u) {
        return createImageBitmap(
          u,
          Object.assign(s.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (u) {
        return Ma.add(e, u), t && t(u), s.manager.itemEnd(e), u;
      })
      .catch(function (u) {
        r && r(u), Ma.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
      });
    Ma.add(e, l), s.manager.itemStart(e);
  }
}
let K0;
class zT {
  static getContext() {
    return (
      K0 === void 0 &&
        (K0 = new (window.AudioContext || window.webkitAudioContext)()),
      K0
    );
  }
  static setContext(e) {
    K0 = e;
  }
}
class V5 extends rr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new _s(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (l) {
          try {
            const u = l.slice(0);
            zT.getContext()
              .decodeAudioData(u, function (d) {
                t(d);
              })
              .catch(a);
          } catch (u) {
            a(u);
          }
        },
        i,
        r
      );
    function a(l) {
      r ? r(l) : console.error(l), s.manager.itemError(e);
    }
  }
}
const D2 = new _t(),
  L2 = new _t(),
  gu = new _t();
class W5 {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new bn()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new bn()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        gu.copy(e.projectionMatrix);
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(sc * t.fov * 0.5)) / t.zoom;
      let a, l;
      (L2.elements[12] = -r),
        (D2.elements[12] = r),
        (a = -o * t.aspect + s),
        (l = o * t.aspect + s),
        (gu.elements[0] = (2 * t.near) / (l - a)),
        (gu.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(gu),
        (a = -o * t.aspect - s),
        (l = o * t.aspect - s),
        (gu.elements[0] = (2 * t.near) / (l - a)),
        (gu.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(gu);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(L2),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(D2);
  }
}
class JN extends bn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class HT {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = F2()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = F2();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function F2() {
  return performance.now();
}
const vu = new z(),
  N2 = new Ri(),
  X5 = new z(),
  yu = new z();
class J5 extends qt {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = zT.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new HT());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      i = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(vu, N2, X5),
      yu.set(0, 0, -1).applyQuaternion(N2),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(vu.x, r),
        t.positionY.linearRampToValueAtTime(vu.y, r),
        t.positionZ.linearRampToValueAtTime(vu.z, r),
        t.forwardX.linearRampToValueAtTime(yu.x, r),
        t.forwardY.linearRampToValueAtTime(yu.y, r),
        t.forwardZ.linearRampToValueAtTime(yu.z, r),
        t.upX.linearRampToValueAtTime(i.x, r),
        t.upY.linearRampToValueAtTime(i.y, r),
        t.upZ.linearRampToValueAtTime(i.z, r);
    } else
      t.setPosition(vu.x, vu.y, vu.z),
        t.setOrientation(yu.x, yu.y, yu.z, i.x, i.y, i.z);
  }
}
class jN extends qt {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    (this.isPlaying = !1), (this._progress = 0);
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== "buffer"
        ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
          this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    );
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const _u = new z(),
  O2 = new Ri(),
  j5 = new z(),
  xu = new z();
class Y5 extends jN {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(_u, O2, j5), xu.set(0, 0, 1).applyQuaternion(O2);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(_u.x, i),
        t.positionY.linearRampToValueAtTime(_u.y, i),
        t.positionZ.linearRampToValueAtTime(_u.z, i),
        t.orientationX.linearRampToValueAtTime(xu.x, i),
        t.orientationY.linearRampToValueAtTime(xu.y, i),
        t.orientationZ.linearRampToValueAtTime(xu.z, i);
    } else t.setPosition(_u.x, _u.y, _u.z), t.setOrientation(xu.x, xu.y, xu.z);
  }
}
class K5 {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class YN {
  constructor(e, t, i) {
    (this.binding = e), (this.valueSize = i);
    let r, s, o;
    switch (t) {
      case "quaternion":
        (r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5));
        break;
      default:
        (r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5));
    }
    (this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(i, r, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let l = t, u = t + t; l !== u; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    Ri.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    Ri.multiplyQuaternionsFlat(e, o, e, t, e, i),
      Ri.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const GT = "\\[\\]\\.:\\/",
  Q5 = new RegExp("[" + GT + "]", "g"),
  VT = "[^" + GT + "]",
  Z5 = "[^" + GT.replace("\\.", "") + "]",
  q5 = /((?:WC+[\/:])*)/.source.replace("WC", VT),
  $5 = /(WCOD+)?/.source.replace("WCOD", Z5),
  e8 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", VT),
  t8 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", VT),
  n8 = new RegExp("^" + q5 + $5 + e8 + t8 + "$"),
  i8 = ["material", "materials", "bones", "map"];
class r8 {
  constructor(e, t, i) {
    const r = i || $t.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class $t {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || $t.parseTrackName(t)),
      (this.node = $t.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new $t.Composite(e, t, i)
      : new $t(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(Q5, "");
  }
  static parseTrackName(e) {
    const t = n8.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      i8.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = i(a.children);
            if (l) return l;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = $t.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (i) {
      let u = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let c = 0; c < e.length; c++)
            if (e[c].name === u) {
              u = c;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (u !== void 0) {
        if (e[u] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[u];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const u = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          u +
          "." +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.isMaterial === !0
        ? (a = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = r);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
$t.Composite = r8;
$t.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
$t.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
$t.prototype.GetterByBindingType = [
  $t.prototype._getValue_direct,
  $t.prototype._getValue_array,
  $t.prototype._getValue_arrayElement,
  $t.prototype._getValue_toArray,
];
$t.prototype.SetterByBindingTypeAndVersioning = [
  [
    $t.prototype._setValue_direct,
    $t.prototype._setValue_direct_setNeedsUpdate,
    $t.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    $t.prototype._setValue_array,
    $t.prototype._setValue_array_setNeedsUpdate,
    $t.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    $t.prototype._setValue_arrayElement,
    $t.prototype._setValue_arrayElement_setNeedsUpdate,
    $t.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    $t.prototype._setValue_fromArray,
    $t.prototype._setValue_fromArray_setNeedsUpdate,
    $t.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class s8 {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = ms()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i)
      e[arguments[i].uuid] = i;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      l = e.length,
      u = this.nCachedObjects_;
    for (let c = 0, d = arguments.length; c !== d; ++c) {
      const p = arguments[c],
        m = p.uuid;
      let v = t[m];
      if (v === void 0) {
        (v = l++), (t[m] = v), e.push(p);
        for (let _ = 0, x = o; _ !== x; ++_) s[_].push(new $t(p, i[_], r[_]));
      } else if (v < u) {
        a = e[v];
        const _ = --u,
          x = e[_];
        (t[x.uuid] = v), (e[v] = x), (t[m] = _), (e[_] = p);
        for (let g = 0, A = o; g !== A; ++g) {
          const S = s[g],
            w = S[_];
          let C = S[v];
          (S[v] = w), C === void 0 && (C = new $t(p, i[g], r[g])), (S[_] = C);
        }
      } else
        e[v] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = u;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o],
        u = l.uuid,
        c = t[u];
      if (c !== void 0 && c >= s) {
        const d = s++,
          p = e[d];
        (t[p.uuid] = c), (e[c] = p), (t[u] = d), (e[d] = l);
        for (let m = 0, v = r; m !== v; ++m) {
          const _ = i[m],
            x = _[d],
            g = _[c];
          (_[c] = x), (_[d] = g);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const u = arguments[a],
        c = u.uuid,
        d = t[c];
      if (d !== void 0)
        if ((delete t[c], d < s)) {
          const p = --s,
            m = e[p],
            v = --o,
            _ = e[v];
          (t[m.uuid] = d), (e[d] = m), (t[_.uuid] = p), (e[p] = _), e.pop();
          for (let x = 0, g = r; x !== g; ++x) {
            const A = i[x],
              S = A[p],
              w = A[v];
            (A[d] = S), (A[p] = w), A.pop();
          }
        } else {
          const p = --o,
            m = e[p];
          p > 0 && (t[m.uuid] = d), (e[d] = m), e.pop();
          for (let v = 0, _ = r; v !== _; ++v) {
            const x = i[v];
            (x[d] = x[p]), x.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      u = l.length,
      c = this.nCachedObjects_,
      d = new Array(u);
    (r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(d);
    for (let p = c, m = l.length; p !== m; ++p) {
      const v = l[p];
      d[p] = new $t(v, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e];
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        l = o[a],
        u = e[a];
      (t[u] = i),
        (o[i] = l),
        o.pop(),
        (s[i] = s[a]),
        s.pop(),
        (r[i] = r[a]),
        r.pop();
    }
  }
}
class KN {
  constructor(e, t, i = null, r = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r);
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: Xu, endingEnd: Xu };
    for (let u = 0; u !== o; ++u) {
      const c = s[u].createInterpolant(null);
      (a[u] = c), (c.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = WF),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      u = a.sampleValues;
    return (l[0] = s), (l[1] = s + i), (u[0] = e / o), (u[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * l));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        u = this._propertyBindings;
      switch (this.blendMode) {
        case uT:
          for (let c = 0, d = l.length; c !== d; ++c)
            l[c].evaluate(o), u[c].accumulateAdditive(a);
          break;
        case lx:
        default:
          for (let c = 0, d = l.length; c !== d; ++c)
            l[c].evaluate(o), u[c].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const o = i === XF;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === VF) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t);
        (r -= t * a), (s += Math.abs(a));
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const u = e < 0;
            this._setEndings(u, !u, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i
      ? ((r.endingStart = Ju), (r.endingEnd = Ju))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? Ju : Xu)
          : (r.endingStart = lm),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Ju : Xu) : (r.endingEnd = lm));
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = i), this;
  }
}
const o8 = new Float32Array(1);
class a8 extends Zo {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = i.uuid,
      u = this._bindingsByRootAndName;
    let c = u[l];
    c === void 0 && ((c = {}), (u[l] = c));
    for (let d = 0; d !== s; ++d) {
      const p = r[d],
        m = p.name;
      let v = c[m];
      if (v !== void 0) ++v.referenceCount, (o[d] = v);
      else {
        if (((v = o[d]), v !== void 0)) {
          v._cacheIndex === null &&
            (++v.referenceCount, this._addInactiveBinding(v, l, m));
          continue;
        }
        const _ = t && t._propertyBindings[d].binding.parsedPath;
        (v = new YN($t.create(i, m, _), p.ValueTypeName, p.getValueSize())),
          ++v.referenceCount,
          this._addInactiveBinding(v, l, m),
          (o[d] = v);
      }
      a[d].resultBuffer = v.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex;
    (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      u = l[l.length - 1],
      c = e._byClipCacheIndex;
    (u._byClipCacheIndex = c),
      (l[c] = u),
      l.pop(),
      (e._byClipCacheIndex = null);
    const d = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete d[p],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let o = r[t];
    o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      l = t[t.length - 1],
      u = e._cacheIndex;
    (l._cacheIndex = u),
      (t[u] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      i === void 0 &&
        ((i = new DT(new Float32Array(2), new Float32Array(2), 1, o8)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid;
    let o = typeof e == "string" ? Ph.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let u = null;
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = lx)),
      l !== void 0)
    ) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === i) return d;
      (u = l.knownActions[0]), o === null && (o = u._clip);
    }
    if (o === null) return null;
    const c = new KN(this, o, t, i);
    return this._bindAction(c, u), this._addInactiveAction(c, a, s), c;
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == "string" ? Ph.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let u = 0; u !== i; ++u) t[u]._update(r, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let u = 0; u !== l; ++u) a[u].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const u = o[a];
        this._deactivateAction(u);
        const c = u._cacheIndex,
          d = t[t.length - 1];
        (u._cacheIndex = null),
          (u._byClipCacheIndex = null),
          (d._cacheIndex = c),
          (t[c] = d),
          t.pop(),
          this._removeInactiveBindingsForAction(u);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class l8 extends ux {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isRenderTarget3D = !0),
      (this.depth = i),
      (this.texture = new cx(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class u8 extends ux {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isRenderTargetArray = !0),
      (this.depth = i),
      (this.texture = new zm(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class WT {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new WT(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let c8 = 0;
class f8 extends Zo {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: c8++ }),
      (this.name = ""),
      (this.usage = cm),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = Array.isArray(t[i]) ? t[i] : [t[i]];
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class h8 extends Vm {
  constructor(e, t, i = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class d8 {
  constructor(e, t, i, r, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const U2 = new _t();
class QN {
  constructor(e, t, i = 0, r = 1 / 0) {
    (this.ray = new Fc(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new oc()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      U2.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(U2),
      this
    );
  }
  intersectObject(e, t = !0, i = []) {
    return nw(e, this, i, t), i.sort(k2), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) nw(e[r], this, i, t);
    return i.sort(k2), i;
  }
}
function k2(n, e) {
  return n.distance - e.distance;
}
function nw(n, e, t, i) {
  let r = !0;
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (r = !1),
    r === !0 && i === !0)
  ) {
    const s = n.children;
    for (let o = 0, a = s.length; o < a; o++) nw(s[o], e, t, !0);
  }
}
class iw {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (this.phi = Rt(this.phi, 1e-6, Math.PI - 1e-6)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(Rt(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class p8 {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class XT {
  constructor(e, t, i, r) {
    (XT.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 4; i++) this.elements[i] = e[i + t];
    return this;
  }
  set(e, t, i, r) {
    const s = this.elements;
    return (s[0] = e), (s[2] = t), (s[1] = i), (s[3] = r), this;
  }
}
const z2 = new Ae();
class m8 {
  constructor(e = new Ae(1 / 0, 1 / 0), t = new Ae(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = z2.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, z2).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const H2 = new z(),
  Q0 = new z();
class g8 {
  constructor(e = new z(), t = new z()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    H2.subVectors(e, this.start), Q0.subVectors(this.end, this.start);
    const i = Q0.dot(Q0);
    let s = Q0.dot(H2) / i;
    return t && (s = Rt(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const G2 = new z();
class v8 extends qt {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const i = new Lt(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const u = (o / l) * Math.PI * 2,
        c = (a / l) * Math.PI * 2;
      r.push(Math.cos(u), Math.sin(u), 1, Math.cos(c), Math.sin(c), 1);
    }
    i.setAttribute("position", new ht(r, 3));
    const s = new ir({ fog: !1, toneMapped: !1 });
    (this.cone = new So(i, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      G2.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(G2),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const al = new z(),
  Z0 = new _t(),
  eS = new _t();
class y8 extends So {
  constructor(e) {
    const t = ZN(e),
      i = new Lt(),
      r = [],
      s = [],
      o = new Ze(0, 0, 1),
      a = new Ze(0, 1, 0);
    for (let u = 0; u < t.length; u++) {
      const c = t[u];
      c.parent &&
        c.parent.isBone &&
        (r.push(0, 0, 0),
        r.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new ht(r, 3)),
      i.setAttribute("color", new ht(s, 3));
    const l = new ir({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(i, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute("position");
    eS.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (Z0.multiplyMatrices(eS, a.matrixWorld),
        al.setFromMatrixPosition(Z0),
        r.setXYZ(o, al.x, al.y, al.z),
        Z0.multiplyMatrices(eS, a.parent.matrixWorld),
        al.setFromMatrixPosition(Z0),
        r.setXYZ(o + 1, al.x, al.y, al.z),
        (o += 2));
    }
    (i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function ZN(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, ZN(n.children[t]));
  return e;
}
class _8 extends qn {
  constructor(e, t, i) {
    const r = new Km(t, 4, 2),
      s = new hs({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s),
      (this.light = e),
      (this.color = i),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const x8 = new z(),
  V2 = new Ze(),
  W2 = new Ze();
class A8 extends qt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "HemisphereLightHelper");
    const r = new Ym(t);
    r.rotateY(Math.PI * 0.5),
      (this.material = new hs({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = r.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    r.setAttribute("color", new rn(o, 3)),
      this.add(new qn(r, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      V2.copy(this.light.color), W2.copy(this.light.groundColor);
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? V2 : W2;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(x8.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class S8 extends So {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    (i = new Ze(i)), (r = new Ze(r));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      l = [],
      u = [];
    for (let p = 0, m = 0, v = -a; p <= t; p++, v += o) {
      l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a);
      const _ = p === s ? i : r;
      _.toArray(u, m),
        (m += 3),
        _.toArray(u, m),
        (m += 3),
        _.toArray(u, m),
        (m += 3),
        _.toArray(u, m),
        (m += 3);
    }
    const c = new Lt();
    c.setAttribute("position", new ht(l, 3)),
      c.setAttribute("color", new ht(u, 3));
    const d = new ir({ vertexColors: !0, toneMapped: !1 });
    super(c, d), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class M8 extends So {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    (s = new Ze(s)), (o = new Ze(o));
    const a = [],
      l = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const p = (d / t) * (Math.PI * 2),
          m = Math.sin(p) * e,
          v = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(m, 0, v);
        const _ = d & 1 ? s : o;
        l.push(_.r, _.g, _.b), l.push(_.r, _.g, _.b);
      }
    for (let d = 0; d < i; d++) {
      const p = d & 1 ? s : o,
        m = e - (e / i) * d;
      for (let v = 0; v < r; v++) {
        let _ = (v / r) * (Math.PI * 2),
          x = Math.sin(_) * m,
          g = Math.cos(_) * m;
        a.push(x, 0, g),
          l.push(p.r, p.g, p.b),
          (_ = ((v + 1) / r) * (Math.PI * 2)),
          (x = Math.sin(_) * m),
          (g = Math.cos(_) * m),
          a.push(x, 0, g),
          l.push(p.r, p.g, p.b);
      }
    }
    const u = new Lt();
    u.setAttribute("position", new ht(a, 3)),
      u.setAttribute("color", new ht(l, 3));
    const c = new ir({ vertexColors: !0, toneMapped: !1 });
    super(u, c), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const X2 = new z(),
  q0 = new z(),
  J2 = new z();
class w8 extends qt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let r = new Lt();
    r.setAttribute(
      "position",
      new ht([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new ir({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new ka(r, s)),
      this.add(this.lightPlane),
      (r = new Lt()),
      r.setAttribute("position", new ht([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new ka(r, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      X2.setFromMatrixPosition(this.light.matrixWorld),
      q0.setFromMatrixPosition(this.light.target.matrixWorld),
      J2.subVectors(q0, X2),
      this.lightPlane.lookAt(q0),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(q0),
      (this.targetLine.scale.z = J2.length());
  }
}
const $0 = new z(),
  Hn = new Hm();
class E8 extends So {
  constructor(e) {
    const t = new Lt(),
      i = new ir({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(v, _) {
      l(v), l(_);
    }
    function l(v) {
      r.push(0, 0, 0),
        s.push(0, 0, 0),
        o[v] === void 0 && (o[v] = []),
        o[v].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new ht(r, 3)),
      t.setAttribute("color", new ht(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const u = new Ze(16755200),
      c = new Ze(16711680),
      d = new Ze(43775),
      p = new Ze(16777215),
      m = new Ze(3355443);
    this.setColors(u, c, d, p, m);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, i.r, i.g, i.b),
      a.setXYZ(33, i.r, i.g, i.b),
      a.setXYZ(34, i.r, i.g, i.b),
      a.setXYZ(35, i.r, i.g, i.b),
      a.setXYZ(36, i.r, i.g, i.b),
      a.setXYZ(37, i.r, i.g, i.b),
      a.setXYZ(38, r.r, r.g, r.b),
      a.setXYZ(39, r.r, r.g, r.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1;
    Hn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    const s = this.camera.coordinateSystem === po ? -1 : 0;
    Yn("c", t, e, Hn, 0, 0, s),
      Yn("t", t, e, Hn, 0, 0, 1),
      Yn("n1", t, e, Hn, -i, -r, s),
      Yn("n2", t, e, Hn, i, -r, s),
      Yn("n3", t, e, Hn, -i, r, s),
      Yn("n4", t, e, Hn, i, r, s),
      Yn("f1", t, e, Hn, -i, -r, 1),
      Yn("f2", t, e, Hn, i, -r, 1),
      Yn("f3", t, e, Hn, -i, r, 1),
      Yn("f4", t, e, Hn, i, r, 1),
      Yn("u1", t, e, Hn, i * 0.7, r * 1.1, s),
      Yn("u2", t, e, Hn, -i * 0.7, r * 1.1, s),
      Yn("u3", t, e, Hn, 0, r * 2, s),
      Yn("cf1", t, e, Hn, -i, 0, 1),
      Yn("cf2", t, e, Hn, i, 0, 1),
      Yn("cf3", t, e, Hn, 0, -r, 1),
      Yn("cf4", t, e, Hn, 0, r, 1),
      Yn("cn1", t, e, Hn, -i, 0, s),
      Yn("cn2", t, e, Hn, i, 0, s),
      Yn("cn3", t, e, Hn, 0, -r, s),
      Yn("cn4", t, e, Hn, 0, r, s),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Yn(n, e, t, i, r, s, o) {
  $0.set(r, s, o).unproject(i);
  const a = e[n];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let u = 0, c = a.length; u < c; u++) l.setXYZ(a[u], $0.x, $0.y, $0.z);
  }
}
const ev = new er();
class T8 extends So {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(8 * 3),
      s = new Lt();
    s.setIndex(new rn(i, 1)),
      s.setAttribute("position", new rn(r, 3)),
      super(s, new ir({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && ev.setFromObject(this.object),
      ev.isEmpty())
    )
      return;
    const t = ev.min,
      i = ev.max,
      r = this.geometry.attributes.position,
      s = r.array;
    (s[0] = i.x),
      (s[1] = i.y),
      (s[2] = i.z),
      (s[3] = t.x),
      (s[4] = i.y),
      (s[5] = i.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = i.z),
      (s[9] = i.x),
      (s[10] = t.y),
      (s[11] = i.z),
      (s[12] = i.x),
      (s[13] = i.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = i.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = i.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class C8 extends So {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new Lt();
    s.setIndex(new rn(i, 1)),
      s.setAttribute("position", new ht(r, 3)),
      super(s, new ir({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class b8 extends ka {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new Lt();
    o.setAttribute("position", new ht(s, 3)),
      o.computeBoundingSphere(),
      super(o, new ir({ color: r, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new Lt();
    l.setAttribute("position", new ht(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new qn(
          l,
          new hs({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const j2 = new z();
let tv, tS;
class R8 extends qt {
  constructor(
    e = new z(0, 0, 1),
    t = new z(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      tv === void 0 &&
        ((tv = new Lt()),
        tv.setAttribute("position", new ht([0, 0, 0, 0, 1, 0], 3)),
        (tS = new Yh(0, 0.5, 1, 5, 1)),
        tS.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new ka(tv, new ir({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new qn(tS, new hs({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      j2.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(j2, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class P8 extends So {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new Lt();
    r.setAttribute("position", new ht(t, 3)),
      r.setAttribute("color", new ht(i, 3));
    const s = new ir({ vertexColors: !0, toneMapped: !1 });
    super(r, s), (this.type = "AxesHelper");
  }
  setColors(e, t, i) {
    const r = new Ze(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class B8 {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Ze()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new dm()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(g) {
      const A = [];
      for (let S = 0, w = g.length; S < w; S++) {
        const C = g[S],
          b = new ac();
        (b.curves = C.curves), A.push(b);
      }
      return A;
    }
    function i(g, A) {
      const S = A.length;
      let w = !1;
      for (let C = S - 1, b = 0; b < S; C = b++) {
        let P = A[C],
          I = A[b],
          R = I.x - P.x,
          T = I.y - P.y;
        if (Math.abs(T) > Number.EPSILON) {
          if (
            (T < 0 && ((P = A[b]), (R = -R), (I = A[C]), (T = -T)),
            g.y < P.y || g.y > I.y)
          )
            continue;
          if (g.y === P.y) {
            if (g.x === P.x) return !0;
          } else {
            const D = T * (g.x - P.x) - R * (g.y - P.y);
            if (D === 0) return !0;
            if (D < 0) continue;
            w = !w;
          }
        } else {
          if (g.y !== P.y) continue;
          if ((I.x <= g.x && g.x <= P.x) || (P.x <= g.x && g.x <= I.x))
            return !0;
        }
      }
      return w;
    }
    const r = Xo.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const u = [];
    if (s.length === 1)
      return (a = s[0]), (l = new ac()), (l.curves = a.curves), u.push(l), u;
    let c = !r(s[0].getPoints());
    c = e ? !c : c;
    const d = [],
      p = [];
    let m = [],
      v = 0,
      _;
    (p[v] = void 0), (m[v] = []);
    for (let g = 0, A = s.length; g < A; g++)
      (a = s[g]),
        (_ = a.getPoints()),
        (o = r(_)),
        (o = e ? !o : o),
        o
          ? (!c && p[v] && v++,
            (p[v] = { s: new ac(), p: _ }),
            (p[v].s.curves = a.curves),
            c && v++,
            (m[v] = []))
          : m[v].push({ h: a, p: _[0] });
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let g = !1,
        A = 0;
      for (let S = 0, w = p.length; S < w; S++) d[S] = [];
      for (let S = 0, w = p.length; S < w; S++) {
        const C = m[S];
        for (let b = 0; b < C.length; b++) {
          const P = C[b];
          let I = !0;
          for (let R = 0; R < p.length; R++)
            i(P.p, p[R].p) &&
              (S !== R && A++, I ? ((I = !1), d[R].push(P)) : (g = !0));
          I && d[S].push(P);
        }
      }
      A > 0 && g === !1 && (m = d);
    }
    let x;
    for (let g = 0, A = p.length; g < A; g++) {
      (l = p[g].s), u.push(l), (x = m[g]);
      for (let S = 0, w = x.length; S < w; S++) l.holes.push(x[S].h);
    }
    return u;
  }
}
class I8 extends Zo {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
function D8(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2))
      : ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0)),
    n
  );
}
function L8(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0))
      : ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2)),
    n
  );
}
function F8(n) {
  return (
    (n.repeat.x = 1), (n.repeat.y = 1), (n.offset.x = 0), (n.offset.y = 0), n
  );
}
function rw(n, e, t, i) {
  const r = N8(i);
  switch (t) {
    case iT:
      return n * e;
    case sT:
      return n * e;
    case oT:
      return n * e * 2;
    case sx:
      return ((n * e) / r.components) * r.byteLength;
    case km:
      return ((n * e) / r.components) * r.byteLength;
    case aT:
      return ((n * e * 2) / r.components) * r.byteLength;
    case ox:
      return ((n * e * 2) / r.components) * r.byteLength;
    case rT:
      return ((n * e * 3) / r.components) * r.byteLength;
    case $i:
      return ((n * e * 4) / r.components) * r.byteLength;
    case ax:
      return ((n * e * 4) / r.components) * r.byteLength;
    case gp:
    case vp:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case yp:
    case _p:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ly:
    case Ny:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4;
    case Dy:
    case Fy:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2;
    case Oy:
    case Uy:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case ky:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case zy:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Hy:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Gy:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Vy:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Wy:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Xy:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Jy:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case jy:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Yy:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Ky:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Qy:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Zy:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case qy:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case $y:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case xp:
    case e_:
    case t_:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case lT:
    case n_:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case i_:
    case r_:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function N8(n) {
  switch (n) {
    case xo:
    case eT:
      return { byteLength: 1, components: 1 };
    case Eh:
    case tT:
    case jh:
      return { byteLength: 2, components: 1 };
    case ix:
    case rx:
      return { byteLength: 2, components: 4 };
    case Ua:
    case nx:
    case kr:
      return { byteLength: 4, components: 1 };
    case nT:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
const O8 = { contain: D8, cover: L8, fill: F8, getByteLength: rw };
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Xh } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Xh));
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function qN() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, o) {
    t(s, o), (i = n.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function U8(n) {
  const e = new WeakMap();
  function t(a, l) {
    const u = a.array,
      c = a.usage,
      d = u.byteLength,
      p = n.createBuffer();
    n.bindBuffer(l, p), n.bufferData(l, u, c), a.onUploadCallback();
    let m;
    if (u instanceof Float32Array) m = n.FLOAT;
    else if (u instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (m = n.HALF_FLOAT) : (m = n.UNSIGNED_SHORT);
    else if (u instanceof Int16Array) m = n.SHORT;
    else if (u instanceof Uint32Array) m = n.UNSIGNED_INT;
    else if (u instanceof Int32Array) m = n.INT;
    else if (u instanceof Int8Array) m = n.BYTE;
    else if (u instanceof Uint8Array) m = n.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray) m = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + u
      );
    return {
      buffer: p,
      type: m,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: a.version,
      size: d,
    };
  }
  function i(a, l, u) {
    const c = l.array,
      d = l.updateRanges;
    if ((n.bindBuffer(u, a), d.length === 0)) n.bufferSubData(u, 0, c);
    else {
      d.sort((m, v) => m.start - v.start);
      let p = 0;
      for (let m = 1; m < d.length; m++) {
        const v = d[p],
          _ = d[m];
        _.start <= v.start + v.count + 1
          ? (v.count = Math.max(v.count, _.start + _.count - v.start))
          : (++p, (d[p] = _));
      }
      d.length = p + 1;
      for (let m = 0, v = d.length; m < v; m++) {
        const _ = d[m];
        n.bufferSubData(u, _.start * c.BYTES_PER_ELEMENT, c, _.start, _.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function r(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function s(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (n.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (
      (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute)
    ) {
      const c = e.get(a);
      (!c || c.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        });
      return;
    }
    const u = e.get(a);
    if (u === void 0) e.set(a, t(a, l));
    else if (u.version < a.version) {
      if (u.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      i(u.buffer, a, l), (u.version = a.version);
    }
  }
  return { get: r, remove: s, update: o };
}
var k8 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  z8 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  H8 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  G8 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  V8 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  W8 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  X8 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  J8 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  j8 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  Y8 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  K8 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  Q8 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Z8 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  q8 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  $8 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  e6 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  t6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  n6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  i6 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  r6 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  s6 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  o6 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  a6 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  l6 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  u6 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  c6 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  f6 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  h6 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  d6 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  p6 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  m6 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  g6 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  v6 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  y6 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  _6 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  x6 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  A6 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  S6 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  M6 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  w6 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  E6 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  T6 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  C6 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  b6 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  R6 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  P6 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  B6 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  I6 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  D6 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  L6 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  F6 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  N6 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  O6 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  U6 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  k6 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  z6 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  H6 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  G6 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  V6 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  W6 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  X6 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  J6 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  j6 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Y6 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  K6 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Q6 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Z6 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  q6 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  $6 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  eW = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  tW = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  nW = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  iW = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  rW = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  sW = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  oW = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  aW = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  lW = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  uW = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  cW = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  fW = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  hW = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  dW = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  pW = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  mW = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  gW = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  vW = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  yW = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  _W = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  xW = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  AW = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  SW = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  MW = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  wW = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  EW = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  TW = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  CW = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  bW = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  RW = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  PW = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  BW = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  IW = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  DW = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  LW = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  FW = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  NW = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  OW = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const UW = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  kW = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  zW = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  HW = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  GW = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  VW = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  WW = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  XW = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  JW = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  jW = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  YW = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  KW = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  QW = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  ZW = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  qW = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  $W = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  e7 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  t7 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  n7 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  i7 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  r7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  s7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  o7 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  a7 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  l7 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  u7 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  c7 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  f7 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  h7 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  d7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  p7 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  m7 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  g7 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  v7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Nt = {
    alphahash_fragment: k8,
    alphahash_pars_fragment: z8,
    alphamap_fragment: H8,
    alphamap_pars_fragment: G8,
    alphatest_fragment: V8,
    alphatest_pars_fragment: W8,
    aomap_fragment: X8,
    aomap_pars_fragment: J8,
    batching_pars_vertex: j8,
    batching_vertex: Y8,
    begin_vertex: K8,
    beginnormal_vertex: Q8,
    bsdfs: Z8,
    iridescence_fragment: q8,
    bumpmap_pars_fragment: $8,
    clipping_planes_fragment: e6,
    clipping_planes_pars_fragment: t6,
    clipping_planes_pars_vertex: n6,
    clipping_planes_vertex: i6,
    color_fragment: r6,
    color_pars_fragment: s6,
    color_pars_vertex: o6,
    color_vertex: a6,
    common: l6,
    cube_uv_reflection_fragment: u6,
    defaultnormal_vertex: c6,
    displacementmap_pars_vertex: f6,
    displacementmap_vertex: h6,
    emissivemap_fragment: d6,
    emissivemap_pars_fragment: p6,
    colorspace_fragment: m6,
    colorspace_pars_fragment: g6,
    envmap_fragment: v6,
    envmap_common_pars_fragment: y6,
    envmap_pars_fragment: _6,
    envmap_pars_vertex: x6,
    envmap_physical_pars_fragment: B6,
    envmap_vertex: A6,
    fog_vertex: S6,
    fog_pars_vertex: M6,
    fog_fragment: w6,
    fog_pars_fragment: E6,
    gradientmap_pars_fragment: T6,
    lightmap_pars_fragment: C6,
    lights_lambert_fragment: b6,
    lights_lambert_pars_fragment: R6,
    lights_pars_begin: P6,
    lights_toon_fragment: I6,
    lights_toon_pars_fragment: D6,
    lights_phong_fragment: L6,
    lights_phong_pars_fragment: F6,
    lights_physical_fragment: N6,
    lights_physical_pars_fragment: O6,
    lights_fragment_begin: U6,
    lights_fragment_maps: k6,
    lights_fragment_end: z6,
    logdepthbuf_fragment: H6,
    logdepthbuf_pars_fragment: G6,
    logdepthbuf_pars_vertex: V6,
    logdepthbuf_vertex: W6,
    map_fragment: X6,
    map_pars_fragment: J6,
    map_particle_fragment: j6,
    map_particle_pars_fragment: Y6,
    metalnessmap_fragment: K6,
    metalnessmap_pars_fragment: Q6,
    morphinstance_vertex: Z6,
    morphcolor_vertex: q6,
    morphnormal_vertex: $6,
    morphtarget_pars_vertex: eW,
    morphtarget_vertex: tW,
    normal_fragment_begin: nW,
    normal_fragment_maps: iW,
    normal_pars_fragment: rW,
    normal_pars_vertex: sW,
    normal_vertex: oW,
    normalmap_pars_fragment: aW,
    clearcoat_normal_fragment_begin: lW,
    clearcoat_normal_fragment_maps: uW,
    clearcoat_pars_fragment: cW,
    iridescence_pars_fragment: fW,
    opaque_fragment: hW,
    packing: dW,
    premultiplied_alpha_fragment: pW,
    project_vertex: mW,
    dithering_fragment: gW,
    dithering_pars_fragment: vW,
    roughnessmap_fragment: yW,
    roughnessmap_pars_fragment: _W,
    shadowmap_pars_fragment: xW,
    shadowmap_pars_vertex: AW,
    shadowmap_vertex: SW,
    shadowmask_pars_fragment: MW,
    skinbase_vertex: wW,
    skinning_pars_vertex: EW,
    skinning_vertex: TW,
    skinnormal_vertex: CW,
    specularmap_fragment: bW,
    specularmap_pars_fragment: RW,
    tonemapping_fragment: PW,
    tonemapping_pars_fragment: BW,
    transmission_fragment: IW,
    transmission_pars_fragment: DW,
    uv_pars_fragment: LW,
    uv_pars_vertex: FW,
    uv_vertex: NW,
    worldpos_vertex: OW,
    background_vert: UW,
    background_frag: kW,
    backgroundCube_vert: zW,
    backgroundCube_frag: HW,
    cube_vert: GW,
    cube_frag: VW,
    depth_vert: WW,
    depth_frag: XW,
    distanceRGBA_vert: JW,
    distanceRGBA_frag: jW,
    equirect_vert: YW,
    equirect_frag: KW,
    linedashed_vert: QW,
    linedashed_frag: ZW,
    meshbasic_vert: qW,
    meshbasic_frag: $W,
    meshlambert_vert: e7,
    meshlambert_frag: t7,
    meshmatcap_vert: n7,
    meshmatcap_frag: i7,
    meshnormal_vert: r7,
    meshnormal_frag: s7,
    meshphong_vert: o7,
    meshphong_frag: a7,
    meshphysical_vert: l7,
    meshphysical_frag: u7,
    meshtoon_vert: c7,
    meshtoon_frag: f7,
    points_vert: h7,
    points_frag: d7,
    shadow_vert: p7,
    shadow_frag: m7,
    sprite_vert: g7,
    sprite_frag: v7,
  },
  Qe = {
    common: {
      diffuse: { value: new Ze(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new It() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new It() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new It() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new It() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new It() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new It() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new It() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new It() },
      normalScale: { value: new Ae(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new It() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new It() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new It() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new It() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Ze(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Ze(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new It() },
      alphaTest: { value: 0 },
      uvTransform: { value: new It() },
    },
    sprite: {
      diffuse: { value: new Ze(16777215) },
      opacity: { value: 1 },
      center: { value: new Ae(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new It() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new It() },
      alphaTest: { value: 0 },
    },
  },
  ho = {
    basic: {
      uniforms: fr([
        Qe.common,
        Qe.specularmap,
        Qe.envmap,
        Qe.aomap,
        Qe.lightmap,
        Qe.fog,
      ]),
      vertexShader: Nt.meshbasic_vert,
      fragmentShader: Nt.meshbasic_frag,
    },
    lambert: {
      uniforms: fr([
        Qe.common,
        Qe.specularmap,
        Qe.envmap,
        Qe.aomap,
        Qe.lightmap,
        Qe.emissivemap,
        Qe.bumpmap,
        Qe.normalmap,
        Qe.displacementmap,
        Qe.fog,
        Qe.lights,
        { emissive: { value: new Ze(0) } },
      ]),
      vertexShader: Nt.meshlambert_vert,
      fragmentShader: Nt.meshlambert_frag,
    },
    phong: {
      uniforms: fr([
        Qe.common,
        Qe.specularmap,
        Qe.envmap,
        Qe.aomap,
        Qe.lightmap,
        Qe.emissivemap,
        Qe.bumpmap,
        Qe.normalmap,
        Qe.displacementmap,
        Qe.fog,
        Qe.lights,
        {
          emissive: { value: new Ze(0) },
          specular: { value: new Ze(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Nt.meshphong_vert,
      fragmentShader: Nt.meshphong_frag,
    },
    standard: {
      uniforms: fr([
        Qe.common,
        Qe.envmap,
        Qe.aomap,
        Qe.lightmap,
        Qe.emissivemap,
        Qe.bumpmap,
        Qe.normalmap,
        Qe.displacementmap,
        Qe.roughnessmap,
        Qe.metalnessmap,
        Qe.fog,
        Qe.lights,
        {
          emissive: { value: new Ze(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Nt.meshphysical_vert,
      fragmentShader: Nt.meshphysical_frag,
    },
    toon: {
      uniforms: fr([
        Qe.common,
        Qe.aomap,
        Qe.lightmap,
        Qe.emissivemap,
        Qe.bumpmap,
        Qe.normalmap,
        Qe.displacementmap,
        Qe.gradientmap,
        Qe.fog,
        Qe.lights,
        { emissive: { value: new Ze(0) } },
      ]),
      vertexShader: Nt.meshtoon_vert,
      fragmentShader: Nt.meshtoon_frag,
    },
    matcap: {
      uniforms: fr([
        Qe.common,
        Qe.bumpmap,
        Qe.normalmap,
        Qe.displacementmap,
        Qe.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Nt.meshmatcap_vert,
      fragmentShader: Nt.meshmatcap_frag,
    },
    points: {
      uniforms: fr([Qe.points, Qe.fog]),
      vertexShader: Nt.points_vert,
      fragmentShader: Nt.points_frag,
    },
    dashed: {
      uniforms: fr([
        Qe.common,
        Qe.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Nt.linedashed_vert,
      fragmentShader: Nt.linedashed_frag,
    },
    depth: {
      uniforms: fr([Qe.common, Qe.displacementmap]),
      vertexShader: Nt.depth_vert,
      fragmentShader: Nt.depth_frag,
    },
    normal: {
      uniforms: fr([
        Qe.common,
        Qe.bumpmap,
        Qe.normalmap,
        Qe.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Nt.meshnormal_vert,
      fragmentShader: Nt.meshnormal_frag,
    },
    sprite: {
      uniforms: fr([Qe.sprite, Qe.fog]),
      vertexShader: Nt.sprite_vert,
      fragmentShader: Nt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new It() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Nt.background_vert,
      fragmentShader: Nt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new It() },
      },
      vertexShader: Nt.backgroundCube_vert,
      fragmentShader: Nt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Nt.cube_vert,
      fragmentShader: Nt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Nt.equirect_vert,
      fragmentShader: Nt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: fr([
        Qe.common,
        Qe.displacementmap,
        {
          referencePosition: { value: new z() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Nt.distanceRGBA_vert,
      fragmentShader: Nt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: fr([
        Qe.lights,
        Qe.fog,
        { color: { value: new Ze(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Nt.shadow_vert,
      fragmentShader: Nt.shadow_frag,
    },
  };
ho.physical = {
  uniforms: fr([
    ho.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new It() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new It() },
      clearcoatNormalScale: { value: new Ae(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new It() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new It() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new It() },
      sheen: { value: 0 },
      sheenColor: { value: new Ze(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new It() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new It() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new It() },
      transmissionSamplerSize: { value: new Ae() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new It() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Ze(0) },
      specularColor: { value: new Ze(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new It() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new It() },
      anisotropyVector: { value: new Ae() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new It() },
    },
  ]),
  vertexShader: Nt.meshphysical_vert,
  fragmentShader: Nt.meshphysical_frag,
};
const nv = { r: 0, b: 0, g: 0 },
  Au = new ys(),
  y7 = new _t();
function _7(n, e, t, i, r, s, o) {
  const a = new Ze(0);
  let l = s === !0 ? 0 : 1,
    u,
    c,
    d = null,
    p = 0,
    m = null;
  function v(S) {
    let w = S.isScene === !0 ? S.background : null;
    return (
      w && w.isTexture && (w = (S.backgroundBlurriness > 0 ? t : e).get(w)), w
    );
  }
  function _(S) {
    let w = !1;
    const C = v(S);
    C === null ? g(a, l) : C && C.isColor && (g(C, 1), (w = !0));
    const b = n.xr.getEnvironmentBlendMode();
    b === "additive"
      ? i.buffers.color.setClear(0, 0, 0, 1, o)
      : b === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || w) &&
        (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }
  function x(S, w) {
    const C = v(w);
    C && (C.isCubeTexture || C.mapping === Jh)
      ? (c === void 0 &&
          ((c = new qn(
            new Nc(1, 1, 1),
            new Ao({
              name: "BackgroundCubeMaterial",
              uniforms: Rh(ho.backgroundCube.uniforms),
              vertexShader: ho.backgroundCube.vertexShader,
              fragmentShader: ho.backgroundCube.fragmentShader,
              side: Ar,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          c.geometry.deleteAttribute("normal"),
          c.geometry.deleteAttribute("uv"),
          (c.onBeforeRender = function (b, P, I) {
            this.matrixWorld.copyPosition(I.matrixWorld);
          }),
          Object.defineProperty(c.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          r.update(c)),
        Au.copy(w.backgroundRotation),
        (Au.x *= -1),
        (Au.y *= -1),
        (Au.z *= -1),
        C.isCubeTexture &&
          C.isRenderTargetTexture === !1 &&
          ((Au.y *= -1), (Au.z *= -1)),
        (c.material.uniforms.envMap.value = C),
        (c.material.uniforms.flipEnvMap.value =
          C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1),
        (c.material.uniforms.backgroundBlurriness.value =
          w.backgroundBlurriness),
        (c.material.uniforms.backgroundIntensity.value = w.backgroundIntensity),
        c.material.uniforms.backgroundRotation.value.setFromMatrix4(
          y7.makeRotationFromEuler(Au)
        ),
        (c.material.toneMapped = en.getTransfer(C.colorSpace) !== pn),
        (d !== C || p !== C.version || m !== n.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (d = C),
          (p = C.version),
          (m = n.toneMapping)),
        c.layers.enableAll(),
        S.unshift(c, c.geometry, c.material, 0, 0, null))
      : C &&
        C.isTexture &&
        (u === void 0 &&
          ((u = new qn(
            new Kh(2, 2),
            new Ao({
              name: "BackgroundMaterial",
              uniforms: Rh(ho.background.uniforms),
              vertexShader: ho.background.vertexShader,
              fragmentShader: ho.background.fragmentShader,
              side: Yo,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          u.geometry.deleteAttribute("normal"),
          Object.defineProperty(u.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          r.update(u)),
        (u.material.uniforms.t2D.value = C),
        (u.material.uniforms.backgroundIntensity.value = w.backgroundIntensity),
        (u.material.toneMapped = en.getTransfer(C.colorSpace) !== pn),
        C.matrixAutoUpdate === !0 && C.updateMatrix(),
        u.material.uniforms.uvTransform.value.copy(C.matrix),
        (d !== C || p !== C.version || m !== n.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (d = C),
          (p = C.version),
          (m = n.toneMapping)),
        u.layers.enableAll(),
        S.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function g(S, w) {
    S.getRGB(nv, lN(n)), i.buffers.color.setClear(nv.r, nv.g, nv.b, w, o);
  }
  function A() {
    c !== void 0 && (c.geometry.dispose(), c.material.dispose()),
      u !== void 0 && (u.geometry.dispose(), u.material.dispose());
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (S, w = 1) {
      a.set(S), (l = w), g(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (S) {
      (l = S), g(a, l);
    },
    render: _,
    addToRenderList: x,
    dispose: A,
  };
}
function x7(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    i = {},
    r = p(null);
  let s = r,
    o = !1;
  function a(T, D, G, W, q) {
    let Z = !1;
    const K = d(W, G, D);
    s !== K && ((s = K), u(s.object)),
      (Z = m(T, W, G, q)),
      Z && v(T, W, G, q),
      q !== null && e.update(q, n.ELEMENT_ARRAY_BUFFER),
      (Z || o) &&
        ((o = !1),
        w(T, D, G, W),
        q !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(q).buffer));
  }
  function l() {
    return n.createVertexArray();
  }
  function u(T) {
    return n.bindVertexArray(T);
  }
  function c(T) {
    return n.deleteVertexArray(T);
  }
  function d(T, D, G) {
    const W = G.wireframe === !0;
    let q = i[T.id];
    q === void 0 && ((q = {}), (i[T.id] = q));
    let Z = q[D.id];
    Z === void 0 && ((Z = {}), (q[D.id] = Z));
    let K = Z[W];
    return K === void 0 && ((K = p(l())), (Z[W] = K)), K;
  }
  function p(T) {
    const D = [],
      G = [],
      W = [];
    for (let q = 0; q < t; q++) (D[q] = 0), (G[q] = 0), (W[q] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: D,
      enabledAttributes: G,
      attributeDivisors: W,
      object: T,
      attributes: {},
      index: null,
    };
  }
  function m(T, D, G, W) {
    const q = s.attributes,
      Z = D.attributes;
    let K = 0;
    const te = G.getAttributes();
    for (const O in te)
      if (te[O].location >= 0) {
        const F = q[O];
        let se = Z[O];
        if (
          (se === void 0 &&
            (O === "instanceMatrix" &&
              T.instanceMatrix &&
              (se = T.instanceMatrix),
            O === "instanceColor" && T.instanceColor && (se = T.instanceColor)),
          F === void 0 || F.attribute !== se || (se && F.data !== se.data))
        )
          return !0;
        K++;
      }
    return s.attributesNum !== K || s.index !== W;
  }
  function v(T, D, G, W) {
    const q = {},
      Z = D.attributes;
    let K = 0;
    const te = G.getAttributes();
    for (const O in te)
      if (te[O].location >= 0) {
        let F = Z[O];
        F === void 0 &&
          (O === "instanceMatrix" && T.instanceMatrix && (F = T.instanceMatrix),
          O === "instanceColor" && T.instanceColor && (F = T.instanceColor));
        const se = {};
        (se.attribute = F), F && F.data && (se.data = F.data), (q[O] = se), K++;
      }
    (s.attributes = q), (s.attributesNum = K), (s.index = W);
  }
  function _() {
    const T = s.newAttributes;
    for (let D = 0, G = T.length; D < G; D++) T[D] = 0;
  }
  function x(T) {
    g(T, 0);
  }
  function g(T, D) {
    const G = s.newAttributes,
      W = s.enabledAttributes,
      q = s.attributeDivisors;
    (G[T] = 1),
      W[T] === 0 && (n.enableVertexAttribArray(T), (W[T] = 1)),
      q[T] !== D && (n.vertexAttribDivisor(T, D), (q[T] = D));
  }
  function A() {
    const T = s.newAttributes,
      D = s.enabledAttributes;
    for (let G = 0, W = D.length; G < W; G++)
      D[G] !== T[G] && (n.disableVertexAttribArray(G), (D[G] = 0));
  }
  function S(T, D, G, W, q, Z, K) {
    K === !0
      ? n.vertexAttribIPointer(T, D, G, q, Z)
      : n.vertexAttribPointer(T, D, G, W, q, Z);
  }
  function w(T, D, G, W) {
    _();
    const q = W.attributes,
      Z = G.getAttributes(),
      K = D.defaultAttributeValues;
    for (const te in Z) {
      const O = Z[te];
      if (O.location >= 0) {
        let Y = q[te];
        if (
          (Y === void 0 &&
            (te === "instanceMatrix" &&
              T.instanceMatrix &&
              (Y = T.instanceMatrix),
            te === "instanceColor" && T.instanceColor && (Y = T.instanceColor)),
          Y !== void 0)
        ) {
          const F = Y.normalized,
            se = Y.itemSize,
            Me = e.get(Y);
          if (Me === void 0) continue;
          const De = Me.buffer,
            re = Me.type,
            xe = Me.bytesPerElement,
            Ce = re === n.INT || re === n.UNSIGNED_INT || Y.gpuType === nx;
          if (Y.isInterleavedBufferAttribute) {
            const Se = Y.data,
              Xe = Se.stride,
              et = Y.offset;
            if (Se.isInstancedInterleavedBuffer) {
              for (let Ye = 0; Ye < O.locationSize; Ye++)
                g(O.location + Ye, Se.meshPerAttribute);
              T.isInstancedMesh !== !0 &&
                W._maxInstanceCount === void 0 &&
                (W._maxInstanceCount = Se.meshPerAttribute * Se.count);
            } else
              for (let Ye = 0; Ye < O.locationSize; Ye++) x(O.location + Ye);
            n.bindBuffer(n.ARRAY_BUFFER, De);
            for (let Ye = 0; Ye < O.locationSize; Ye++)
              S(
                O.location + Ye,
                se / O.locationSize,
                re,
                F,
                Xe * xe,
                (et + (se / O.locationSize) * Ye) * xe,
                Ce
              );
          } else {
            if (Y.isInstancedBufferAttribute) {
              for (let Se = 0; Se < O.locationSize; Se++)
                g(O.location + Se, Y.meshPerAttribute);
              T.isInstancedMesh !== !0 &&
                W._maxInstanceCount === void 0 &&
                (W._maxInstanceCount = Y.meshPerAttribute * Y.count);
            } else
              for (let Se = 0; Se < O.locationSize; Se++) x(O.location + Se);
            n.bindBuffer(n.ARRAY_BUFFER, De);
            for (let Se = 0; Se < O.locationSize; Se++)
              S(
                O.location + Se,
                se / O.locationSize,
                re,
                F,
                se * xe,
                (se / O.locationSize) * Se * xe,
                Ce
              );
          }
        } else if (K !== void 0) {
          const F = K[te];
          if (F !== void 0)
            switch (F.length) {
              case 2:
                n.vertexAttrib2fv(O.location, F);
                break;
              case 3:
                n.vertexAttrib3fv(O.location, F);
                break;
              case 4:
                n.vertexAttrib4fv(O.location, F);
                break;
              default:
                n.vertexAttrib1fv(O.location, F);
            }
        }
      }
    }
    A();
  }
  function C() {
    I();
    for (const T in i) {
      const D = i[T];
      for (const G in D) {
        const W = D[G];
        for (const q in W) c(W[q].object), delete W[q];
        delete D[G];
      }
      delete i[T];
    }
  }
  function b(T) {
    if (i[T.id] === void 0) return;
    const D = i[T.id];
    for (const G in D) {
      const W = D[G];
      for (const q in W) c(W[q].object), delete W[q];
      delete D[G];
    }
    delete i[T.id];
  }
  function P(T) {
    for (const D in i) {
      const G = i[D];
      if (G[T.id] === void 0) continue;
      const W = G[T.id];
      for (const q in W) c(W[q].object), delete W[q];
      delete G[T.id];
    }
  }
  function I() {
    R(), (o = !0), s !== r && ((s = r), u(s.object));
  }
  function R() {
    (r.geometry = null), (r.program = null), (r.wireframe = !1);
  }
  return {
    setup: a,
    reset: I,
    resetDefaultState: R,
    dispose: C,
    releaseStatesOfGeometry: b,
    releaseStatesOfProgram: P,
    initAttributes: _,
    enableAttribute: x,
    disableUnusedAttributes: A,
  };
}
function A7(n, e, t) {
  let i;
  function r(u) {
    i = u;
  }
  function s(u, c) {
    n.drawArrays(i, u, c), t.update(c, i, 1);
  }
  function o(u, c, d) {
    d !== 0 && (n.drawArraysInstanced(i, u, c, d), t.update(c, i, d));
  }
  function a(u, c, d) {
    if (d === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, u, 0, c, 0, d);
    let m = 0;
    for (let v = 0; v < d; v++) m += c[v];
    t.update(m, i, 1);
  }
  function l(u, c, d, p) {
    if (d === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let v = 0; v < u.length; v++) o(u[v], c[v], p[v]);
    else {
      m.multiDrawArraysInstancedWEBGL(i, u, 0, c, 0, p, 0, d);
      let v = 0;
      for (let _ = 0; _ < d; _++) v += c[_] * p[_];
      t.update(v, i, 1);
    }
  }
  (this.setMode = r),
    (this.render = s),
    (this.renderInstances = o),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = l);
}
function S7(n, e, t, i) {
  let r;
  function s() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const P = e.get("EXT_texture_filter_anisotropic");
      r = n.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function o(P) {
    return !(
      P !== $i &&
      i.convert(P) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function a(P) {
    const I =
      P === jh &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      P !== xo &&
      i.convert(P) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      P !== kr &&
      !I
    );
  }
  function l(P) {
    if (P === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      P = "mediump";
    }
    return P === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let u = t.precision !== void 0 ? t.precision : "highp";
  const c = l(u);
  c !== u &&
    (console.warn(
      "THREE.WebGLRenderer:",
      u,
      "not supported, using",
      c,
      "instead."
    ),
    (u = c));
  const d = t.logarithmicDepthBuffer === !0,
    p = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
    m = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    v = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    _ = n.getParameter(n.MAX_TEXTURE_SIZE),
    x = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    g = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    A = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    S = n.getParameter(n.MAX_VARYING_VECTORS),
    w = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    C = v > 0,
    b = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: u,
    logarithmicDepthBuffer: d,
    reverseDepthBuffer: p,
    maxTextures: m,
    maxVertexTextures: v,
    maxTextureSize: _,
    maxCubemapSize: x,
    maxAttributes: g,
    maxVertexUniforms: A,
    maxVaryings: S,
    maxFragmentUniforms: w,
    vertexTextures: C,
    maxSamples: b,
  };
}
function M7(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new ma(),
    a = new It(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, p) {
      const m = d.length !== 0 || p || i !== 0 || r;
      return (r = p), (i = d.length), m;
    }),
    (this.beginShadows = function () {
      (s = !0), c(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (d, p) {
      t = c(d, p, 0);
    }),
    (this.setState = function (d, p, m) {
      const v = d.clippingPlanes,
        _ = d.clipIntersection,
        x = d.clipShadows,
        g = n.get(d);
      if (!r || v === null || v.length === 0 || (s && !x)) s ? c(null) : u();
      else {
        const A = s ? 0 : i,
          S = A * 4;
        let w = g.clippingState || null;
        (l.value = w), (w = c(v, p, S, m));
        for (let C = 0; C !== S; ++C) w[C] = t[C];
        (g.clippingState = w),
          (this.numIntersection = _ ? this.numPlanes : 0),
          (this.numPlanes += A);
      }
    });
  function u() {
    l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function c(d, p, m, v) {
    const _ = d !== null ? d.length : 0;
    let x = null;
    if (_ !== 0) {
      if (((x = l.value), v !== !0 || x === null)) {
        const g = m + _ * 4,
          A = p.matrixWorldInverse;
        a.getNormalMatrix(A),
          (x === null || x.length < g) && (x = new Float32Array(g));
        for (let S = 0, w = m; S !== _; ++S, w += 4)
          o.copy(d[S]).applyMatrix4(A, a),
            o.normal.toArray(x, w),
            (x[w + 3] = o.constant);
      }
      (l.value = x), (l.needsUpdate = !0);
    }
    return (e.numPlanes = _), (e.numIntersection = 0), x;
  }
}
function w7(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === om ? (o.mapping = Oa) : a === am && (o.mapping = kl), o;
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === om || a === am)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const u = new gT(l.height);
            return (
              u.fromEquirectangularTexture(n, o),
              e.set(o, u),
              o.addEventListener("dispose", r),
              t(u.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
const jf = 4,
  Y2 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  ku = 20,
  nS = new yo(),
  K2 = new Ze();
let iS = null,
  rS = 0,
  sS = 0,
  oS = !1;
const Du = (1 + Math.sqrt(5)) / 2,
  Af = 1 / Du,
  Q2 = [
    new z(-Du, Af, 0),
    new z(Du, Af, 0),
    new z(-Af, 0, Du),
    new z(Af, 0, Du),
    new z(0, Du, -Af),
    new z(0, Du, Af),
    new z(-1, 1, -1),
    new z(1, 1, -1),
    new z(-1, 1, 1),
    new z(1, 1, 1),
  ];
class sw {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    (iS = this._renderer.getRenderTarget()),
      (rS = this._renderer.getActiveCubeFace()),
      (sS = this._renderer.getActiveMipmapLevel()),
      (oS = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = $2()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = q2()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(iS, rS, sS),
      (this._renderer.xr.enabled = oS),
      (e.scissorTest = !1),
      iv(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Oa || e.mapping === kl
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (iS = this._renderer.getRenderTarget()),
      (rS = this._renderer.getActiveCubeFace()),
      (sS = this._renderer.getActiveMipmapLevel()),
      (oS = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: Zn,
        minFilter: Zn,
        generateMipmaps: !1,
        type: jh,
        format: $i,
        colorSpace: Mc,
        depthBuffer: !1,
      },
      r = Z2(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Z2(e, t, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = E7(s)),
        (this._blurMaterial = T7(s, e, t));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new qn(this._lodPlanes[0], e);
    this._renderer.compile(t, nS);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new bn(90, 1, t, i),
      l = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      c = this._renderer,
      d = c.autoClear,
      p = c.toneMapping;
    c.getClearColor(K2), (c.toneMapping = Vo), (c.autoClear = !1);
    const m = new hs({
        name: "PMREM.Background",
        side: Ar,
        depthWrite: !1,
        depthTest: !1,
      }),
      v = new qn(new Nc(), m);
    let _ = !1;
    const x = e.background;
    x
      ? x.isColor && (m.color.copy(x), (e.background = null), (_ = !0))
      : (m.color.copy(K2), (_ = !0));
    for (let g = 0; g < 6; g++) {
      const A = g % 3;
      A === 0
        ? (a.up.set(0, l[g], 0), a.lookAt(u[g], 0, 0))
        : A === 1
        ? (a.up.set(0, 0, l[g]), a.lookAt(0, u[g], 0))
        : (a.up.set(0, l[g], 0), a.lookAt(0, 0, u[g]));
      const S = this._cubeSize;
      iv(r, A * S, g > 2 ? S : 0, S, S),
        c.setRenderTarget(r),
        _ && c.render(v, a),
        c.render(e, a);
    }
    v.geometry.dispose(),
      v.material.dispose(),
      (c.toneMapping = p),
      (c.autoClear = d),
      (e.background = x);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === Oa || e.mapping === kl;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = $2()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = q2());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new qn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    iv(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, nS);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let s = 1; s < r; s++) {
      const o = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1]
        ),
        a = Q2[(r - s - 1) % Q2.length];
      this._blur(e, s - 1, s, o, a);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer,
      u = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const c = 3,
      d = new qn(this._lodPlanes[r], u),
      p = u.uniforms,
      m = this._sizeLods[i] - 1,
      v = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * ku - 1),
      _ = s / v,
      x = isFinite(s) ? 1 + Math.floor(c * _) : ku;
    x > ku &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${ku}`
      );
    const g = [];
    let A = 0;
    for (let P = 0; P < ku; ++P) {
      const I = P / _,
        R = Math.exp((-I * I) / 2);
      g.push(R), P === 0 ? (A += R) : P < x && (A += 2 * R);
    }
    for (let P = 0; P < g.length; P++) g[P] = g[P] / A;
    (p.envMap.value = e.texture),
      (p.samples.value = x),
      (p.weights.value = g),
      (p.latitudinal.value = o === "latitudinal"),
      a && (p.poleAxis.value = a);
    const { _lodMax: S } = this;
    (p.dTheta.value = v), (p.mipInt.value = S - i);
    const w = this._sizeLods[r],
      C = 3 * w * (r > S - jf ? r - S + jf : 0),
      b = 4 * (this._cubeSize - w);
    iv(t, C, b, 3 * w, 2 * w), l.setRenderTarget(t), l.render(d, nS);
  }
}
function E7(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - jf + 1 + Y2.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let l = 1 / a;
    o > n - jf ? (l = Y2[o - n + jf - 1]) : o === 0 && (l = 0), i.push(l);
    const u = 1 / (a - 2),
      c = -u,
      d = 1 + u,
      p = [c, c, d, c, d, d, c, c, d, d, c, d],
      m = 6,
      v = 6,
      _ = 3,
      x = 2,
      g = 1,
      A = new Float32Array(_ * v * m),
      S = new Float32Array(x * v * m),
      w = new Float32Array(g * v * m);
    for (let b = 0; b < m; b++) {
      const P = ((b % 3) * 2) / 3 - 1,
        I = b > 2 ? 0 : -1,
        R = [
          P,
          I,
          0,
          P + 2 / 3,
          I,
          0,
          P + 2 / 3,
          I + 1,
          0,
          P,
          I,
          0,
          P + 2 / 3,
          I + 1,
          0,
          P,
          I + 1,
          0,
        ];
      A.set(R, _ * v * b), S.set(p, x * v * b);
      const T = [b, b, b, b, b, b];
      w.set(T, g * v * b);
    }
    const C = new Lt();
    C.setAttribute("position", new rn(A, _)),
      C.setAttribute("uv", new rn(S, x)),
      C.setAttribute("faceIndex", new rn(w, g)),
      e.push(C),
      r > jf && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function Z2(n, e, t) {
  const i = new Ko(n, e, t);
  return (
    (i.texture.mapping = Jh),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function iv(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function T7(n, e, t) {
  const i = new Float32Array(ku),
    r = new z(0, 1, 0);
  return new Ao({
    name: "SphericalGaussianBlur",
    defines: {
      n: ku,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: JT(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Ca,
    depthTest: !1,
    depthWrite: !1,
  });
}
function q2() {
  return new Ao({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: JT(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Ca,
    depthTest: !1,
    depthWrite: !1,
  });
}
function $2() {
  return new Ao({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: JT(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Ca,
    depthTest: !1,
    depthWrite: !1,
  });
}
function JT() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function C7(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        u = l === om || l === am,
        c = l === Oa || l === kl;
      if (u || c) {
        let d = e.get(a);
        const p = d !== void 0 ? d.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== p)
          return (
            t === null && (t = new sw(n)),
            (d = u ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
            (d.texture.pmremVersion = a.pmremVersion),
            e.set(a, d),
            d.texture
          );
        if (d !== void 0) return d.texture;
        {
          const m = a.image;
          return (u && m && m.height > 0) || (c && m && r(m))
            ? (t === null && (t = new sw(n)),
              (d = u ? t.fromEquirectangular(a) : t.fromCubemap(a)),
              (d.texture.pmremVersion = a.pmremVersion),
              e.set(a, d),
              a.addEventListener("dispose", s),
              d.texture)
            : null;
        }
      }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const u = 6;
    for (let c = 0; c < u; c++) a[c] !== void 0 && l++;
    return l === u;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: i, dispose: o };
}
function b7(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          Cf("THREE.WebGLRenderer: " + i + " extension not supported."),
        r
      );
    },
  };
}
function R7(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const v in p.attributes) e.remove(p.attributes[v]);
    p.removeEventListener("dispose", o), delete r[p.id];
    const m = s.get(p);
    m && (e.remove(m), s.delete(p)),
      i.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(d, p) {
    return (
      r[p.id] === !0 ||
        (p.addEventListener("dispose", o),
        (r[p.id] = !0),
        t.memory.geometries++),
      p
    );
  }
  function l(d) {
    const p = d.attributes;
    for (const m in p) e.update(p[m], n.ARRAY_BUFFER);
  }
  function u(d) {
    const p = [],
      m = d.index,
      v = d.attributes.position;
    let _ = 0;
    if (m !== null) {
      const A = m.array;
      _ = m.version;
      for (let S = 0, w = A.length; S < w; S += 3) {
        const C = A[S + 0],
          b = A[S + 1],
          P = A[S + 2];
        p.push(C, b, b, P, P, C);
      }
    } else if (v !== void 0) {
      const A = v.array;
      _ = v.version;
      for (let S = 0, w = A.length / 3 - 1; S < w; S += 3) {
        const C = S + 0,
          b = S + 1,
          P = S + 2;
        p.push(C, b, b, P, P, C);
      }
    } else return;
    const x = new (rN(p) ? pT : dT)(p, 1);
    x.version = _;
    const g = s.get(d);
    g && e.remove(g), s.set(d, x);
  }
  function c(d) {
    const p = s.get(d);
    if (p) {
      const m = d.index;
      m !== null && p.version < m.version && u(d);
    } else u(d);
    return s.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: c };
}
function P7(n, e, t) {
  let i;
  function r(p) {
    i = p;
  }
  let s, o;
  function a(p) {
    (s = p.type), (o = p.bytesPerElement);
  }
  function l(p, m) {
    n.drawElements(i, m, s, p * o), t.update(m, i, 1);
  }
  function u(p, m, v) {
    v !== 0 && (n.drawElementsInstanced(i, m, s, p * o, v), t.update(m, i, v));
  }
  function c(p, m, v) {
    if (v === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, m, 0, s, p, 0, v);
    let x = 0;
    for (let g = 0; g < v; g++) x += m[g];
    t.update(x, i, 1);
  }
  function d(p, m, v, _) {
    if (v === 0) return;
    const x = e.get("WEBGL_multi_draw");
    if (x === null) for (let g = 0; g < p.length; g++) u(p[g] / o, m[g], _[g]);
    else {
      x.multiDrawElementsInstancedWEBGL(i, m, 0, s, p, 0, _, 0, v);
      let g = 0;
      for (let A = 0; A < v; A++) g += m[A] * _[A];
      t.update(g, i, 1);
    }
  }
  (this.setMode = r),
    (this.setIndex = a),
    (this.render = l),
    (this.renderInstances = u),
    (this.renderMultiDraw = c),
    (this.renderMultiDrawInstances = d);
}
function B7(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function I7(n, e, t) {
  const i = new WeakMap(),
    r = new tn();
  function s(o, a, l) {
    const u = o.morphTargetInfluences,
      c =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      d = c !== void 0 ? c.length : 0;
    let p = i.get(a);
    if (p === void 0 || p.count !== d) {
      let T = function () {
        I.dispose(), i.delete(a), a.removeEventListener("dispose", T);
      };
      var m = T;
      p !== void 0 && p.texture.dispose();
      const v = a.morphAttributes.position !== void 0,
        _ = a.morphAttributes.normal !== void 0,
        x = a.morphAttributes.color !== void 0,
        g = a.morphAttributes.position || [],
        A = a.morphAttributes.normal || [],
        S = a.morphAttributes.color || [];
      let w = 0;
      v === !0 && (w = 1), _ === !0 && (w = 2), x === !0 && (w = 3);
      let C = a.attributes.position.count * w,
        b = 1;
      C > e.maxTextureSize &&
        ((b = Math.ceil(C / e.maxTextureSize)), (C = e.maxTextureSize));
      const P = new Float32Array(C * b * 4 * d),
        I = new zm(P, C, b, d);
      (I.type = kr), (I.needsUpdate = !0);
      const R = w * 4;
      for (let D = 0; D < d; D++) {
        const G = g[D],
          W = A[D],
          q = S[D],
          Z = C * b * 4 * D;
        for (let K = 0; K < G.count; K++) {
          const te = K * R;
          v === !0 &&
            (r.fromBufferAttribute(G, K),
            (P[Z + te + 0] = r.x),
            (P[Z + te + 1] = r.y),
            (P[Z + te + 2] = r.z),
            (P[Z + te + 3] = 0)),
            _ === !0 &&
              (r.fromBufferAttribute(W, K),
              (P[Z + te + 4] = r.x),
              (P[Z + te + 5] = r.y),
              (P[Z + te + 6] = r.z),
              (P[Z + te + 7] = 0)),
            x === !0 &&
              (r.fromBufferAttribute(q, K),
              (P[Z + te + 8] = r.x),
              (P[Z + te + 9] = r.y),
              (P[Z + te + 10] = r.z),
              (P[Z + te + 11] = q.itemSize === 4 ? r.w : 1));
        }
      }
      (p = { count: d, texture: I, size: new Ae(C, b) }),
        i.set(a, p),
        a.addEventListener("dispose", T);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
    else {
      let v = 0;
      for (let x = 0; x < u.length; x++) v += u[x];
      const _ = a.morphTargetsRelative ? 1 : 1 - v;
      l.getUniforms().setValue(n, "morphTargetBaseInfluence", _),
        l.getUniforms().setValue(n, "morphTargetInfluences", u);
    }
    l.getUniforms().setValue(n, "morphTargetsTexture", p.texture, t),
      l.getUniforms().setValue(n, "morphTargetsTextureSize", p.size);
  }
  return { update: s };
}
function D7(n, e, t, i) {
  let r = new WeakMap();
  function s(l) {
    const u = i.render.frame,
      c = l.geometry,
      d = e.get(l, c);
    if (
      (r.get(d) !== u && (e.update(d), r.set(d, u)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        r.get(l) !== u &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          r.set(l, u))),
      l.isSkinnedMesh)
    ) {
      const p = l.skeleton;
      r.get(p) !== u && (p.update(), r.set(p, u));
    }
    return d;
  }
  function o() {
    r = new WeakMap();
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a),
      t.remove(u.instanceMatrix),
      u.instanceColor !== null && t.remove(u.instanceColor);
  }
  return { update: s, dispose: o };
}
const $N = new Pn(),
  eB = new MT(1, 1),
  eO = new zm(),
  tO = new cx(),
  nO = new Gm(),
  tB = [],
  nB = [],
  iB = new Float32Array(16),
  rB = new Float32Array(9),
  sB = new Float32Array(4);
function Zh(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = tB[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (tB[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function gi(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function vi(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function Px(n, e) {
  let t = nB[e];
  t === void 0 && ((t = new Int32Array(e)), (nB[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function L7(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function F7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (gi(t, e)) return;
    n.uniform2fv(this.addr, e), vi(t, e);
  }
}
function N7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (gi(t, e)) return;
    n.uniform3fv(this.addr, e), vi(t, e);
  }
}
function O7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (gi(t, e)) return;
    n.uniform4fv(this.addr, e), vi(t, e);
  }
}
function U7(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (gi(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), vi(t, e);
  } else {
    if (gi(t, i)) return;
    sB.set(i), n.uniformMatrix2fv(this.addr, !1, sB), vi(t, i);
  }
}
function k7(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (gi(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), vi(t, e);
  } else {
    if (gi(t, i)) return;
    rB.set(i), n.uniformMatrix3fv(this.addr, !1, rB), vi(t, i);
  }
}
function z7(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (gi(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), vi(t, e);
  } else {
    if (gi(t, i)) return;
    iB.set(i), n.uniformMatrix4fv(this.addr, !1, iB), vi(t, i);
  }
}
function H7(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function G7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (gi(t, e)) return;
    n.uniform2iv(this.addr, e), vi(t, e);
  }
}
function V7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (gi(t, e)) return;
    n.uniform3iv(this.addr, e), vi(t, e);
  }
}
function W7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (gi(t, e)) return;
    n.uniform4iv(this.addr, e), vi(t, e);
  }
}
function X7(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function J7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (gi(t, e)) return;
    n.uniform2uiv(this.addr, e), vi(t, e);
  }
}
function j7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (gi(t, e)) return;
    n.uniform3uiv(this.addr, e), vi(t, e);
  }
}
function Y7(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (gi(t, e)) return;
    n.uniform4uiv(this.addr, e), vi(t, e);
  }
}
function K7(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r));
  let s;
  this.type === n.SAMPLER_2D_SHADOW
    ? ((eB.compareFunction = fT), (s = eB))
    : (s = $N),
    t.setTexture2D(e || s, r);
}
function Q7(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || tO, r);
}
function Z7(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || nO, r);
}
function q7(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || eO, r);
}
function $7(n) {
  switch (n) {
    case 5126:
      return L7;
    case 35664:
      return F7;
    case 35665:
      return N7;
    case 35666:
      return O7;
    case 35674:
      return U7;
    case 35675:
      return k7;
    case 35676:
      return z7;
    case 5124:
    case 35670:
      return H7;
    case 35667:
    case 35671:
      return G7;
    case 35668:
    case 35672:
      return V7;
    case 35669:
    case 35673:
      return W7;
    case 5125:
      return X7;
    case 36294:
      return J7;
    case 36295:
      return j7;
    case 36296:
      return Y7;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return K7;
    case 35679:
    case 36299:
    case 36307:
      return Q7;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Z7;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return q7;
  }
}
function eX(n, e) {
  n.uniform1fv(this.addr, e);
}
function tX(n, e) {
  const t = Zh(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function nX(n, e) {
  const t = Zh(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function iX(n, e) {
  const t = Zh(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function rX(n, e) {
  const t = Zh(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function sX(n, e) {
  const t = Zh(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function oX(n, e) {
  const t = Zh(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function aX(n, e) {
  n.uniform1iv(this.addr, e);
}
function lX(n, e) {
  n.uniform2iv(this.addr, e);
}
function uX(n, e) {
  n.uniform3iv(this.addr, e);
}
function cX(n, e) {
  n.uniform4iv(this.addr, e);
}
function fX(n, e) {
  n.uniform1uiv(this.addr, e);
}
function hX(n, e) {
  n.uniform2uiv(this.addr, e);
}
function dX(n, e) {
  n.uniform3uiv(this.addr, e);
}
function pX(n, e) {
  n.uniform4uiv(this.addr, e);
}
function mX(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Px(t, r);
  gi(i, s) || (n.uniform1iv(this.addr, s), vi(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || $N, s[o]);
}
function gX(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Px(t, r);
  gi(i, s) || (n.uniform1iv(this.addr, s), vi(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || tO, s[o]);
}
function vX(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Px(t, r);
  gi(i, s) || (n.uniform1iv(this.addr, s), vi(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || nO, s[o]);
}
function yX(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Px(t, r);
  gi(i, s) || (n.uniform1iv(this.addr, s), vi(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || eO, s[o]);
}
function _X(n) {
  switch (n) {
    case 5126:
      return eX;
    case 35664:
      return tX;
    case 35665:
      return nX;
    case 35666:
      return iX;
    case 35674:
      return rX;
    case 35675:
      return sX;
    case 35676:
      return oX;
    case 5124:
    case 35670:
      return aX;
    case 35667:
    case 35671:
      return lX;
    case 35668:
    case 35672:
      return uX;
    case 35669:
    case 35673:
      return cX;
    case 5125:
      return fX;
    case 36294:
      return hX;
    case 36295:
      return dX;
    case 36296:
      return pX;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return mX;
    case 35679:
    case 36299:
    case 36307:
      return gX;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return vX;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return yX;
  }
}
class xX {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = $7(t.type));
  }
}
class AX {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = _X(t.type));
  }
}
class SX {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const aS = /(\w+)(\])?(\[|\.)?/g;
function oB(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function MX(n, e, t) {
  const i = n.name,
    r = i.length;
  for (aS.lastIndex = 0; ; ) {
    const s = aS.exec(i),
      o = aS.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      u = s[3];
    if ((l && (a = a | 0), u === void 0 || (u === "[" && o + 2 === r))) {
      oB(t, u === void 0 ? new xX(a, n, e) : new AX(a, n, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && ((d = new SX(a)), oB(t, d)), (t = d);
    }
  }
}
class kv {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name);
      MX(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function aB(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
const wX = 37297;
let EX = 0;
function TX(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
const lB = new It();
function CX(n) {
  en._getMatrix(lB, en.workingColorSpace, n);
  const e = `mat3( ${lB.elements.map((t) => t.toFixed(4))} )`;
  switch (en.getTransfer(n)) {
    case um:
      return [e, "LinearTransferOETF"];
    case pn:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", n),
        [e, "LinearTransferOETF"]
      );
  }
}
function uB(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      TX(n.getShaderSource(e), o)
    );
  } else return r;
}
function bX(n, e) {
  const t = CX(e);
  return [
    `vec4 ${n}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function RX(n, e) {
  let t;
  switch (e) {
    case NF:
      t = "Linear";
      break;
    case OF:
      t = "Reinhard";
      break;
    case UF:
      t = "Cineon";
      break;
    case $E:
      t = "ACESFilmic";
      break;
    case zF:
      t = "AgX";
      break;
    case HF:
      t = "Neutral";
      break;
    case kF:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const rv = new z();
function PX() {
  en.getLuminanceCoefficients(rv);
  const n = rv.x.toFixed(4),
    e = rv.y.toFixed(4),
    t = rv.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function BX(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(Zd).join(`
`);
}
function IX(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function DX(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function Zd(n) {
  return n !== "";
}
function cB(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function fB(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const LX = /^[ \t]*#include +<([\w\d./]+)>/gm;
function ow(n) {
  return n.replace(LX, NX);
}
const FX = new Map();
function NX(n, e) {
  let t = Nt[e];
  if (t === void 0) {
    const i = FX.get(e);
    if (i !== void 0)
      (t = Nt[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return ow(t);
}
const OX =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function hB(n) {
  return n.replace(OX, UX);
}
function UX(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function dB(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function kX(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === $_
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === mp
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === uo && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function zX(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Oa:
      case kl:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Jh:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function HX(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case kl:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function GX(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case Um:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case LF:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case FF:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function VX(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function WX(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = kX(t),
    u = zX(t),
    c = HX(t),
    d = GX(t),
    p = VX(t),
    m = BX(t),
    v = IX(s),
    _ = r.createProgram();
  let x,
    g,
    A = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((x = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
      ].filter(Zd).join(`
`)),
      x.length > 0 &&
        (x += `
`),
      (g = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
      ].filter(Zd).join(`
`)),
      g.length > 0 &&
        (g += `
`))
    : ((x = [
        dB(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Zd).join(`
`)),
      (g = [
        dB(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + d : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Vo ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Vo ? Nt.tonemapping_pars_fragment : "",
        t.toneMapping !== Vo ? RX("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Nt.colorspace_pars_fragment,
        bX("linearToOutputTexel", t.outputColorSpace),
        PX(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(Zd).join(`
`))),
    (o = ow(o)),
    (o = cB(o, t)),
    (o = fB(o, t)),
    (a = ow(a)),
    (a = cB(a, t)),
    (a = fB(a, t)),
    (o = hB(o)),
    (a = hB(a)),
    t.isRawShaderMaterial !== !0 &&
      ((A = `#version 300 es
`),
      (x =
        [
          m,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        x),
      (g =
        [
          "#define varying in",
          t.glslVersion === ZM
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === ZM ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        g));
  const S = A + x + o,
    w = A + g + a,
    C = aB(r, r.VERTEX_SHADER, S),
    b = aB(r, r.FRAGMENT_SHADER, w);
  r.attachShader(_, C),
    r.attachShader(_, b),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(_, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"),
    r.linkProgram(_);
  function P(D) {
    if (n.debug.checkShaderErrors) {
      const G = r.getProgramInfoLog(_).trim(),
        W = r.getShaderInfoLog(C).trim(),
        q = r.getShaderInfoLog(b).trim();
      let Z = !0,
        K = !0;
      if (r.getProgramParameter(_, r.LINK_STATUS) === !1)
        if (((Z = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(r, _, C, b);
        else {
          const te = uB(r, C, "vertex"),
            O = uB(r, b, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(_, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              D.name +
              `
Material Type: ` +
              D.type +
              `

Program Info Log: ` +
              G +
              `
` +
              te +
              `
` +
              O
          );
        }
      else
        G !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", G)
          : (W === "" || q === "") && (K = !1);
      K &&
        (D.diagnostics = {
          runnable: Z,
          programLog: G,
          vertexShader: { log: W, prefix: x },
          fragmentShader: { log: q, prefix: g },
        });
    }
    r.deleteShader(C), r.deleteShader(b), (I = new kv(r, _)), (R = DX(r, _));
  }
  let I;
  this.getUniforms = function () {
    return I === void 0 && P(this), I;
  };
  let R;
  this.getAttributes = function () {
    return R === void 0 && P(this), R;
  };
  let T = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return T === !1 && (T = r.getProgramParameter(_, wX)), T;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(_),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = EX++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = _),
    (this.vertexShader = C),
    (this.fragmentShader = b),
    this
  );
}
let XX = 0;
class JX {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && ((i = new jX(e)), t.set(e, i)), i;
  }
}
class jX {
  constructor(e) {
    (this.id = XX++), (this.code = e), (this.usedTimes = 0);
  }
}
function YX(n, e, t, i, r, s, o) {
  const a = new oc(),
    l = new JX(),
    u = new Set(),
    c = [],
    d = r.logarithmicDepthBuffer,
    p = r.vertexTextures;
  let m = r.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function _(R) {
    return u.add(R), R === 0 ? "uv" : `uv${R}`;
  }
  function x(R, T, D, G, W) {
    const q = G.fog,
      Z = W.geometry,
      K = R.isMeshStandardMaterial ? G.environment : null,
      te = (R.isMeshStandardMaterial ? t : e).get(R.envMap || K),
      O = te && te.mapping === Jh ? te.image.height : null,
      Y = v[R.type];
    R.precision !== null &&
      ((m = r.getMaxPrecision(R.precision)),
      m !== R.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          R.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const F =
        Z.morphAttributes.position ||
        Z.morphAttributes.normal ||
        Z.morphAttributes.color,
      se = F !== void 0 ? F.length : 0;
    let Me = 0;
    Z.morphAttributes.position !== void 0 && (Me = 1),
      Z.morphAttributes.normal !== void 0 && (Me = 2),
      Z.morphAttributes.color !== void 0 && (Me = 3);
    let De, re, xe, Ce;
    if (Y) {
      const We = ho[Y];
      (De = We.vertexShader), (re = We.fragmentShader);
    } else
      (De = R.vertexShader),
        (re = R.fragmentShader),
        l.update(R),
        (xe = l.getVertexShaderID(R)),
        (Ce = l.getFragmentShaderID(R));
    const Se = n.getRenderTarget(),
      Xe = n.state.buffers.depth.getReversed(),
      et = W.isInstancedMesh === !0,
      Ye = W.isBatchedMesh === !0,
      Fe = !!R.map,
      de = !!R.matcap,
      ce = !!te,
      k = !!R.aoMap,
      Ve = !!R.lightMap,
      we = !!R.bumpMap,
      J = !!R.normalMap,
      Te = !!R.displacementMap,
      st = !!R.emissiveMap,
      Le = !!R.metalnessMap,
      U = !!R.roughnessMap,
      L = R.anisotropy > 0,
      ie = R.clearcoat > 0,
      fe = R.dispersion > 0,
      ye = R.iridescence > 0,
      me = R.sheen > 0,
      Pe = R.transmission > 0,
      Ie = L && !!R.anisotropyMap,
      ze = ie && !!R.clearcoatMap,
      Mt = ie && !!R.clearcoatNormalMap,
      Re = ie && !!R.clearcoatRoughnessMap,
      Ne = ye && !!R.iridescenceMap,
      mt = ye && !!R.iridescenceThicknessMap,
      dt = me && !!R.sheenColorMap,
      Ke = me && !!R.sheenRoughnessMap,
      X = !!R.specularMap,
      pe = !!R.specularColorMap,
      He = !!R.specularIntensityMap,
      V = Pe && !!R.transmissionMap,
      be = Pe && !!R.thicknessMap,
      ue = !!R.gradientMap,
      ge = !!R.alphaMap,
      Ue = R.alphaTest > 0,
      ke = !!R.alphaHash,
      ft = !!R.extensions;
    let Ct = Vo;
    R.toneMapped &&
      (Se === null || Se.isXRRenderTarget === !0) &&
      (Ct = n.toneMapping);
    const cn = {
      shaderID: Y,
      shaderType: R.type,
      shaderName: R.name,
      vertexShader: De,
      fragmentShader: re,
      defines: R.defines,
      customVertexShaderID: xe,
      customFragmentShaderID: Ce,
      isRawShaderMaterial: R.isRawShaderMaterial === !0,
      glslVersion: R.glslVersion,
      precision: m,
      batching: Ye,
      batchingColor: Ye && W._colorsTexture !== null,
      instancing: et,
      instancingColor: et && W.instanceColor !== null,
      instancingMorph: et && W.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace:
        Se === null
          ? n.outputColorSpace
          : Se.isXRRenderTarget === !0
          ? Se.texture.colorSpace
          : Mc,
      alphaToCoverage: !!R.alphaToCoverage,
      map: Fe,
      matcap: de,
      envMap: ce,
      envMapMode: ce && te.mapping,
      envMapCubeUVHeight: O,
      aoMap: k,
      lightMap: Ve,
      bumpMap: we,
      normalMap: J,
      displacementMap: p && Te,
      emissiveMap: st,
      normalMapObjectSpace: J && R.normalMapType === KF,
      normalMapTangentSpace: J && R.normalMapType === Ql,
      metalnessMap: Le,
      roughnessMap: U,
      anisotropy: L,
      anisotropyMap: Ie,
      clearcoat: ie,
      clearcoatMap: ze,
      clearcoatNormalMap: Mt,
      clearcoatRoughnessMap: Re,
      dispersion: fe,
      iridescence: ye,
      iridescenceMap: Ne,
      iridescenceThicknessMap: mt,
      sheen: me,
      sheenColorMap: dt,
      sheenRoughnessMap: Ke,
      specularMap: X,
      specularColorMap: pe,
      specularIntensityMap: He,
      transmission: Pe,
      transmissionMap: V,
      thicknessMap: be,
      gradientMap: ue,
      opaque:
        R.transparent === !1 && R.blending === nc && R.alphaToCoverage === !1,
      alphaMap: ge,
      alphaTest: Ue,
      alphaHash: ke,
      combine: R.combine,
      mapUv: Fe && _(R.map.channel),
      aoMapUv: k && _(R.aoMap.channel),
      lightMapUv: Ve && _(R.lightMap.channel),
      bumpMapUv: we && _(R.bumpMap.channel),
      normalMapUv: J && _(R.normalMap.channel),
      displacementMapUv: Te && _(R.displacementMap.channel),
      emissiveMapUv: st && _(R.emissiveMap.channel),
      metalnessMapUv: Le && _(R.metalnessMap.channel),
      roughnessMapUv: U && _(R.roughnessMap.channel),
      anisotropyMapUv: Ie && _(R.anisotropyMap.channel),
      clearcoatMapUv: ze && _(R.clearcoatMap.channel),
      clearcoatNormalMapUv: Mt && _(R.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Re && _(R.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ne && _(R.iridescenceMap.channel),
      iridescenceThicknessMapUv: mt && _(R.iridescenceThicknessMap.channel),
      sheenColorMapUv: dt && _(R.sheenColorMap.channel),
      sheenRoughnessMapUv: Ke && _(R.sheenRoughnessMap.channel),
      specularMapUv: X && _(R.specularMap.channel),
      specularColorMapUv: pe && _(R.specularColorMap.channel),
      specularIntensityMapUv: He && _(R.specularIntensityMap.channel),
      transmissionMapUv: V && _(R.transmissionMap.channel),
      thicknessMapUv: be && _(R.thicknessMap.channel),
      alphaMapUv: ge && _(R.alphaMap.channel),
      vertexTangents: !!Z.attributes.tangent && (J || L),
      vertexColors: R.vertexColors,
      vertexAlphas:
        R.vertexColors === !0 &&
        !!Z.attributes.color &&
        Z.attributes.color.itemSize === 4,
      pointsUvs: W.isPoints === !0 && !!Z.attributes.uv && (Fe || ge),
      fog: !!q,
      useFog: R.fog === !0,
      fogExp2: !!q && q.isFogExp2,
      flatShading: R.flatShading === !0,
      sizeAttenuation: R.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      reverseDepthBuffer: Xe,
      skinning: W.isSkinnedMesh === !0,
      morphTargets: Z.morphAttributes.position !== void 0,
      morphNormals: Z.morphAttributes.normal !== void 0,
      morphColors: Z.morphAttributes.color !== void 0,
      morphTargetsCount: se,
      morphTextureStride: Me,
      numDirLights: T.directional.length,
      numPointLights: T.point.length,
      numSpotLights: T.spot.length,
      numSpotLightMaps: T.spotLightMap.length,
      numRectAreaLights: T.rectArea.length,
      numHemiLights: T.hemi.length,
      numDirLightShadows: T.directionalShadowMap.length,
      numPointLightShadows: T.pointShadowMap.length,
      numSpotLightShadows: T.spotShadowMap.length,
      numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
      numLightProbes: T.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: R.dithering,
      shadowMapEnabled: n.shadowMap.enabled && D.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: Ct,
      decodeVideoTexture:
        Fe &&
        R.map.isVideoTexture === !0 &&
        en.getTransfer(R.map.colorSpace) === pn,
      decodeVideoTextureEmissive:
        st &&
        R.emissiveMap.isVideoTexture === !0 &&
        en.getTransfer(R.emissiveMap.colorSpace) === pn,
      premultipliedAlpha: R.premultipliedAlpha,
      doubleSided: R.side === Vs,
      flipSided: R.side === Ar,
      useDepthPacking: R.depthPacking >= 0,
      depthPacking: R.depthPacking || 0,
      index0AttributeName: R.index0AttributeName,
      extensionClipCullDistance:
        ft &&
        R.extensions.clipCullDistance === !0 &&
        i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((ft && R.extensions.multiDraw === !0) || Ye) &&
        i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: R.customProgramCacheKey(),
    };
    return (
      (cn.vertexUv1s = u.has(1)),
      (cn.vertexUv2s = u.has(2)),
      (cn.vertexUv3s = u.has(3)),
      u.clear(),
      cn
    );
  }
  function g(R) {
    const T = [];
    if (
      (R.shaderID
        ? T.push(R.shaderID)
        : (T.push(R.customVertexShaderID), T.push(R.customFragmentShaderID)),
      R.defines !== void 0)
    )
      for (const D in R.defines) T.push(D), T.push(R.defines[D]);
    return (
      R.isRawShaderMaterial === !1 &&
        (A(T, R), S(T, R), T.push(n.outputColorSpace)),
      T.push(R.customProgramCacheKey),
      T.join()
    );
  }
  function A(R, T) {
    R.push(T.precision),
      R.push(T.outputColorSpace),
      R.push(T.envMapMode),
      R.push(T.envMapCubeUVHeight),
      R.push(T.mapUv),
      R.push(T.alphaMapUv),
      R.push(T.lightMapUv),
      R.push(T.aoMapUv),
      R.push(T.bumpMapUv),
      R.push(T.normalMapUv),
      R.push(T.displacementMapUv),
      R.push(T.emissiveMapUv),
      R.push(T.metalnessMapUv),
      R.push(T.roughnessMapUv),
      R.push(T.anisotropyMapUv),
      R.push(T.clearcoatMapUv),
      R.push(T.clearcoatNormalMapUv),
      R.push(T.clearcoatRoughnessMapUv),
      R.push(T.iridescenceMapUv),
      R.push(T.iridescenceThicknessMapUv),
      R.push(T.sheenColorMapUv),
      R.push(T.sheenRoughnessMapUv),
      R.push(T.specularMapUv),
      R.push(T.specularColorMapUv),
      R.push(T.specularIntensityMapUv),
      R.push(T.transmissionMapUv),
      R.push(T.thicknessMapUv),
      R.push(T.combine),
      R.push(T.fogExp2),
      R.push(T.sizeAttenuation),
      R.push(T.morphTargetsCount),
      R.push(T.morphAttributeCount),
      R.push(T.numDirLights),
      R.push(T.numPointLights),
      R.push(T.numSpotLights),
      R.push(T.numSpotLightMaps),
      R.push(T.numHemiLights),
      R.push(T.numRectAreaLights),
      R.push(T.numDirLightShadows),
      R.push(T.numPointLightShadows),
      R.push(T.numSpotLightShadows),
      R.push(T.numSpotLightShadowsWithMaps),
      R.push(T.numLightProbes),
      R.push(T.shadowMapType),
      R.push(T.toneMapping),
      R.push(T.numClippingPlanes),
      R.push(T.numClipIntersection),
      R.push(T.depthPacking);
  }
  function S(R, T) {
    a.disableAll(),
      T.supportsVertexTextures && a.enable(0),
      T.instancing && a.enable(1),
      T.instancingColor && a.enable(2),
      T.instancingMorph && a.enable(3),
      T.matcap && a.enable(4),
      T.envMap && a.enable(5),
      T.normalMapObjectSpace && a.enable(6),
      T.normalMapTangentSpace && a.enable(7),
      T.clearcoat && a.enable(8),
      T.iridescence && a.enable(9),
      T.alphaTest && a.enable(10),
      T.vertexColors && a.enable(11),
      T.vertexAlphas && a.enable(12),
      T.vertexUv1s && a.enable(13),
      T.vertexUv2s && a.enable(14),
      T.vertexUv3s && a.enable(15),
      T.vertexTangents && a.enable(16),
      T.anisotropy && a.enable(17),
      T.alphaHash && a.enable(18),
      T.batching && a.enable(19),
      T.dispersion && a.enable(20),
      T.batchingColor && a.enable(21),
      R.push(a.mask),
      a.disableAll(),
      T.fog && a.enable(0),
      T.useFog && a.enable(1),
      T.flatShading && a.enable(2),
      T.logarithmicDepthBuffer && a.enable(3),
      T.reverseDepthBuffer && a.enable(4),
      T.skinning && a.enable(5),
      T.morphTargets && a.enable(6),
      T.morphNormals && a.enable(7),
      T.morphColors && a.enable(8),
      T.premultipliedAlpha && a.enable(9),
      T.shadowMapEnabled && a.enable(10),
      T.doubleSided && a.enable(11),
      T.flipSided && a.enable(12),
      T.useDepthPacking && a.enable(13),
      T.dithering && a.enable(14),
      T.transmission && a.enable(15),
      T.sheen && a.enable(16),
      T.opaque && a.enable(17),
      T.pointsUvs && a.enable(18),
      T.decodeVideoTexture && a.enable(19),
      T.decodeVideoTextureEmissive && a.enable(20),
      T.alphaToCoverage && a.enable(21),
      R.push(a.mask);
  }
  function w(R) {
    const T = v[R.type];
    let D;
    if (T) {
      const G = ho[T];
      D = uN.clone(G.uniforms);
    } else D = R.uniforms;
    return D;
  }
  function C(R, T) {
    let D;
    for (let G = 0, W = c.length; G < W; G++) {
      const q = c[G];
      if (q.cacheKey === T) {
        (D = q), ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && ((D = new WX(n, T, R, s)), c.push(D)), D;
  }
  function b(R) {
    if (--R.usedTimes === 0) {
      const T = c.indexOf(R);
      (c[T] = c[c.length - 1]), c.pop(), R.destroy();
    }
  }
  function P(R) {
    l.remove(R);
  }
  function I() {
    l.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: g,
    getUniforms: w,
    acquireProgram: C,
    releaseProgram: b,
    releaseShaderCache: P,
    programs: c,
    dispose: I,
  };
}
function KX() {
  let n = new WeakMap();
  function e(o) {
    return n.has(o);
  }
  function t(o) {
    let a = n.get(o);
    return a === void 0 && ((a = {}), n.set(o, a)), a;
  }
  function i(o) {
    n.delete(o);
  }
  function r(o, a, l) {
    n.get(o)[a] = l;
  }
  function s() {
    n = new WeakMap();
  }
  return { has: e, get: t, remove: i, update: r, dispose: s };
}
function QX(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function pB(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function mB() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
  }
  function o(d, p, m, v, _, x) {
    let g = n[e];
    return (
      g === void 0
        ? ((g = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: v,
            renderOrder: d.renderOrder,
            z: _,
            group: x,
          }),
          (n[e] = g))
        : ((g.id = d.id),
          (g.object = d),
          (g.geometry = p),
          (g.material = m),
          (g.groupOrder = v),
          (g.renderOrder = d.renderOrder),
          (g.z = _),
          (g.group = x)),
      e++,
      g
    );
  }
  function a(d, p, m, v, _, x) {
    const g = o(d, p, m, v, _, x);
    m.transmission > 0
      ? i.push(g)
      : m.transparent === !0
      ? r.push(g)
      : t.push(g);
  }
  function l(d, p, m, v, _, x) {
    const g = o(d, p, m, v, _, x);
    m.transmission > 0
      ? i.unshift(g)
      : m.transparent === !0
      ? r.unshift(g)
      : t.unshift(g);
  }
  function u(d, p) {
    t.length > 1 && t.sort(d || QX),
      i.length > 1 && i.sort(p || pB),
      r.length > 1 && r.sort(p || pB);
  }
  function c() {
    for (let d = e, p = n.length; d < p; d++) {
      const m = n[d];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: c,
    sort: u,
  };
}
function ZX() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new mB()), n.set(i, [o]))
        : r >= s.length
        ? ((o = new mB()), s.push(o))
        : (o = s[r]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function qX() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new z(), color: new Ze() };
          break;
        case "SpotLight":
          t = {
            position: new z(),
            direction: new z(),
            color: new Ze(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new z(), color: new Ze(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new z(), skyColor: new Ze(), groundColor: new Ze() };
          break;
        case "RectAreaLight":
          t = {
            color: new Ze(),
            position: new z(),
            halfWidth: new z(),
            halfHeight: new z(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function $X() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ae(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ae(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ae(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let eJ = 0;
function tJ(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function nJ(n) {
  const e = new qX(),
    t = $X(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let u = 0; u < 9; u++) i.probe.push(new z());
  const r = new z(),
    s = new _t(),
    o = new _t();
  function a(u) {
    let c = 0,
      d = 0,
      p = 0;
    for (let R = 0; R < 9; R++) i.probe[R].set(0, 0, 0);
    let m = 0,
      v = 0,
      _ = 0,
      x = 0,
      g = 0,
      A = 0,
      S = 0,
      w = 0,
      C = 0,
      b = 0,
      P = 0;
    u.sort(tJ);
    for (let R = 0, T = u.length; R < T; R++) {
      const D = u[R],
        G = D.color,
        W = D.intensity,
        q = D.distance,
        Z = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight) (c += G.r * W), (d += G.g * W), (p += G.b * W);
      else if (D.isLightProbe) {
        for (let K = 0; K < 9; K++)
          i.probe[K].addScaledVector(D.sh.coefficients[K], W);
        P++;
      } else if (D.isDirectionalLight) {
        const K = e.get(D);
        if ((K.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow)) {
          const te = D.shadow,
            O = t.get(D);
          (O.shadowIntensity = te.intensity),
            (O.shadowBias = te.bias),
            (O.shadowNormalBias = te.normalBias),
            (O.shadowRadius = te.radius),
            (O.shadowMapSize = te.mapSize),
            (i.directionalShadow[m] = O),
            (i.directionalShadowMap[m] = Z),
            (i.directionalShadowMatrix[m] = D.shadow.matrix),
            A++;
        }
        (i.directional[m] = K), m++;
      } else if (D.isSpotLight) {
        const K = e.get(D);
        K.position.setFromMatrixPosition(D.matrixWorld),
          K.color.copy(G).multiplyScalar(W),
          (K.distance = q),
          (K.coneCos = Math.cos(D.angle)),
          (K.penumbraCos = Math.cos(D.angle * (1 - D.penumbra))),
          (K.decay = D.decay),
          (i.spot[_] = K);
        const te = D.shadow;
        if (
          (D.map &&
            ((i.spotLightMap[C] = D.map),
            C++,
            te.updateMatrices(D),
            D.castShadow && b++),
          (i.spotLightMatrix[_] = te.matrix),
          D.castShadow)
        ) {
          const O = t.get(D);
          (O.shadowIntensity = te.intensity),
            (O.shadowBias = te.bias),
            (O.shadowNormalBias = te.normalBias),
            (O.shadowRadius = te.radius),
            (O.shadowMapSize = te.mapSize),
            (i.spotShadow[_] = O),
            (i.spotShadowMap[_] = Z),
            w++;
        }
        _++;
      } else if (D.isRectAreaLight) {
        const K = e.get(D);
        K.color.copy(G).multiplyScalar(W),
          K.halfWidth.set(D.width * 0.5, 0, 0),
          K.halfHeight.set(0, D.height * 0.5, 0),
          (i.rectArea[x] = K),
          x++;
      } else if (D.isPointLight) {
        const K = e.get(D);
        if (
          (K.color.copy(D.color).multiplyScalar(D.intensity),
          (K.distance = D.distance),
          (K.decay = D.decay),
          D.castShadow)
        ) {
          const te = D.shadow,
            O = t.get(D);
          (O.shadowIntensity = te.intensity),
            (O.shadowBias = te.bias),
            (O.shadowNormalBias = te.normalBias),
            (O.shadowRadius = te.radius),
            (O.shadowMapSize = te.mapSize),
            (O.shadowCameraNear = te.camera.near),
            (O.shadowCameraFar = te.camera.far),
            (i.pointShadow[v] = O),
            (i.pointShadowMap[v] = Z),
            (i.pointShadowMatrix[v] = D.shadow.matrix),
            S++;
        }
        (i.point[v] = K), v++;
      } else if (D.isHemisphereLight) {
        const K = e.get(D);
        K.skyColor.copy(D.color).multiplyScalar(W),
          K.groundColor.copy(D.groundColor).multiplyScalar(W),
          (i.hemi[g] = K),
          g++;
      }
    }
    x > 0 &&
      (n.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = Qe.LTC_FLOAT_1), (i.rectAreaLTC2 = Qe.LTC_FLOAT_2))
        : ((i.rectAreaLTC1 = Qe.LTC_HALF_1), (i.rectAreaLTC2 = Qe.LTC_HALF_2))),
      (i.ambient[0] = c),
      (i.ambient[1] = d),
      (i.ambient[2] = p);
    const I = i.hash;
    (I.directionalLength !== m ||
      I.pointLength !== v ||
      I.spotLength !== _ ||
      I.rectAreaLength !== x ||
      I.hemiLength !== g ||
      I.numDirectionalShadows !== A ||
      I.numPointShadows !== S ||
      I.numSpotShadows !== w ||
      I.numSpotMaps !== C ||
      I.numLightProbes !== P) &&
      ((i.directional.length = m),
      (i.spot.length = _),
      (i.rectArea.length = x),
      (i.point.length = v),
      (i.hemi.length = g),
      (i.directionalShadow.length = A),
      (i.directionalShadowMap.length = A),
      (i.pointShadow.length = S),
      (i.pointShadowMap.length = S),
      (i.spotShadow.length = w),
      (i.spotShadowMap.length = w),
      (i.directionalShadowMatrix.length = A),
      (i.pointShadowMatrix.length = S),
      (i.spotLightMatrix.length = w + C - b),
      (i.spotLightMap.length = C),
      (i.numSpotLightShadowsWithMaps = b),
      (i.numLightProbes = P),
      (I.directionalLength = m),
      (I.pointLength = v),
      (I.spotLength = _),
      (I.rectAreaLength = x),
      (I.hemiLength = g),
      (I.numDirectionalShadows = A),
      (I.numPointShadows = S),
      (I.numSpotShadows = w),
      (I.numSpotMaps = C),
      (I.numLightProbes = P),
      (i.version = eJ++));
  }
  function l(u, c) {
    let d = 0,
      p = 0,
      m = 0,
      v = 0,
      _ = 0;
    const x = c.matrixWorldInverse;
    for (let g = 0, A = u.length; g < A; g++) {
      const S = u[g];
      if (S.isDirectionalLight) {
        const w = i.directional[d];
        w.direction.setFromMatrixPosition(S.matrixWorld),
          r.setFromMatrixPosition(S.target.matrixWorld),
          w.direction.sub(r),
          w.direction.transformDirection(x),
          d++;
      } else if (S.isSpotLight) {
        const w = i.spot[m];
        w.position.setFromMatrixPosition(S.matrixWorld),
          w.position.applyMatrix4(x),
          w.direction.setFromMatrixPosition(S.matrixWorld),
          r.setFromMatrixPosition(S.target.matrixWorld),
          w.direction.sub(r),
          w.direction.transformDirection(x),
          m++;
      } else if (S.isRectAreaLight) {
        const w = i.rectArea[v];
        w.position.setFromMatrixPosition(S.matrixWorld),
          w.position.applyMatrix4(x),
          o.identity(),
          s.copy(S.matrixWorld),
          s.premultiply(x),
          o.extractRotation(s),
          w.halfWidth.set(S.width * 0.5, 0, 0),
          w.halfHeight.set(0, S.height * 0.5, 0),
          w.halfWidth.applyMatrix4(o),
          w.halfHeight.applyMatrix4(o),
          v++;
      } else if (S.isPointLight) {
        const w = i.point[p];
        w.position.setFromMatrixPosition(S.matrixWorld),
          w.position.applyMatrix4(x),
          p++;
      } else if (S.isHemisphereLight) {
        const w = i.hemi[_];
        w.direction.setFromMatrixPosition(S.matrixWorld),
          w.direction.transformDirection(x),
          _++;
      }
    }
  }
  return { setup: a, setupView: l, state: i };
}
function gB(n) {
  const e = new nJ(n),
    t = [],
    i = [];
  function r(c) {
    (u.camera = c), (t.length = 0), (i.length = 0);
  }
  function s(c) {
    t.push(c);
  }
  function o(c) {
    i.push(c);
  }
  function a() {
    e.setup(t);
  }
  function l(c) {
    e.setupView(t, c);
  }
  const u = {
    lightsArray: t,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: r,
    state: u,
    setupLights: a,
    setupLightsView: l,
    pushLight: s,
    pushShadow: o,
  };
}
function iJ(n) {
  let e = new WeakMap();
  function t(r, s = 0) {
    const o = e.get(r);
    let a;
    return (
      o === void 0
        ? ((a = new gB(n)), e.set(r, [a]))
        : s >= o.length
        ? ((a = new gB(n)), o.push(a))
        : (a = o[s]),
      a
    );
  }
  function i() {
    e = new WeakMap();
  }
  return { get: t, dispose: i };
}
const rJ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  sJ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function oJ(n, e, t) {
  let i = new Xm();
  const r = new Ae(),
    s = new Ae(),
    o = new tn(),
    a = new PT({ depthPacking: YF }),
    l = new BT(),
    u = {},
    c = t.maxTextureSize,
    d = { [Yo]: Ar, [Ar]: Yo, [Vs]: Vs },
    p = new Ao({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Ae() },
        radius: { value: 4 },
      },
      vertexShader: rJ,
      fragmentShader: sJ,
    }),
    m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const v = new Lt();
  v.setAttribute(
    "position",
    new rn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const _ = new qn(v, p),
    x = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = $_);
  let g = this.type;
  this.render = function (b, P, I) {
    if (
      x.enabled === !1 ||
      (x.autoUpdate === !1 && x.needsUpdate === !1) ||
      b.length === 0
    )
      return;
    const R = n.getRenderTarget(),
      T = n.getActiveCubeFace(),
      D = n.getActiveMipmapLevel(),
      G = n.state;
    G.setBlending(Ca),
      G.buffers.color.setClear(1, 1, 1, 1),
      G.buffers.depth.setTest(!0),
      G.setScissorTest(!1);
    const W = g !== uo && this.type === uo,
      q = g === uo && this.type !== uo;
    for (let Z = 0, K = b.length; Z < K; Z++) {
      const te = b[Z],
        O = te.shadow;
      if (O === void 0) {
        console.warn("THREE.WebGLShadowMap:", te, "has no shadow.");
        continue;
      }
      if (O.autoUpdate === !1 && O.needsUpdate === !1) continue;
      r.copy(O.mapSize);
      const Y = O.getFrameExtents();
      if (
        (r.multiply(Y),
        s.copy(O.mapSize),
        (r.x > c || r.y > c) &&
          (r.x > c &&
            ((s.x = Math.floor(c / Y.x)),
            (r.x = s.x * Y.x),
            (O.mapSize.x = s.x)),
          r.y > c &&
            ((s.y = Math.floor(c / Y.y)),
            (r.y = s.y * Y.y),
            (O.mapSize.y = s.y))),
        O.map === null || W === !0 || q === !0)
      ) {
        const se = this.type !== uo ? { minFilter: bi, magFilter: bi } : {};
        O.map !== null && O.map.dispose(),
          (O.map = new Ko(r.x, r.y, se)),
          (O.map.texture.name = te.name + ".shadowMap"),
          O.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(O.map), n.clear();
      const F = O.getViewportCount();
      for (let se = 0; se < F; se++) {
        const Me = O.getViewport(se);
        o.set(s.x * Me.x, s.y * Me.y, s.x * Me.z, s.y * Me.w),
          G.viewport(o),
          O.updateMatrices(te, se),
          (i = O.getFrustum()),
          w(P, I, O.camera, te, this.type);
      }
      O.isPointLightShadow !== !0 && this.type === uo && A(O, I),
        (O.needsUpdate = !1);
    }
    (g = this.type), (x.needsUpdate = !1), n.setRenderTarget(R, T, D);
  };
  function A(b, P) {
    const I = e.update(_);
    p.defines.VSM_SAMPLES !== b.blurSamples &&
      ((p.defines.VSM_SAMPLES = b.blurSamples),
      (m.defines.VSM_SAMPLES = b.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      b.mapPass === null && (b.mapPass = new Ko(r.x, r.y)),
      (p.uniforms.shadow_pass.value = b.map.texture),
      (p.uniforms.resolution.value = b.mapSize),
      (p.uniforms.radius.value = b.radius),
      n.setRenderTarget(b.mapPass),
      n.clear(),
      n.renderBufferDirect(P, null, I, p, _, null),
      (m.uniforms.shadow_pass.value = b.mapPass.texture),
      (m.uniforms.resolution.value = b.mapSize),
      (m.uniforms.radius.value = b.radius),
      n.setRenderTarget(b.map),
      n.clear(),
      n.renderBufferDirect(P, null, I, m, _, null);
  }
  function S(b, P, I, R) {
    let T = null;
    const D =
      I.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
    if (D !== void 0) T = D;
    else if (
      ((T = I.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        P.clipShadows === !0 &&
        Array.isArray(P.clippingPlanes) &&
        P.clippingPlanes.length !== 0) ||
        (P.displacementMap && P.displacementScale !== 0) ||
        (P.alphaMap && P.alphaTest > 0) ||
        (P.map && P.alphaTest > 0))
    ) {
      const G = T.uuid,
        W = P.uuid;
      let q = u[G];
      q === void 0 && ((q = {}), (u[G] = q));
      let Z = q[W];
      Z === void 0 &&
        ((Z = T.clone()), (q[W] = Z), P.addEventListener("dispose", C)),
        (T = Z);
    }
    if (
      ((T.visible = P.visible),
      (T.wireframe = P.wireframe),
      R === uo
        ? (T.side = P.shadowSide !== null ? P.shadowSide : P.side)
        : (T.side = P.shadowSide !== null ? P.shadowSide : d[P.side]),
      (T.alphaMap = P.alphaMap),
      (T.alphaTest = P.alphaTest),
      (T.map = P.map),
      (T.clipShadows = P.clipShadows),
      (T.clippingPlanes = P.clippingPlanes),
      (T.clipIntersection = P.clipIntersection),
      (T.displacementMap = P.displacementMap),
      (T.displacementScale = P.displacementScale),
      (T.displacementBias = P.displacementBias),
      (T.wireframeLinewidth = P.wireframeLinewidth),
      (T.linewidth = P.linewidth),
      I.isPointLight === !0 && T.isMeshDistanceMaterial === !0)
    ) {
      const G = n.properties.get(T);
      G.light = I;
    }
    return T;
  }
  function w(b, P, I, R, T) {
    if (b.visible === !1) return;
    if (
      b.layers.test(P.layers) &&
      (b.isMesh || b.isLine || b.isPoints) &&
      (b.castShadow || (b.receiveShadow && T === uo)) &&
      (!b.frustumCulled || i.intersectsObject(b))
    ) {
      b.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, b.matrixWorld);
      const W = e.update(b),
        q = b.material;
      if (Array.isArray(q)) {
        const Z = W.groups;
        for (let K = 0, te = Z.length; K < te; K++) {
          const O = Z[K],
            Y = q[O.materialIndex];
          if (Y && Y.visible) {
            const F = S(b, Y, R, T);
            b.onBeforeShadow(n, b, P, I, W, F, O),
              n.renderBufferDirect(I, null, W, F, b, O),
              b.onAfterShadow(n, b, P, I, W, F, O);
          }
        }
      } else if (q.visible) {
        const Z = S(b, q, R, T);
        b.onBeforeShadow(n, b, P, I, W, Z, null),
          n.renderBufferDirect(I, null, W, Z, b, null),
          b.onAfterShadow(n, b, P, I, W, Z, null);
      }
    }
    const G = b.children;
    for (let W = 0, q = G.length; W < q; W++) w(G[W], P, I, R, T);
  }
  function C(b) {
    b.target.removeEventListener("dispose", C);
    for (const I in u) {
      const R = u[I],
        T = b.target.uuid;
      T in R && (R[T].dispose(), delete R[T]);
    }
  }
}
const aJ = {
  [Ty]: Cy,
  [by]: By,
  [Ry]: Iy,
  [xc]: Py,
  [Cy]: Ty,
  [By]: by,
  [Iy]: Ry,
  [Py]: xc,
};
function lJ(n, e) {
  function t() {
    let V = !1;
    const be = new tn();
    let ue = null;
    const ge = new tn(0, 0, 0, 0);
    return {
      setMask: function (Ue) {
        ue !== Ue && !V && (n.colorMask(Ue, Ue, Ue, Ue), (ue = Ue));
      },
      setLocked: function (Ue) {
        V = Ue;
      },
      setClear: function (Ue, ke, ft, Ct, cn) {
        cn === !0 && ((Ue *= Ct), (ke *= Ct), (ft *= Ct)),
          be.set(Ue, ke, ft, Ct),
          ge.equals(be) === !1 && (n.clearColor(Ue, ke, ft, Ct), ge.copy(be));
      },
      reset: function () {
        (V = !1), (ue = null), ge.set(-1, 0, 0, 0);
      },
    };
  }
  function i() {
    let V = !1,
      be = !1,
      ue = null,
      ge = null,
      Ue = null;
    return {
      setReversed: function (ke) {
        if (be !== ke) {
          const ft = e.get("EXT_clip_control");
          be
            ? ft.clipControlEXT(ft.LOWER_LEFT_EXT, ft.ZERO_TO_ONE_EXT)
            : ft.clipControlEXT(ft.LOWER_LEFT_EXT, ft.NEGATIVE_ONE_TO_ONE_EXT);
          const Ct = Ue;
          (Ue = null), this.setClear(Ct);
        }
        be = ke;
      },
      getReversed: function () {
        return be;
      },
      setTest: function (ke) {
        ke ? Se(n.DEPTH_TEST) : Xe(n.DEPTH_TEST);
      },
      setMask: function (ke) {
        ue !== ke && !V && (n.depthMask(ke), (ue = ke));
      },
      setFunc: function (ke) {
        if ((be && (ke = aJ[ke]), ge !== ke)) {
          switch (ke) {
            case Ty:
              n.depthFunc(n.NEVER);
              break;
            case Cy:
              n.depthFunc(n.ALWAYS);
              break;
            case by:
              n.depthFunc(n.LESS);
              break;
            case xc:
              n.depthFunc(n.LEQUAL);
              break;
            case Ry:
              n.depthFunc(n.EQUAL);
              break;
            case Py:
              n.depthFunc(n.GEQUAL);
              break;
            case By:
              n.depthFunc(n.GREATER);
              break;
            case Iy:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          ge = ke;
        }
      },
      setLocked: function (ke) {
        V = ke;
      },
      setClear: function (ke) {
        Ue !== ke && (be && (ke = 1 - ke), n.clearDepth(ke), (Ue = ke));
      },
      reset: function () {
        (V = !1), (ue = null), (ge = null), (Ue = null), (be = !1);
      },
    };
  }
  function r() {
    let V = !1,
      be = null,
      ue = null,
      ge = null,
      Ue = null,
      ke = null,
      ft = null,
      Ct = null,
      cn = null;
    return {
      setTest: function (We) {
        V || (We ? Se(n.STENCIL_TEST) : Xe(n.STENCIL_TEST));
      },
      setMask: function (We) {
        be !== We && !V && (n.stencilMask(We), (be = We));
      },
      setFunc: function (We, nt, Et) {
        (ue !== We || ge !== nt || Ue !== Et) &&
          (n.stencilFunc(We, nt, Et), (ue = We), (ge = nt), (Ue = Et));
      },
      setOp: function (We, nt, Et) {
        (ke !== We || ft !== nt || Ct !== Et) &&
          (n.stencilOp(We, nt, Et), (ke = We), (ft = nt), (Ct = Et));
      },
      setLocked: function (We) {
        V = We;
      },
      setClear: function (We) {
        cn !== We && (n.clearStencil(We), (cn = We));
      },
      reset: function () {
        (V = !1),
          (be = null),
          (ue = null),
          (ge = null),
          (Ue = null),
          (ke = null),
          (ft = null),
          (Ct = null),
          (cn = null);
      },
    };
  }
  const s = new t(),
    o = new i(),
    a = new r(),
    l = new WeakMap(),
    u = new WeakMap();
  let c = {},
    d = {},
    p = new WeakMap(),
    m = [],
    v = null,
    _ = !1,
    x = null,
    g = null,
    A = null,
    S = null,
    w = null,
    C = null,
    b = null,
    P = new Ze(0, 0, 0),
    I = 0,
    R = !1,
    T = null,
    D = null,
    G = null,
    W = null,
    q = null;
  const Z = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let K = !1,
    te = 0;
  const O = n.getParameter(n.VERSION);
  O.indexOf("WebGL") !== -1
    ? ((te = parseFloat(/^WebGL (\d)/.exec(O)[1])), (K = te >= 1))
    : O.indexOf("OpenGL ES") !== -1 &&
      ((te = parseFloat(/^OpenGL ES (\d)/.exec(O)[1])), (K = te >= 2));
  let Y = null,
    F = {};
  const se = n.getParameter(n.SCISSOR_BOX),
    Me = n.getParameter(n.VIEWPORT),
    De = new tn().fromArray(se),
    re = new tn().fromArray(Me);
  function xe(V, be, ue, ge) {
    const Ue = new Uint8Array(4),
      ke = n.createTexture();
    n.bindTexture(V, ke),
      n.texParameteri(V, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(V, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let ft = 0; ft < ue; ft++)
      V === n.TEXTURE_3D || V === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(be, 0, n.RGBA, 1, 1, ge, 0, n.RGBA, n.UNSIGNED_BYTE, Ue)
        : n.texImage2D(
            be + ft,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            Ue
          );
    return ke;
  }
  const Ce = {};
  (Ce[n.TEXTURE_2D] = xe(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (Ce[n.TEXTURE_CUBE_MAP] = xe(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (Ce[n.TEXTURE_2D_ARRAY] = xe(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (Ce[n.TEXTURE_3D] = xe(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    Se(n.DEPTH_TEST),
    o.setFunc(xc),
    we(!1),
    J(XM),
    Se(n.CULL_FACE),
    k(Ca);
  function Se(V) {
    c[V] !== !0 && (n.enable(V), (c[V] = !0));
  }
  function Xe(V) {
    c[V] !== !1 && (n.disable(V), (c[V] = !1));
  }
  function et(V, be) {
    return d[V] !== be
      ? (n.bindFramebuffer(V, be),
        (d[V] = be),
        V === n.DRAW_FRAMEBUFFER && (d[n.FRAMEBUFFER] = be),
        V === n.FRAMEBUFFER && (d[n.DRAW_FRAMEBUFFER] = be),
        !0)
      : !1;
  }
  function Ye(V, be) {
    let ue = m,
      ge = !1;
    if (V) {
      (ue = p.get(be)), ue === void 0 && ((ue = []), p.set(be, ue));
      const Ue = V.textures;
      if (ue.length !== Ue.length || ue[0] !== n.COLOR_ATTACHMENT0) {
        for (let ke = 0, ft = Ue.length; ke < ft; ke++)
          ue[ke] = n.COLOR_ATTACHMENT0 + ke;
        (ue.length = Ue.length), (ge = !0);
      }
    } else ue[0] !== n.BACK && ((ue[0] = n.BACK), (ge = !0));
    ge && n.drawBuffers(ue);
  }
  function Fe(V) {
    return v !== V ? (n.useProgram(V), (v = V), !0) : !1;
  }
  const de = {
    [gl]: n.FUNC_ADD,
    [vF]: n.FUNC_SUBTRACT,
    [yF]: n.FUNC_REVERSE_SUBTRACT,
  };
  (de[_F] = n.MIN), (de[xF] = n.MAX);
  const ce = {
    [AF]: n.ZERO,
    [SF]: n.ONE,
    [MF]: n.SRC_COLOR,
    [wy]: n.SRC_ALPHA,
    [RF]: n.SRC_ALPHA_SATURATE,
    [CF]: n.DST_COLOR,
    [EF]: n.DST_ALPHA,
    [wF]: n.ONE_MINUS_SRC_COLOR,
    [Ey]: n.ONE_MINUS_SRC_ALPHA,
    [bF]: n.ONE_MINUS_DST_COLOR,
    [TF]: n.ONE_MINUS_DST_ALPHA,
    [PF]: n.CONSTANT_COLOR,
    [BF]: n.ONE_MINUS_CONSTANT_COLOR,
    [IF]: n.CONSTANT_ALPHA,
    [DF]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function k(V, be, ue, ge, Ue, ke, ft, Ct, cn, We) {
    if (V === Ca) {
      _ === !0 && (Xe(n.BLEND), (_ = !1));
      return;
    }
    if ((_ === !1 && (Se(n.BLEND), (_ = !0)), V !== gF)) {
      if (V !== x || We !== R) {
        if (
          ((g !== gl || w !== gl) &&
            (n.blendEquation(n.FUNC_ADD), (g = gl), (w = gl)),
          We)
        )
          switch (V) {
            case nc:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case JM:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case jM:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case YM:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", V);
              break;
          }
        else
          switch (V) {
            case nc:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case JM:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case jM:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case YM:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", V);
              break;
          }
        (A = null),
          (S = null),
          (C = null),
          (b = null),
          P.set(0, 0, 0),
          (I = 0),
          (x = V),
          (R = We);
      }
      return;
    }
    (Ue = Ue || be),
      (ke = ke || ue),
      (ft = ft || ge),
      (be !== g || Ue !== w) &&
        (n.blendEquationSeparate(de[be], de[Ue]), (g = be), (w = Ue)),
      (ue !== A || ge !== S || ke !== C || ft !== b) &&
        (n.blendFuncSeparate(ce[ue], ce[ge], ce[ke], ce[ft]),
        (A = ue),
        (S = ge),
        (C = ke),
        (b = ft)),
      (Ct.equals(P) === !1 || cn !== I) &&
        (n.blendColor(Ct.r, Ct.g, Ct.b, cn), P.copy(Ct), (I = cn)),
      (x = V),
      (R = !1);
  }
  function Ve(V, be) {
    V.side === Vs ? Xe(n.CULL_FACE) : Se(n.CULL_FACE);
    let ue = V.side === Ar;
    be && (ue = !ue),
      we(ue),
      V.blending === nc && V.transparent === !1
        ? k(Ca)
        : k(
            V.blending,
            V.blendEquation,
            V.blendSrc,
            V.blendDst,
            V.blendEquationAlpha,
            V.blendSrcAlpha,
            V.blendDstAlpha,
            V.blendColor,
            V.blendAlpha,
            V.premultipliedAlpha
          ),
      o.setFunc(V.depthFunc),
      o.setTest(V.depthTest),
      o.setMask(V.depthWrite),
      s.setMask(V.colorWrite);
    const ge = V.stencilWrite;
    a.setTest(ge),
      ge &&
        (a.setMask(V.stencilWriteMask),
        a.setFunc(V.stencilFunc, V.stencilRef, V.stencilFuncMask),
        a.setOp(V.stencilFail, V.stencilZFail, V.stencilZPass)),
      st(V.polygonOffset, V.polygonOffsetFactor, V.polygonOffsetUnits),
      V.alphaToCoverage === !0
        ? Se(n.SAMPLE_ALPHA_TO_COVERAGE)
        : Xe(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function we(V) {
    T !== V && (V ? n.frontFace(n.CW) : n.frontFace(n.CCW), (T = V));
  }
  function J(V) {
    V !== dF
      ? (Se(n.CULL_FACE),
        V !== D &&
          (V === XM
            ? n.cullFace(n.BACK)
            : V === pF
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : Xe(n.CULL_FACE),
      (D = V);
  }
  function Te(V) {
    V !== G && (K && n.lineWidth(V), (G = V));
  }
  function st(V, be, ue) {
    V
      ? (Se(n.POLYGON_OFFSET_FILL),
        (W !== be || q !== ue) && (n.polygonOffset(be, ue), (W = be), (q = ue)))
      : Xe(n.POLYGON_OFFSET_FILL);
  }
  function Le(V) {
    V ? Se(n.SCISSOR_TEST) : Xe(n.SCISSOR_TEST);
  }
  function U(V) {
    V === void 0 && (V = n.TEXTURE0 + Z - 1),
      Y !== V && (n.activeTexture(V), (Y = V));
  }
  function L(V, be, ue) {
    ue === void 0 && (Y === null ? (ue = n.TEXTURE0 + Z - 1) : (ue = Y));
    let ge = F[ue];
    ge === void 0 && ((ge = { type: void 0, texture: void 0 }), (F[ue] = ge)),
      (ge.type !== V || ge.texture !== be) &&
        (Y !== ue && (n.activeTexture(ue), (Y = ue)),
        n.bindTexture(V, be || Ce[V]),
        (ge.type = V),
        (ge.texture = be));
  }
  function ie() {
    const V = F[Y];
    V !== void 0 &&
      V.type !== void 0 &&
      (n.bindTexture(V.type, null), (V.type = void 0), (V.texture = void 0));
  }
  function fe() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function ye() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function me() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function Pe() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function Ie() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function ze() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function Mt() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function Re() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function Ne() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function mt() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (V) {
      console.error("THREE.WebGLState:", V);
    }
  }
  function dt(V) {
    De.equals(V) === !1 && (n.scissor(V.x, V.y, V.z, V.w), De.copy(V));
  }
  function Ke(V) {
    re.equals(V) === !1 && (n.viewport(V.x, V.y, V.z, V.w), re.copy(V));
  }
  function X(V, be) {
    let ue = u.get(be);
    ue === void 0 && ((ue = new WeakMap()), u.set(be, ue));
    let ge = ue.get(V);
    ge === void 0 && ((ge = n.getUniformBlockIndex(be, V.name)), ue.set(V, ge));
  }
  function pe(V, be) {
    const ge = u.get(be).get(V);
    l.get(be) !== ge &&
      (n.uniformBlockBinding(be, ge, V.__bindingPointIndex), l.set(be, ge));
  }
  function He() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      o.setReversed(!1),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (c = {}),
      (Y = null),
      (F = {}),
      (d = {}),
      (p = new WeakMap()),
      (m = []),
      (v = null),
      (_ = !1),
      (x = null),
      (g = null),
      (A = null),
      (S = null),
      (w = null),
      (C = null),
      (b = null),
      (P = new Ze(0, 0, 0)),
      (I = 0),
      (R = !1),
      (T = null),
      (D = null),
      (G = null),
      (W = null),
      (q = null),
      De.set(0, 0, n.canvas.width, n.canvas.height),
      re.set(0, 0, n.canvas.width, n.canvas.height),
      s.reset(),
      o.reset(),
      a.reset();
  }
  return {
    buffers: { color: s, depth: o, stencil: a },
    enable: Se,
    disable: Xe,
    bindFramebuffer: et,
    drawBuffers: Ye,
    useProgram: Fe,
    setBlending: k,
    setMaterial: Ve,
    setFlipSided: we,
    setCullFace: J,
    setLineWidth: Te,
    setPolygonOffset: st,
    setScissorTest: Le,
    activeTexture: U,
    bindTexture: L,
    unbindTexture: ie,
    compressedTexImage2D: fe,
    compressedTexImage3D: ye,
    texImage2D: Ne,
    texImage3D: mt,
    updateUBOMapping: X,
    uniformBlockBinding: pe,
    texStorage2D: Mt,
    texStorage3D: Re,
    texSubImage2D: me,
    texSubImage3D: Pe,
    compressedTexSubImage2D: Ie,
    compressedTexSubImage3D: ze,
    scissor: dt,
    viewport: Ke,
    reset: He,
  };
}
function uJ(n, e, t, i, r, s, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    l =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    u = new Ae(),
    c = new WeakMap();
  let d;
  const p = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function v(U, L) {
    return m ? new OffscreenCanvas(U, L) : hm("canvas");
  }
  function _(U, L, ie) {
    let fe = 1;
    const ye = Le(U);
    if (
      ((ye.width > ie || ye.height > ie) &&
        (fe = ie / Math.max(ye.width, ye.height)),
      fe < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && U instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && U instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && U instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && U instanceof VideoFrame)
      ) {
        const me = Math.floor(fe * ye.width),
          Pe = Math.floor(fe * ye.height);
        d === void 0 && (d = v(me, Pe));
        const Ie = L ? v(me, Pe) : d;
        return (
          (Ie.width = me),
          (Ie.height = Pe),
          Ie.getContext("2d").drawImage(U, 0, 0, me, Pe),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              ye.width +
              "x" +
              ye.height +
              ") to (" +
              me +
              "x" +
              Pe +
              ")."
          ),
          Ie
        );
      } else
        return (
          "data" in U &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                ye.width +
                "x" +
                ye.height +
                ")."
            ),
          U
        );
    return U;
  }
  function x(U) {
    return U.generateMipmaps;
  }
  function g(U) {
    n.generateMipmap(U);
  }
  function A(U) {
    return U.isWebGLCubeRenderTarget
      ? n.TEXTURE_CUBE_MAP
      : U.isWebGL3DRenderTarget
      ? n.TEXTURE_3D
      : U.isWebGLArrayRenderTarget || U.isCompressedArrayTexture
      ? n.TEXTURE_2D_ARRAY
      : n.TEXTURE_2D;
  }
  function S(U, L, ie, fe, ye = !1) {
    if (U !== null) {
      if (n[U] !== void 0) return n[U];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          U +
          "'"
      );
    }
    let me = L;
    if (
      (L === n.RED &&
        (ie === n.FLOAT && (me = n.R32F),
        ie === n.HALF_FLOAT && (me = n.R16F),
        ie === n.UNSIGNED_BYTE && (me = n.R8)),
      L === n.RED_INTEGER &&
        (ie === n.UNSIGNED_BYTE && (me = n.R8UI),
        ie === n.UNSIGNED_SHORT && (me = n.R16UI),
        ie === n.UNSIGNED_INT && (me = n.R32UI),
        ie === n.BYTE && (me = n.R8I),
        ie === n.SHORT && (me = n.R16I),
        ie === n.INT && (me = n.R32I)),
      L === n.RG &&
        (ie === n.FLOAT && (me = n.RG32F),
        ie === n.HALF_FLOAT && (me = n.RG16F),
        ie === n.UNSIGNED_BYTE && (me = n.RG8)),
      L === n.RG_INTEGER &&
        (ie === n.UNSIGNED_BYTE && (me = n.RG8UI),
        ie === n.UNSIGNED_SHORT && (me = n.RG16UI),
        ie === n.UNSIGNED_INT && (me = n.RG32UI),
        ie === n.BYTE && (me = n.RG8I),
        ie === n.SHORT && (me = n.RG16I),
        ie === n.INT && (me = n.RG32I)),
      L === n.RGB_INTEGER &&
        (ie === n.UNSIGNED_BYTE && (me = n.RGB8UI),
        ie === n.UNSIGNED_SHORT && (me = n.RGB16UI),
        ie === n.UNSIGNED_INT && (me = n.RGB32UI),
        ie === n.BYTE && (me = n.RGB8I),
        ie === n.SHORT && (me = n.RGB16I),
        ie === n.INT && (me = n.RGB32I)),
      L === n.RGBA_INTEGER &&
        (ie === n.UNSIGNED_BYTE && (me = n.RGBA8UI),
        ie === n.UNSIGNED_SHORT && (me = n.RGBA16UI),
        ie === n.UNSIGNED_INT && (me = n.RGBA32UI),
        ie === n.BYTE && (me = n.RGBA8I),
        ie === n.SHORT && (me = n.RGBA16I),
        ie === n.INT && (me = n.RGBA32I)),
      L === n.RGB && ie === n.UNSIGNED_INT_5_9_9_9_REV && (me = n.RGB9_E5),
      L === n.RGBA)
    ) {
      const Pe = ye ? um : en.getTransfer(fe);
      ie === n.FLOAT && (me = n.RGBA32F),
        ie === n.HALF_FLOAT && (me = n.RGBA16F),
        ie === n.UNSIGNED_BYTE && (me = Pe === pn ? n.SRGB8_ALPHA8 : n.RGBA8),
        ie === n.UNSIGNED_SHORT_4_4_4_4 && (me = n.RGBA4),
        ie === n.UNSIGNED_SHORT_5_5_5_1 && (me = n.RGB5_A1);
    }
    return (
      (me === n.R16F ||
        me === n.R32F ||
        me === n.RG16F ||
        me === n.RG32F ||
        me === n.RGBA16F ||
        me === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      me
    );
  }
  function w(U, L) {
    let ie;
    return (
      U
        ? L === null || L === Ua || L === Ac
          ? (ie = n.DEPTH24_STENCIL8)
          : L === kr
          ? (ie = n.DEPTH32F_STENCIL8)
          : L === Eh &&
            ((ie = n.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : L === null || L === Ua || L === Ac
        ? (ie = n.DEPTH_COMPONENT24)
        : L === kr
        ? (ie = n.DEPTH_COMPONENT32F)
        : L === Eh && (ie = n.DEPTH_COMPONENT16),
      ie
    );
  }
  function C(U, L) {
    return x(U) === !0 ||
      (U.isFramebufferTexture && U.minFilter !== bi && U.minFilter !== Zn)
      ? Math.log2(Math.max(L.width, L.height)) + 1
      : U.mipmaps !== void 0 && U.mipmaps.length > 0
      ? U.mipmaps.length
      : U.isCompressedTexture && Array.isArray(U.image)
      ? L.mipmaps.length
      : 1;
  }
  function b(U) {
    const L = U.target;
    L.removeEventListener("dispose", b), I(L), L.isVideoTexture && c.delete(L);
  }
  function P(U) {
    const L = U.target;
    L.removeEventListener("dispose", P), T(L);
  }
  function I(U) {
    const L = i.get(U);
    if (L.__webglInit === void 0) return;
    const ie = U.source,
      fe = p.get(ie);
    if (fe) {
      const ye = fe[L.__cacheKey];
      ye.usedTimes--,
        ye.usedTimes === 0 && R(U),
        Object.keys(fe).length === 0 && p.delete(ie);
    }
    i.remove(U);
  }
  function R(U) {
    const L = i.get(U);
    n.deleteTexture(L.__webglTexture);
    const ie = U.source,
      fe = p.get(ie);
    delete fe[L.__cacheKey], o.memory.textures--;
  }
  function T(U) {
    const L = i.get(U);
    if (
      (U.depthTexture && (U.depthTexture.dispose(), i.remove(U.depthTexture)),
      U.isWebGLCubeRenderTarget)
    )
      for (let fe = 0; fe < 6; fe++) {
        if (Array.isArray(L.__webglFramebuffer[fe]))
          for (let ye = 0; ye < L.__webglFramebuffer[fe].length; ye++)
            n.deleteFramebuffer(L.__webglFramebuffer[fe][ye]);
        else n.deleteFramebuffer(L.__webglFramebuffer[fe]);
        L.__webglDepthbuffer && n.deleteRenderbuffer(L.__webglDepthbuffer[fe]);
      }
    else {
      if (Array.isArray(L.__webglFramebuffer))
        for (let fe = 0; fe < L.__webglFramebuffer.length; fe++)
          n.deleteFramebuffer(L.__webglFramebuffer[fe]);
      else n.deleteFramebuffer(L.__webglFramebuffer);
      if (
        (L.__webglDepthbuffer && n.deleteRenderbuffer(L.__webglDepthbuffer),
        L.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(L.__webglMultisampledFramebuffer),
        L.__webglColorRenderbuffer)
      )
        for (let fe = 0; fe < L.__webglColorRenderbuffer.length; fe++)
          L.__webglColorRenderbuffer[fe] &&
            n.deleteRenderbuffer(L.__webglColorRenderbuffer[fe]);
      L.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(L.__webglDepthRenderbuffer);
    }
    const ie = U.textures;
    for (let fe = 0, ye = ie.length; fe < ye; fe++) {
      const me = i.get(ie[fe]);
      me.__webglTexture &&
        (n.deleteTexture(me.__webglTexture), o.memory.textures--),
        i.remove(ie[fe]);
    }
    i.remove(U);
  }
  let D = 0;
  function G() {
    D = 0;
  }
  function W() {
    const U = D;
    return (
      U >= r.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            U +
            " texture units while this GPU supports only " +
            r.maxTextures
        ),
      (D += 1),
      U
    );
  }
  function q(U) {
    const L = [];
    return (
      L.push(U.wrapS),
      L.push(U.wrapT),
      L.push(U.wrapR || 0),
      L.push(U.magFilter),
      L.push(U.minFilter),
      L.push(U.anisotropy),
      L.push(U.internalFormat),
      L.push(U.format),
      L.push(U.type),
      L.push(U.generateMipmaps),
      L.push(U.premultiplyAlpha),
      L.push(U.flipY),
      L.push(U.unpackAlignment),
      L.push(U.colorSpace),
      L.join()
    );
  }
  function Z(U, L) {
    const ie = i.get(U);
    if (
      (U.isVideoTexture && Te(U),
      U.isRenderTargetTexture === !1 &&
        U.version > 0 &&
        ie.__version !== U.version)
    ) {
      const fe = U.image;
      if (fe === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (fe.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        re(ie, U, L);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, ie.__webglTexture, n.TEXTURE0 + L);
  }
  function K(U, L) {
    const ie = i.get(U);
    if (U.version > 0 && ie.__version !== U.version) {
      re(ie, U, L);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, ie.__webglTexture, n.TEXTURE0 + L);
  }
  function te(U, L) {
    const ie = i.get(U);
    if (U.version > 0 && ie.__version !== U.version) {
      re(ie, U, L);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, ie.__webglTexture, n.TEXTURE0 + L);
  }
  function O(U, L) {
    const ie = i.get(U);
    if (U.version > 0 && ie.__version !== U.version) {
      xe(ie, U, L);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, ie.__webglTexture, n.TEXTURE0 + L);
  }
  const Y = { [zl]: n.REPEAT, [fs]: n.CLAMP_TO_EDGE, [wh]: n.MIRRORED_REPEAT },
    F = {
      [bi]: n.NEAREST,
      [tx]: n.NEAREST_MIPMAP_NEAREST,
      [Wu]: n.NEAREST_MIPMAP_LINEAR,
      [Zn]: n.LINEAR,
      [ah]: n.LINEAR_MIPMAP_NEAREST,
      [Xs]: n.LINEAR_MIPMAP_LINEAR,
    },
    se = {
      [QF]: n.NEVER,
      [nN]: n.ALWAYS,
      [ZF]: n.LESS,
      [fT]: n.LEQUAL,
      [qF]: n.EQUAL,
      [tN]: n.GEQUAL,
      [$F]: n.GREATER,
      [eN]: n.NOTEQUAL,
    };
  function Me(U, L) {
    if (
      (L.type === kr &&
        e.has("OES_texture_float_linear") === !1 &&
        (L.magFilter === Zn ||
          L.magFilter === ah ||
          L.magFilter === Wu ||
          L.magFilter === Xs ||
          L.minFilter === Zn ||
          L.minFilter === ah ||
          L.minFilter === Wu ||
          L.minFilter === Xs) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      n.texParameteri(U, n.TEXTURE_WRAP_S, Y[L.wrapS]),
      n.texParameteri(U, n.TEXTURE_WRAP_T, Y[L.wrapT]),
      (U === n.TEXTURE_3D || U === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(U, n.TEXTURE_WRAP_R, Y[L.wrapR]),
      n.texParameteri(U, n.TEXTURE_MAG_FILTER, F[L.magFilter]),
      n.texParameteri(U, n.TEXTURE_MIN_FILTER, F[L.minFilter]),
      L.compareFunction &&
        (n.texParameteri(U, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(U, n.TEXTURE_COMPARE_FUNC, se[L.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        L.magFilter === bi ||
        (L.minFilter !== Wu && L.minFilter !== Xs) ||
        (L.type === kr && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (L.anisotropy > 1 || i.get(L).__currentAnisotropy) {
        const ie = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(
          U,
          ie.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(L.anisotropy, r.getMaxAnisotropy())
        ),
          (i.get(L).__currentAnisotropy = L.anisotropy);
      }
    }
  }
  function De(U, L) {
    let ie = !1;
    U.__webglInit === void 0 &&
      ((U.__webglInit = !0), L.addEventListener("dispose", b));
    const fe = L.source;
    let ye = p.get(fe);
    ye === void 0 && ((ye = {}), p.set(fe, ye));
    const me = q(L);
    if (me !== U.__cacheKey) {
      ye[me] === void 0 &&
        ((ye[me] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (ie = !0)),
        ye[me].usedTimes++;
      const Pe = ye[U.__cacheKey];
      Pe !== void 0 &&
        (ye[U.__cacheKey].usedTimes--, Pe.usedTimes === 0 && R(L)),
        (U.__cacheKey = me),
        (U.__webglTexture = ye[me].texture);
    }
    return ie;
  }
  function re(U, L, ie) {
    let fe = n.TEXTURE_2D;
    (L.isDataArrayTexture || L.isCompressedArrayTexture) &&
      (fe = n.TEXTURE_2D_ARRAY),
      L.isData3DTexture && (fe = n.TEXTURE_3D);
    const ye = De(U, L),
      me = L.source;
    t.bindTexture(fe, U.__webglTexture, n.TEXTURE0 + ie);
    const Pe = i.get(me);
    if (me.version !== Pe.__version || ye === !0) {
      t.activeTexture(n.TEXTURE0 + ie);
      const Ie = en.getPrimaries(en.workingColorSpace),
        ze = L.colorSpace === va ? null : en.getPrimaries(L.colorSpace),
        Mt =
          L.colorSpace === va || Ie === ze ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, L.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, L.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Mt);
      let Re = _(L.image, !1, r.maxTextureSize);
      Re = st(L, Re);
      const Ne = s.convert(L.format, L.colorSpace),
        mt = s.convert(L.type);
      let dt = S(L.internalFormat, Ne, mt, L.colorSpace, L.isVideoTexture);
      Me(fe, L);
      let Ke;
      const X = L.mipmaps,
        pe = L.isVideoTexture !== !0,
        He = Pe.__version === void 0 || ye === !0,
        V = me.dataReady,
        be = C(L, Re);
      if (L.isDepthTexture)
        (dt = w(L.format === Sc, L.type)),
          He &&
            (pe
              ? t.texStorage2D(n.TEXTURE_2D, 1, dt, Re.width, Re.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  dt,
                  Re.width,
                  Re.height,
                  0,
                  Ne,
                  mt,
                  null
                ));
      else if (L.isDataTexture)
        if (X.length > 0) {
          pe &&
            He &&
            t.texStorage2D(n.TEXTURE_2D, be, dt, X[0].width, X[0].height);
          for (let ue = 0, ge = X.length; ue < ge; ue++)
            (Ke = X[ue]),
              pe
                ? V &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    ue,
                    0,
                    0,
                    Ke.width,
                    Ke.height,
                    Ne,
                    mt,
                    Ke.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    ue,
                    dt,
                    Ke.width,
                    Ke.height,
                    0,
                    Ne,
                    mt,
                    Ke.data
                  );
          L.generateMipmaps = !1;
        } else
          pe
            ? (He && t.texStorage2D(n.TEXTURE_2D, be, dt, Re.width, Re.height),
              V &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Re.width,
                  Re.height,
                  Ne,
                  mt,
                  Re.data
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                dt,
                Re.width,
                Re.height,
                0,
                Ne,
                mt,
                Re.data
              );
      else if (L.isCompressedTexture)
        if (L.isCompressedArrayTexture) {
          pe &&
            He &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              be,
              dt,
              X[0].width,
              X[0].height,
              Re.depth
            );
          for (let ue = 0, ge = X.length; ue < ge; ue++)
            if (((Ke = X[ue]), L.format !== $i))
              if (Ne !== null)
                if (pe) {
                  if (V)
                    if (L.layerUpdates.size > 0) {
                      const Ue = rw(Ke.width, Ke.height, L.format, L.type);
                      for (const ke of L.layerUpdates) {
                        const ft = Ke.data.subarray(
                          (ke * Ue) / Ke.data.BYTES_PER_ELEMENT,
                          ((ke + 1) * Ue) / Ke.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          ue,
                          0,
                          0,
                          ke,
                          Ke.width,
                          Ke.height,
                          1,
                          Ne,
                          ft
                        );
                      }
                      L.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        ue,
                        0,
                        0,
                        0,
                        Ke.width,
                        Ke.height,
                        Re.depth,
                        Ne,
                        Ke.data
                      );
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    ue,
                    dt,
                    Ke.width,
                    Ke.height,
                    Re.depth,
                    0,
                    Ke.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              pe
                ? V &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    ue,
                    0,
                    0,
                    0,
                    Ke.width,
                    Ke.height,
                    Re.depth,
                    Ne,
                    mt,
                    Ke.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    ue,
                    dt,
                    Ke.width,
                    Ke.height,
                    Re.depth,
                    0,
                    Ne,
                    mt,
                    Ke.data
                  );
        } else {
          pe &&
            He &&
            t.texStorage2D(n.TEXTURE_2D, be, dt, X[0].width, X[0].height);
          for (let ue = 0, ge = X.length; ue < ge; ue++)
            (Ke = X[ue]),
              L.format !== $i
                ? Ne !== null
                  ? pe
                    ? V &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        ue,
                        0,
                        0,
                        Ke.width,
                        Ke.height,
                        Ne,
                        Ke.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        ue,
                        dt,
                        Ke.width,
                        Ke.height,
                        0,
                        Ke.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : pe
                ? V &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    ue,
                    0,
                    0,
                    Ke.width,
                    Ke.height,
                    Ne,
                    mt,
                    Ke.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    ue,
                    dt,
                    Ke.width,
                    Ke.height,
                    0,
                    Ne,
                    mt,
                    Ke.data
                  );
        }
      else if (L.isDataArrayTexture)
        if (pe) {
          if (
            (He &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                be,
                dt,
                Re.width,
                Re.height,
                Re.depth
              ),
            V)
          )
            if (L.layerUpdates.size > 0) {
              const ue = rw(Re.width, Re.height, L.format, L.type);
              for (const ge of L.layerUpdates) {
                const Ue = Re.data.subarray(
                  (ge * ue) / Re.data.BYTES_PER_ELEMENT,
                  ((ge + 1) * ue) / Re.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  ge,
                  Re.width,
                  Re.height,
                  1,
                  Ne,
                  mt,
                  Ue
                );
              }
              L.clearLayerUpdates();
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Re.width,
                Re.height,
                Re.depth,
                Ne,
                mt,
                Re.data
              );
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            dt,
            Re.width,
            Re.height,
            Re.depth,
            0,
            Ne,
            mt,
            Re.data
          );
      else if (L.isData3DTexture)
        pe
          ? (He &&
              t.texStorage3D(
                n.TEXTURE_3D,
                be,
                dt,
                Re.width,
                Re.height,
                Re.depth
              ),
            V &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Re.width,
                Re.height,
                Re.depth,
                Ne,
                mt,
                Re.data
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              dt,
              Re.width,
              Re.height,
              Re.depth,
              0,
              Ne,
              mt,
              Re.data
            );
      else if (L.isFramebufferTexture) {
        if (He)
          if (pe) t.texStorage2D(n.TEXTURE_2D, be, dt, Re.width, Re.height);
          else {
            let ue = Re.width,
              ge = Re.height;
            for (let Ue = 0; Ue < be; Ue++)
              t.texImage2D(n.TEXTURE_2D, Ue, dt, ue, ge, 0, Ne, mt, null),
                (ue >>= 1),
                (ge >>= 1);
          }
      } else if (X.length > 0) {
        if (pe && He) {
          const ue = Le(X[0]);
          t.texStorage2D(n.TEXTURE_2D, be, dt, ue.width, ue.height);
        }
        for (let ue = 0, ge = X.length; ue < ge; ue++)
          (Ke = X[ue]),
            pe
              ? V && t.texSubImage2D(n.TEXTURE_2D, ue, 0, 0, Ne, mt, Ke)
              : t.texImage2D(n.TEXTURE_2D, ue, dt, Ne, mt, Ke);
        L.generateMipmaps = !1;
      } else if (pe) {
        if (He) {
          const ue = Le(Re);
          t.texStorage2D(n.TEXTURE_2D, be, dt, ue.width, ue.height);
        }
        V && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ne, mt, Re);
      } else t.texImage2D(n.TEXTURE_2D, 0, dt, Ne, mt, Re);
      x(L) && g(fe), (Pe.__version = me.version), L.onUpdate && L.onUpdate(L);
    }
    U.__version = L.version;
  }
  function xe(U, L, ie) {
    if (L.image.length !== 6) return;
    const fe = De(U, L),
      ye = L.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, U.__webglTexture, n.TEXTURE0 + ie);
    const me = i.get(ye);
    if (ye.version !== me.__version || fe === !0) {
      t.activeTexture(n.TEXTURE0 + ie);
      const Pe = en.getPrimaries(en.workingColorSpace),
        Ie = L.colorSpace === va ? null : en.getPrimaries(L.colorSpace),
        ze =
          L.colorSpace === va || Pe === Ie ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, L.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, L.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ze);
      const Mt = L.isCompressedTexture || L.image[0].isCompressedTexture,
        Re = L.image[0] && L.image[0].isDataTexture,
        Ne = [];
      for (let ge = 0; ge < 6; ge++)
        !Mt && !Re
          ? (Ne[ge] = _(L.image[ge], !0, r.maxCubemapSize))
          : (Ne[ge] = Re ? L.image[ge].image : L.image[ge]),
          (Ne[ge] = st(L, Ne[ge]));
      const mt = Ne[0],
        dt = s.convert(L.format, L.colorSpace),
        Ke = s.convert(L.type),
        X = S(L.internalFormat, dt, Ke, L.colorSpace),
        pe = L.isVideoTexture !== !0,
        He = me.__version === void 0 || fe === !0,
        V = ye.dataReady;
      let be = C(L, mt);
      Me(n.TEXTURE_CUBE_MAP, L);
      let ue;
      if (Mt) {
        pe &&
          He &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, be, X, mt.width, mt.height);
        for (let ge = 0; ge < 6; ge++) {
          ue = Ne[ge].mipmaps;
          for (let Ue = 0; Ue < ue.length; Ue++) {
            const ke = ue[Ue];
            L.format !== $i
              ? dt !== null
                ? pe
                  ? V &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                      Ue,
                      0,
                      0,
                      ke.width,
                      ke.height,
                      dt,
                      ke.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                      Ue,
                      X,
                      ke.width,
                      ke.height,
                      0,
                      ke.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : pe
              ? V &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                  Ue,
                  0,
                  0,
                  ke.width,
                  ke.height,
                  dt,
                  Ke,
                  ke.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                  Ue,
                  X,
                  ke.width,
                  ke.height,
                  0,
                  dt,
                  Ke,
                  ke.data
                );
          }
        }
      } else {
        if (((ue = L.mipmaps), pe && He)) {
          ue.length > 0 && be++;
          const ge = Le(Ne[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, be, X, ge.width, ge.height);
        }
        for (let ge = 0; ge < 6; ge++)
          if (Re) {
            pe
              ? V &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                  0,
                  0,
                  0,
                  Ne[ge].width,
                  Ne[ge].height,
                  dt,
                  Ke,
                  Ne[ge].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                  0,
                  X,
                  Ne[ge].width,
                  Ne[ge].height,
                  0,
                  dt,
                  Ke,
                  Ne[ge].data
                );
            for (let Ue = 0; Ue < ue.length; Ue++) {
              const ft = ue[Ue].image[ge].image;
              pe
                ? V &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                    Ue + 1,
                    0,
                    0,
                    ft.width,
                    ft.height,
                    dt,
                    Ke,
                    ft.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                    Ue + 1,
                    X,
                    ft.width,
                    ft.height,
                    0,
                    dt,
                    Ke,
                    ft.data
                  );
            }
          } else {
            pe
              ? V &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                  0,
                  0,
                  0,
                  dt,
                  Ke,
                  Ne[ge]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                  0,
                  X,
                  dt,
                  Ke,
                  Ne[ge]
                );
            for (let Ue = 0; Ue < ue.length; Ue++) {
              const ke = ue[Ue];
              pe
                ? V &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                    Ue + 1,
                    0,
                    0,
                    dt,
                    Ke,
                    ke.image[ge]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
                    Ue + 1,
                    X,
                    dt,
                    Ke,
                    ke.image[ge]
                  );
            }
          }
      }
      x(L) && g(n.TEXTURE_CUBE_MAP),
        (me.__version = ye.version),
        L.onUpdate && L.onUpdate(L);
    }
    U.__version = L.version;
  }
  function Ce(U, L, ie, fe, ye, me) {
    const Pe = s.convert(ie.format, ie.colorSpace),
      Ie = s.convert(ie.type),
      ze = S(ie.internalFormat, Pe, Ie, ie.colorSpace),
      Mt = i.get(L),
      Re = i.get(ie);
    if (((Re.__renderTarget = L), !Mt.__hasExternalTextures)) {
      const Ne = Math.max(1, L.width >> me),
        mt = Math.max(1, L.height >> me);
      ye === n.TEXTURE_3D || ye === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(ye, me, ze, Ne, mt, L.depth, 0, Pe, Ie, null)
        : t.texImage2D(ye, me, ze, Ne, mt, 0, Pe, Ie, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, U),
      J(L)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            fe,
            ye,
            Re.__webglTexture,
            0,
            we(L)
          )
        : (ye === n.TEXTURE_2D ||
            (ye >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              ye <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(n.FRAMEBUFFER, fe, ye, Re.__webglTexture, me),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Se(U, L, ie) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, U), L.depthBuffer)) {
      const fe = L.depthTexture,
        ye = fe && fe.isDepthTexture ? fe.type : null,
        me = w(L.stencilBuffer, ye),
        Pe = L.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Ie = we(L);
      J(L)
        ? a.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Ie,
            me,
            L.width,
            L.height
          )
        : ie
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Ie,
            me,
            L.width,
            L.height
          )
        : n.renderbufferStorage(n.RENDERBUFFER, me, L.width, L.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, Pe, n.RENDERBUFFER, U);
    } else {
      const fe = L.textures;
      for (let ye = 0; ye < fe.length; ye++) {
        const me = fe[ye],
          Pe = s.convert(me.format, me.colorSpace),
          Ie = s.convert(me.type),
          ze = S(me.internalFormat, Pe, Ie, me.colorSpace),
          Mt = we(L);
        ie && J(L) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              Mt,
              ze,
              L.width,
              L.height
            )
          : J(L)
          ? a.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              Mt,
              ze,
              L.width,
              L.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, ze, L.width, L.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function Xe(U, L) {
    if (L && L.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, U),
      !(L.depthTexture && L.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    const fe = i.get(L.depthTexture);
    (fe.__renderTarget = L),
      (!fe.__webglTexture ||
        L.depthTexture.image.width !== L.width ||
        L.depthTexture.image.height !== L.height) &&
        ((L.depthTexture.image.width = L.width),
        (L.depthTexture.image.height = L.height),
        (L.depthTexture.needsUpdate = !0)),
      Z(L.depthTexture, 0);
    const ye = fe.__webglTexture,
      me = we(L);
    if (L.depthTexture.format === ic)
      J(L)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            ye,
            0,
            me
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            ye,
            0
          );
    else if (L.depthTexture.format === Sc)
      J(L)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            ye,
            0,
            me
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            ye,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function et(U) {
    const L = i.get(U),
      ie = U.isWebGLCubeRenderTarget === !0;
    if (L.__boundDepthTexture !== U.depthTexture) {
      const fe = U.depthTexture;
      if ((L.__depthDisposeCallback && L.__depthDisposeCallback(), fe)) {
        const ye = () => {
          delete L.__boundDepthTexture,
            delete L.__depthDisposeCallback,
            fe.removeEventListener("dispose", ye);
        };
        fe.addEventListener("dispose", ye), (L.__depthDisposeCallback = ye);
      }
      L.__boundDepthTexture = fe;
    }
    if (U.depthTexture && !L.__autoAllocateDepthBuffer) {
      if (ie)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Xe(L.__webglFramebuffer, U);
    } else if (ie) {
      L.__webglDepthbuffer = [];
      for (let fe = 0; fe < 6; fe++)
        if (
          (t.bindFramebuffer(n.FRAMEBUFFER, L.__webglFramebuffer[fe]),
          L.__webglDepthbuffer[fe] === void 0)
        )
          (L.__webglDepthbuffer[fe] = n.createRenderbuffer()),
            Se(L.__webglDepthbuffer[fe], U, !1);
        else {
          const ye = U.stencilBuffer
              ? n.DEPTH_STENCIL_ATTACHMENT
              : n.DEPTH_ATTACHMENT,
            me = L.__webglDepthbuffer[fe];
          n.bindRenderbuffer(n.RENDERBUFFER, me),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, ye, n.RENDERBUFFER, me);
        }
    } else if (
      (t.bindFramebuffer(n.FRAMEBUFFER, L.__webglFramebuffer),
      L.__webglDepthbuffer === void 0)
    )
      (L.__webglDepthbuffer = n.createRenderbuffer()),
        Se(L.__webglDepthbuffer, U, !1);
    else {
      const fe = U.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT,
        ye = L.__webglDepthbuffer;
      n.bindRenderbuffer(n.RENDERBUFFER, ye),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, fe, n.RENDERBUFFER, ye);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ye(U, L, ie) {
    const fe = i.get(U);
    L !== void 0 &&
      Ce(
        fe.__webglFramebuffer,
        U,
        U.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      ie !== void 0 && et(U);
  }
  function Fe(U) {
    const L = U.texture,
      ie = i.get(U),
      fe = i.get(L);
    U.addEventListener("dispose", P);
    const ye = U.textures,
      me = U.isWebGLCubeRenderTarget === !0,
      Pe = ye.length > 1;
    if (
      (Pe ||
        (fe.__webglTexture === void 0 &&
          (fe.__webglTexture = n.createTexture()),
        (fe.__version = L.version),
        o.memory.textures++),
      me)
    ) {
      ie.__webglFramebuffer = [];
      for (let Ie = 0; Ie < 6; Ie++)
        if (L.mipmaps && L.mipmaps.length > 0) {
          ie.__webglFramebuffer[Ie] = [];
          for (let ze = 0; ze < L.mipmaps.length; ze++)
            ie.__webglFramebuffer[Ie][ze] = n.createFramebuffer();
        } else ie.__webglFramebuffer[Ie] = n.createFramebuffer();
    } else {
      if (L.mipmaps && L.mipmaps.length > 0) {
        ie.__webglFramebuffer = [];
        for (let Ie = 0; Ie < L.mipmaps.length; Ie++)
          ie.__webglFramebuffer[Ie] = n.createFramebuffer();
      } else ie.__webglFramebuffer = n.createFramebuffer();
      if (Pe)
        for (let Ie = 0, ze = ye.length; Ie < ze; Ie++) {
          const Mt = i.get(ye[Ie]);
          Mt.__webglTexture === void 0 &&
            ((Mt.__webglTexture = n.createTexture()), o.memory.textures++);
        }
      if (U.samples > 0 && J(U) === !1) {
        (ie.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (ie.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, ie.__webglMultisampledFramebuffer);
        for (let Ie = 0; Ie < ye.length; Ie++) {
          const ze = ye[Ie];
          (ie.__webglColorRenderbuffer[Ie] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, ie.__webglColorRenderbuffer[Ie]);
          const Mt = s.convert(ze.format, ze.colorSpace),
            Re = s.convert(ze.type),
            Ne = S(
              ze.internalFormat,
              Mt,
              Re,
              ze.colorSpace,
              U.isXRRenderTarget === !0
            ),
            mt = we(U);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            mt,
            Ne,
            U.width,
            U.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Ie,
              n.RENDERBUFFER,
              ie.__webglColorRenderbuffer[Ie]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          U.depthBuffer &&
            ((ie.__webglDepthRenderbuffer = n.createRenderbuffer()),
            Se(ie.__webglDepthRenderbuffer, U, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (me) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, fe.__webglTexture),
        Me(n.TEXTURE_CUBE_MAP, L);
      for (let Ie = 0; Ie < 6; Ie++)
        if (L.mipmaps && L.mipmaps.length > 0)
          for (let ze = 0; ze < L.mipmaps.length; ze++)
            Ce(
              ie.__webglFramebuffer[Ie][ze],
              U,
              L,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie,
              ze
            );
        else
          Ce(
            ie.__webglFramebuffer[Ie],
            U,
            L,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie,
            0
          );
      x(L) && g(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Pe) {
      for (let Ie = 0, ze = ye.length; Ie < ze; Ie++) {
        const Mt = ye[Ie],
          Re = i.get(Mt);
        t.bindTexture(n.TEXTURE_2D, Re.__webglTexture),
          Me(n.TEXTURE_2D, Mt),
          Ce(
            ie.__webglFramebuffer,
            U,
            Mt,
            n.COLOR_ATTACHMENT0 + Ie,
            n.TEXTURE_2D,
            0
          ),
          x(Mt) && g(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Ie = n.TEXTURE_2D;
      if (
        ((U.isWebGL3DRenderTarget || U.isWebGLArrayRenderTarget) &&
          (Ie = U.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(Ie, fe.__webglTexture),
        Me(Ie, L),
        L.mipmaps && L.mipmaps.length > 0)
      )
        for (let ze = 0; ze < L.mipmaps.length; ze++)
          Ce(ie.__webglFramebuffer[ze], U, L, n.COLOR_ATTACHMENT0, Ie, ze);
      else Ce(ie.__webglFramebuffer, U, L, n.COLOR_ATTACHMENT0, Ie, 0);
      x(L) && g(Ie), t.unbindTexture();
    }
    U.depthBuffer && et(U);
  }
  function de(U) {
    const L = U.textures;
    for (let ie = 0, fe = L.length; ie < fe; ie++) {
      const ye = L[ie];
      if (x(ye)) {
        const me = A(U),
          Pe = i.get(ye).__webglTexture;
        t.bindTexture(me, Pe), g(me), t.unbindTexture();
      }
    }
  }
  const ce = [],
    k = [];
  function Ve(U) {
    if (U.samples > 0) {
      if (J(U) === !1) {
        const L = U.textures,
          ie = U.width,
          fe = U.height;
        let ye = n.COLOR_BUFFER_BIT;
        const me = U.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          Pe = i.get(U),
          Ie = L.length > 1;
        if (Ie)
          for (let ze = 0; ze < L.length; ze++)
            t.bindFramebuffer(n.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + ze,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, Pe.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + ze,
                n.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          Pe.__webglMultisampledFramebuffer
        ),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Pe.__webglFramebuffer);
        for (let ze = 0; ze < L.length; ze++) {
          if (
            (U.resolveDepthBuffer &&
              (U.depthBuffer && (ye |= n.DEPTH_BUFFER_BIT),
              U.stencilBuffer &&
                U.resolveStencilBuffer &&
                (ye |= n.STENCIL_BUFFER_BIT)),
            Ie)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Pe.__webglColorRenderbuffer[ze]
            );
            const Mt = i.get(L[ze]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              Mt,
              0
            );
          }
          n.blitFramebuffer(0, 0, ie, fe, 0, 0, ie, fe, ye, n.NEAREST),
            l === !0 &&
              ((ce.length = 0),
              (k.length = 0),
              ce.push(n.COLOR_ATTACHMENT0 + ze),
              U.depthBuffer &&
                U.resolveDepthBuffer === !1 &&
                (ce.push(me),
                k.push(me),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, k)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, ce));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          Ie)
        )
          for (let ze = 0; ze < L.length; ze++) {
            t.bindFramebuffer(n.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + ze,
                n.RENDERBUFFER,
                Pe.__webglColorRenderbuffer[ze]
              );
            const Mt = i.get(L[ze]).__webglTexture;
            t.bindFramebuffer(n.FRAMEBUFFER, Pe.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + ze,
                n.TEXTURE_2D,
                Mt,
                0
              );
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          Pe.__webglMultisampledFramebuffer
        );
      } else if (U.depthBuffer && U.resolveDepthBuffer === !1 && l) {
        const L = U.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [L]);
      }
    }
  }
  function we(U) {
    return Math.min(r.maxSamples, U.samples);
  }
  function J(U) {
    const L = i.get(U);
    return (
      U.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      L.__useRenderToTexture !== !1
    );
  }
  function Te(U) {
    const L = o.render.frame;
    c.get(U) !== L && (c.set(U, L), U.update());
  }
  function st(U, L) {
    const ie = U.colorSpace,
      fe = U.format,
      ye = U.type;
    return (
      U.isCompressedTexture === !0 ||
        U.isVideoTexture === !0 ||
        (ie !== Mc &&
          ie !== va &&
          (en.getTransfer(ie) === pn
            ? (fe !== $i || ye !== xo) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                ie
              ))),
      L
    );
  }
  function Le(U) {
    return (
      typeof HTMLImageElement < "u" && U instanceof HTMLImageElement
        ? ((u.width = U.naturalWidth || U.width),
          (u.height = U.naturalHeight || U.height))
        : typeof VideoFrame < "u" && U instanceof VideoFrame
        ? ((u.width = U.displayWidth), (u.height = U.displayHeight))
        : ((u.width = U.width), (u.height = U.height)),
      u
    );
  }
  (this.allocateTextureUnit = W),
    (this.resetTextureUnits = G),
    (this.setTexture2D = Z),
    (this.setTexture2DArray = K),
    (this.setTexture3D = te),
    (this.setTextureCube = O),
    (this.rebindTextures = Ye),
    (this.setupRenderTarget = Fe),
    (this.updateRenderTargetMipmap = de),
    (this.updateMultisampleRenderTarget = Ve),
    (this.setupDepthRenderbuffer = et),
    (this.setupFrameBufferTexture = Ce),
    (this.useMultisampledRTT = J);
}
function iO(n, e) {
  function t(i, r = va) {
    let s;
    const o = en.getTransfer(r);
    if (i === xo) return n.UNSIGNED_BYTE;
    if (i === ix) return n.UNSIGNED_SHORT_4_4_4_4;
    if (i === rx) return n.UNSIGNED_SHORT_5_5_5_1;
    if (i === nT) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (i === eT) return n.BYTE;
    if (i === tT) return n.SHORT;
    if (i === Eh) return n.UNSIGNED_SHORT;
    if (i === nx) return n.INT;
    if (i === Ua) return n.UNSIGNED_INT;
    if (i === kr) return n.FLOAT;
    if (i === jh) return n.HALF_FLOAT;
    if (i === iT) return n.ALPHA;
    if (i === rT) return n.RGB;
    if (i === $i) return n.RGBA;
    if (i === sT) return n.LUMINANCE;
    if (i === oT) return n.LUMINANCE_ALPHA;
    if (i === ic) return n.DEPTH_COMPONENT;
    if (i === Sc) return n.DEPTH_STENCIL;
    if (i === sx) return n.RED;
    if (i === km) return n.RED_INTEGER;
    if (i === aT) return n.RG;
    if (i === ox) return n.RG_INTEGER;
    if (i === ax) return n.RGBA_INTEGER;
    if (i === gp || i === vp || i === yp || i === _p)
      if (o === pn)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (i === gp) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === vp) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === yp) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === _p) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (i === gp) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === vp) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === yp) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === _p) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (i === Dy || i === Ly || i === Fy || i === Ny)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (i === Dy) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === Ly) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === Fy) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === Ny) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (i === Oy || i === Uy || i === ky)
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (i === Oy || i === Uy)
          return o === pn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (i === ky)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      i === zy ||
      i === Hy ||
      i === Gy ||
      i === Vy ||
      i === Wy ||
      i === Xy ||
      i === Jy ||
      i === jy ||
      i === Yy ||
      i === Ky ||
      i === Qy ||
      i === Zy ||
      i === qy ||
      i === $y
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (i === zy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === Hy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === Gy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === Vy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === Wy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === Xy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === Jy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === jy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === Yy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === Ky)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === Qy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === Zy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === qy)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === $y)
          return o === pn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (i === xp || i === e_ || i === t_)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (i === xp)
          return o === pn
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === e_) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === t_) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (i === lT || i === n_ || i === i_ || i === r_)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (i === xp) return s.COMPRESSED_RED_RGTC1_EXT;
        if (i === n_) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === i_) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === r_) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return i === Ac ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null;
  }
  return { convert: t };
}
const cJ = { type: "move" };
class lS {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Sa()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Sa()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new z()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new z())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Sa()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new z()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new z())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      u = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        o = !0;
        for (const _ of e.hand.values()) {
          const x = t.getJointPose(_, i),
            g = this._getHandJoint(u, _);
          x !== null &&
            (g.matrix.fromArray(x.transform.matrix),
            g.matrix.decompose(g.position, g.rotation, g.scale),
            (g.matrixWorldNeedsUpdate = !0),
            (g.jointRadius = x.radius)),
            (g.visible = x !== null);
        }
        const c = u.joints["index-finger-tip"],
          d = u.joints["thumb-tip"],
          p = c.position.distanceTo(d.position),
          m = 0.02,
          v = 0.005;
        u.inputState.pinching && p > m + v
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            p <= m - v &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(cJ)));
    }
    return (
      a !== null && (a.visible = r !== null),
      l !== null && (l.visible = s !== null),
      u !== null && (u.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Sa();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
const fJ = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  hJ = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class dJ {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, i) {
    if (this.texture === null) {
      const r = new Pn(),
        s = e.properties.get(r);
      (s.__webglTexture = t.texture),
        (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = r);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        i = new Ao({
          vertexShader: fJ,
          fragmentShader: hJ,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new qn(new Kh(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class pJ extends Zo {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      u = null,
      c = null,
      d = null,
      p = null,
      m = null,
      v = null;
    const _ = new dJ(),
      x = t.getContextAttributes();
    let g = null,
      A = null;
    const S = [],
      w = [],
      C = new Ae();
    let b = null;
    const P = new bn();
    P.viewport = new tn();
    const I = new bn();
    I.viewport = new tn();
    const R = [P, I],
      T = new JN();
    let D = null,
      G = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (re) {
        let xe = S[re];
        return (
          xe === void 0 && ((xe = new lS()), (S[re] = xe)),
          xe.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (re) {
        let xe = S[re];
        return (
          xe === void 0 && ((xe = new lS()), (S[re] = xe)), xe.getGripSpace()
        );
      }),
      (this.getHand = function (re) {
        let xe = S[re];
        return (
          xe === void 0 && ((xe = new lS()), (S[re] = xe)), xe.getHandSpace()
        );
      });
    function W(re) {
      const xe = w.indexOf(re.inputSource);
      if (xe === -1) return;
      const Ce = S[xe];
      Ce !== void 0 &&
        (Ce.update(re.inputSource, re.frame, u || o),
        Ce.dispatchEvent({ type: re.type, data: re.inputSource }));
    }
    function q() {
      r.removeEventListener("select", W),
        r.removeEventListener("selectstart", W),
        r.removeEventListener("selectend", W),
        r.removeEventListener("squeeze", W),
        r.removeEventListener("squeezestart", W),
        r.removeEventListener("squeezeend", W),
        r.removeEventListener("end", q),
        r.removeEventListener("inputsourceschange", Z);
      for (let re = 0; re < S.length; re++) {
        const xe = w[re];
        xe !== null && ((w[re] = null), S[re].disconnect(xe));
      }
      (D = null),
        (G = null),
        _.reset(),
        e.setRenderTarget(g),
        (m = null),
        (p = null),
        (d = null),
        (r = null),
        (A = null),
        De.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(b),
        e.setSize(C.width, C.height, !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (re) {
      (s = re),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (re) {
        (a = re),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return u || o;
      }),
      (this.setReferenceSpace = function (re) {
        u = re;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (re) {
        if (((r = re), r !== null)) {
          if (
            ((g = e.getRenderTarget()),
            r.addEventListener("select", W),
            r.addEventListener("selectstart", W),
            r.addEventListener("selectend", W),
            r.addEventListener("squeeze", W),
            r.addEventListener("squeezestart", W),
            r.addEventListener("squeezeend", W),
            r.addEventListener("end", q),
            r.addEventListener("inputsourceschange", Z),
            x.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (b = e.getPixelRatio()),
            e.getSize(C),
            r.enabledFeatures !== void 0 &&
              r.enabledFeatures.includes("layers"))
          ) {
            let Ce = null,
              Se = null,
              Xe = null;
            x.depth &&
              ((Xe = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (Ce = x.stencil ? Sc : ic),
              (Se = x.stencil ? Ac : Ua));
            const et = {
              colorFormat: t.RGBA8,
              depthFormat: Xe,
              scaleFactor: s,
            };
            (d = new XRWebGLBinding(r, t)),
              (p = d.createProjectionLayer(et)),
              r.updateRenderState({ layers: [p] }),
              e.setPixelRatio(1),
              e.setSize(p.textureWidth, p.textureHeight, !1),
              (A = new Ko(p.textureWidth, p.textureHeight, {
                format: $i,
                type: xo,
                depthTexture: new MT(
                  p.textureWidth,
                  p.textureHeight,
                  Se,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Ce
                ),
                stencilBuffer: x.stencil,
                colorSpace: e.outputColorSpace,
                samples: x.antialias ? 4 : 0,
                resolveDepthBuffer: p.ignoreDepthValues === !1,
              }));
          } else {
            const Ce = {
              antialias: x.antialias,
              alpha: !0,
              depth: x.depth,
              stencil: x.stencil,
              framebufferScaleFactor: s,
            };
            (m = new XRWebGLLayer(r, t, Ce)),
              r.updateRenderState({ baseLayer: m }),
              e.setPixelRatio(1),
              e.setSize(m.framebufferWidth, m.framebufferHeight, !1),
              (A = new Ko(m.framebufferWidth, m.framebufferHeight, {
                format: $i,
                type: xo,
                colorSpace: e.outputColorSpace,
                stencilBuffer: x.stencil,
              }));
          }
          (A.isXRRenderTarget = !0),
            this.setFoveation(l),
            (u = null),
            (o = await r.requestReferenceSpace(a)),
            De.setContext(r),
            De.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return _.getDepthTexture();
      });
    function Z(re) {
      for (let xe = 0; xe < re.removed.length; xe++) {
        const Ce = re.removed[xe],
          Se = w.indexOf(Ce);
        Se >= 0 && ((w[Se] = null), S[Se].disconnect(Ce));
      }
      for (let xe = 0; xe < re.added.length; xe++) {
        const Ce = re.added[xe];
        let Se = w.indexOf(Ce);
        if (Se === -1) {
          for (let et = 0; et < S.length; et++)
            if (et >= w.length) {
              w.push(Ce), (Se = et);
              break;
            } else if (w[et] === null) {
              (w[et] = Ce), (Se = et);
              break;
            }
          if (Se === -1) break;
        }
        const Xe = S[Se];
        Xe && Xe.connect(Ce);
      }
    }
    const K = new z(),
      te = new z();
    function O(re, xe, Ce) {
      K.setFromMatrixPosition(xe.matrixWorld),
        te.setFromMatrixPosition(Ce.matrixWorld);
      const Se = K.distanceTo(te),
        Xe = xe.projectionMatrix.elements,
        et = Ce.projectionMatrix.elements,
        Ye = Xe[14] / (Xe[10] - 1),
        Fe = Xe[14] / (Xe[10] + 1),
        de = (Xe[9] + 1) / Xe[5],
        ce = (Xe[9] - 1) / Xe[5],
        k = (Xe[8] - 1) / Xe[0],
        Ve = (et[8] + 1) / et[0],
        we = Ye * k,
        J = Ye * Ve,
        Te = Se / (-k + Ve),
        st = Te * -k;
      if (
        (xe.matrixWorld.decompose(re.position, re.quaternion, re.scale),
        re.translateX(st),
        re.translateZ(Te),
        re.matrixWorld.compose(re.position, re.quaternion, re.scale),
        re.matrixWorldInverse.copy(re.matrixWorld).invert(),
        Xe[10] === -1)
      )
        re.projectionMatrix.copy(xe.projectionMatrix),
          re.projectionMatrixInverse.copy(xe.projectionMatrixInverse);
      else {
        const Le = Ye + Te,
          U = Fe + Te,
          L = we - st,
          ie = J + (Se - st),
          fe = ((de * Fe) / U) * Le,
          ye = ((ce * Fe) / U) * Le;
        re.projectionMatrix.makePerspective(L, ie, fe, ye, Le, U),
          re.projectionMatrixInverse.copy(re.projectionMatrix).invert();
      }
    }
    function Y(re, xe) {
      xe === null
        ? re.matrixWorld.copy(re.matrix)
        : re.matrixWorld.multiplyMatrices(xe.matrixWorld, re.matrix),
        re.matrixWorldInverse.copy(re.matrixWorld).invert();
    }
    this.updateCamera = function (re) {
      if (r === null) return;
      let xe = re.near,
        Ce = re.far;
      _.texture !== null &&
        (_.depthNear > 0 && (xe = _.depthNear),
        _.depthFar > 0 && (Ce = _.depthFar)),
        (T.near = I.near = P.near = xe),
        (T.far = I.far = P.far = Ce),
        (D !== T.near || G !== T.far) &&
          (r.updateRenderState({ depthNear: T.near, depthFar: T.far }),
          (D = T.near),
          (G = T.far)),
        (P.layers.mask = re.layers.mask | 2),
        (I.layers.mask = re.layers.mask | 4),
        (T.layers.mask = P.layers.mask | I.layers.mask);
      const Se = re.parent,
        Xe = T.cameras;
      Y(T, Se);
      for (let et = 0; et < Xe.length; et++) Y(Xe[et], Se);
      Xe.length === 2
        ? O(T, P, I)
        : T.projectionMatrix.copy(P.projectionMatrix),
        F(re, T, Se);
    };
    function F(re, xe, Ce) {
      Ce === null
        ? re.matrix.copy(xe.matrixWorld)
        : (re.matrix.copy(Ce.matrixWorld),
          re.matrix.invert(),
          re.matrix.multiply(xe.matrixWorld)),
        re.matrix.decompose(re.position, re.quaternion, re.scale),
        re.updateMatrixWorld(!0),
        re.projectionMatrix.copy(xe.projectionMatrix),
        re.projectionMatrixInverse.copy(xe.projectionMatrixInverse),
        re.isPerspectiveCamera &&
          ((re.fov = bh * 2 * Math.atan(1 / re.projectionMatrix.elements[5])),
          (re.zoom = 1));
    }
    (this.getCamera = function () {
      return T;
    }),
      (this.getFoveation = function () {
        if (!(p === null && m === null)) return l;
      }),
      (this.setFoveation = function (re) {
        (l = re),
          p !== null && (p.fixedFoveation = re),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = re);
      }),
      (this.hasDepthSensing = function () {
        return _.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return _.getMesh(T);
      });
    let se = null;
    function Me(re, xe) {
      if (((c = xe.getViewerPose(u || o)), (v = xe), c !== null)) {
        const Ce = c.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(A, m.framebuffer),
          e.setRenderTarget(A));
        let Se = !1;
        Ce.length !== T.cameras.length && ((T.cameras.length = 0), (Se = !0));
        for (let et = 0; et < Ce.length; et++) {
          const Ye = Ce[et];
          let Fe = null;
          if (m !== null) Fe = m.getViewport(Ye);
          else {
            const ce = d.getViewSubImage(p, Ye);
            (Fe = ce.viewport),
              et === 0 &&
                (e.setRenderTargetTextures(
                  A,
                  ce.colorTexture,
                  p.ignoreDepthValues ? void 0 : ce.depthStencilTexture
                ),
                e.setRenderTarget(A));
          }
          let de = R[et];
          de === void 0 &&
            ((de = new bn()),
            de.layers.enable(et),
            (de.viewport = new tn()),
            (R[et] = de)),
            de.matrix.fromArray(Ye.transform.matrix),
            de.matrix.decompose(de.position, de.quaternion, de.scale),
            de.projectionMatrix.fromArray(Ye.projectionMatrix),
            de.projectionMatrixInverse.copy(de.projectionMatrix).invert(),
            de.viewport.set(Fe.x, Fe.y, Fe.width, Fe.height),
            et === 0 &&
              (T.matrix.copy(de.matrix),
              T.matrix.decompose(T.position, T.quaternion, T.scale)),
            Se === !0 && T.cameras.push(de);
        }
        const Xe = r.enabledFeatures;
        if (Xe && Xe.includes("depth-sensing")) {
          const et = d.getDepthInformation(Ce[0]);
          et && et.isValid && et.texture && _.init(e, et, r.renderState);
        }
      }
      for (let Ce = 0; Ce < S.length; Ce++) {
        const Se = w[Ce],
          Xe = S[Ce];
        Se !== null && Xe !== void 0 && Xe.update(Se, xe, u || o);
      }
      se && se(re, xe),
        xe.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: xe }),
        (v = null);
    }
    const De = new qN();
    De.setAnimationLoop(Me),
      (this.setAnimationLoop = function (re) {
        se = re;
      }),
      (this.dispose = function () {});
  }
}
const Su = new ys(),
  mJ = new _t();
function gJ(n, e) {
  function t(x, g) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), g.value.copy(x.matrix);
  }
  function i(x, g) {
    g.color.getRGB(x.fogColor.value, lN(n)),
      g.isFog
        ? ((x.fogNear.value = g.near), (x.fogFar.value = g.far))
        : g.isFogExp2 && (x.fogDensity.value = g.density);
  }
  function r(x, g, A, S, w) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial
      ? s(x, g)
      : g.isMeshToonMaterial
      ? (s(x, g), d(x, g))
      : g.isMeshPhongMaterial
      ? (s(x, g), c(x, g))
      : g.isMeshStandardMaterial
      ? (s(x, g), p(x, g), g.isMeshPhysicalMaterial && m(x, g, w))
      : g.isMeshMatcapMaterial
      ? (s(x, g), v(x, g))
      : g.isMeshDepthMaterial
      ? s(x, g)
      : g.isMeshDistanceMaterial
      ? (s(x, g), _(x, g))
      : g.isMeshNormalMaterial
      ? s(x, g)
      : g.isLineBasicMaterial
      ? (o(x, g), g.isLineDashedMaterial && a(x, g))
      : g.isPointsMaterial
      ? l(x, g, A, S)
      : g.isSpriteMaterial
      ? u(x, g)
      : g.isShadowMaterial
      ? (x.color.value.copy(g.color), (x.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function s(x, g) {
    (x.opacity.value = g.opacity),
      g.color && x.diffuse.value.copy(g.color),
      g.emissive &&
        x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.bumpMap &&
        ((x.bumpMap.value = g.bumpMap),
        t(g.bumpMap, x.bumpMapTransform),
        (x.bumpScale.value = g.bumpScale),
        g.side === Ar && (x.bumpScale.value *= -1)),
      g.normalMap &&
        ((x.normalMap.value = g.normalMap),
        t(g.normalMap, x.normalMapTransform),
        x.normalScale.value.copy(g.normalScale),
        g.side === Ar && x.normalScale.value.negate()),
      g.displacementMap &&
        ((x.displacementMap.value = g.displacementMap),
        t(g.displacementMap, x.displacementMapTransform),
        (x.displacementScale.value = g.displacementScale),
        (x.displacementBias.value = g.displacementBias)),
      g.emissiveMap &&
        ((x.emissiveMap.value = g.emissiveMap),
        t(g.emissiveMap, x.emissiveMapTransform)),
      g.specularMap &&
        ((x.specularMap.value = g.specularMap),
        t(g.specularMap, x.specularMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
    const A = e.get(g),
      S = A.envMap,
      w = A.envMapRotation;
    S &&
      ((x.envMap.value = S),
      Su.copy(w),
      (Su.x *= -1),
      (Su.y *= -1),
      (Su.z *= -1),
      S.isCubeTexture &&
        S.isRenderTargetTexture === !1 &&
        ((Su.y *= -1), (Su.z *= -1)),
      x.envMapRotation.value.setFromMatrix4(mJ.makeRotationFromEuler(Su)),
      (x.flipEnvMap.value =
        S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
      (x.reflectivity.value = g.reflectivity),
      (x.ior.value = g.ior),
      (x.refractionRatio.value = g.refractionRatio)),
      g.lightMap &&
        ((x.lightMap.value = g.lightMap),
        (x.lightMapIntensity.value = g.lightMapIntensity),
        t(g.lightMap, x.lightMapTransform)),
      g.aoMap &&
        ((x.aoMap.value = g.aoMap),
        (x.aoMapIntensity.value = g.aoMapIntensity),
        t(g.aoMap, x.aoMapTransform));
  }
  function o(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform));
  }
  function a(x, g) {
    (x.dashSize.value = g.dashSize),
      (x.totalSize.value = g.dashSize + g.gapSize),
      (x.scale.value = g.scale);
  }
  function l(x, g, A, S) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.size.value = g.size * A),
      (x.scale.value = S * 0.5),
      g.map && ((x.map.value = g.map), t(g.map, x.uvTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function u(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.rotation.value = g.rotation),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function c(x, g) {
    x.specular.value.copy(g.specular),
      (x.shininess.value = Math.max(g.shininess, 1e-4));
  }
  function d(x, g) {
    g.gradientMap && (x.gradientMap.value = g.gradientMap);
  }
  function p(x, g) {
    (x.metalness.value = g.metalness),
      g.metalnessMap &&
        ((x.metalnessMap.value = g.metalnessMap),
        t(g.metalnessMap, x.metalnessMapTransform)),
      (x.roughness.value = g.roughness),
      g.roughnessMap &&
        ((x.roughnessMap.value = g.roughnessMap),
        t(g.roughnessMap, x.roughnessMapTransform)),
      g.envMap && (x.envMapIntensity.value = g.envMapIntensity);
  }
  function m(x, g, A) {
    (x.ior.value = g.ior),
      g.sheen > 0 &&
        (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (x.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap &&
          ((x.sheenColorMap.value = g.sheenColorMap),
          t(g.sheenColorMap, x.sheenColorMapTransform)),
        g.sheenRoughnessMap &&
          ((x.sheenRoughnessMap.value = g.sheenRoughnessMap),
          t(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
      g.clearcoat > 0 &&
        ((x.clearcoat.value = g.clearcoat),
        (x.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap &&
          ((x.clearcoatMap.value = g.clearcoatMap),
          t(g.clearcoatMap, x.clearcoatMapTransform)),
        g.clearcoatRoughnessMap &&
          ((x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
          t(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap &&
          ((x.clearcoatNormalMap.value = g.clearcoatNormalMap),
          t(g.clearcoatNormalMap, x.clearcoatNormalMapTransform),
          x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          g.side === Ar && x.clearcoatNormalScale.value.negate())),
      g.dispersion > 0 && (x.dispersion.value = g.dispersion),
      g.iridescence > 0 &&
        ((x.iridescence.value = g.iridescence),
        (x.iridescenceIOR.value = g.iridescenceIOR),
        (x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
        (x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
        g.iridescenceMap &&
          ((x.iridescenceMap.value = g.iridescenceMap),
          t(g.iridescenceMap, x.iridescenceMapTransform)),
        g.iridescenceThicknessMap &&
          ((x.iridescenceThicknessMap.value = g.iridescenceThicknessMap),
          t(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
      g.transmission > 0 &&
        ((x.transmission.value = g.transmission),
        (x.transmissionSamplerMap.value = A.texture),
        x.transmissionSamplerSize.value.set(A.width, A.height),
        g.transmissionMap &&
          ((x.transmissionMap.value = g.transmissionMap),
          t(g.transmissionMap, x.transmissionMapTransform)),
        (x.thickness.value = g.thickness),
        g.thicknessMap &&
          ((x.thicknessMap.value = g.thicknessMap),
          t(g.thicknessMap, x.thicknessMapTransform)),
        (x.attenuationDistance.value = g.attenuationDistance),
        x.attenuationColor.value.copy(g.attenuationColor)),
      g.anisotropy > 0 &&
        (x.anisotropyVector.value.set(
          g.anisotropy * Math.cos(g.anisotropyRotation),
          g.anisotropy * Math.sin(g.anisotropyRotation)
        ),
        g.anisotropyMap &&
          ((x.anisotropyMap.value = g.anisotropyMap),
          t(g.anisotropyMap, x.anisotropyMapTransform))),
      (x.specularIntensity.value = g.specularIntensity),
      x.specularColor.value.copy(g.specularColor),
      g.specularColorMap &&
        ((x.specularColorMap.value = g.specularColorMap),
        t(g.specularColorMap, x.specularColorMapTransform)),
      g.specularIntensityMap &&
        ((x.specularIntensityMap.value = g.specularIntensityMap),
        t(g.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function v(x, g) {
    g.matcap && (x.matcap.value = g.matcap);
  }
  function _(x, g) {
    const A = e.get(g).light;
    x.referencePosition.value.setFromMatrixPosition(A.matrixWorld),
      (x.nearDistance.value = A.shadow.camera.near),
      (x.farDistance.value = A.shadow.camera.far);
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function vJ(n, e, t, i) {
  let r = {},
    s = {},
    o = [];
  const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(A, S) {
    const w = S.program;
    i.uniformBlockBinding(A, w);
  }
  function u(A, S) {
    let w = r[A.id];
    w === void 0 &&
      (v(A), (w = c(A)), (r[A.id] = w), A.addEventListener("dispose", x));
    const C = S.program;
    i.updateUBOMapping(A, C);
    const b = e.render.frame;
    s[A.id] !== b && (p(A), (s[A.id] = b));
  }
  function c(A) {
    const S = d();
    A.__bindingPointIndex = S;
    const w = n.createBuffer(),
      C = A.__size,
      b = A.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, w),
      n.bufferData(n.UNIFORM_BUFFER, C, b),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, S, w),
      w
    );
  }
  function d() {
    for (let A = 0; A < a; A++) if (o.indexOf(A) === -1) return o.push(A), A;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(A) {
    const S = r[A.id],
      w = A.uniforms,
      C = A.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, S);
    for (let b = 0, P = w.length; b < P; b++) {
      const I = Array.isArray(w[b]) ? w[b] : [w[b]];
      for (let R = 0, T = I.length; R < T; R++) {
        const D = I[R];
        if (m(D, b, R, C) === !0) {
          const G = D.__offset,
            W = Array.isArray(D.value) ? D.value : [D.value];
          let q = 0;
          for (let Z = 0; Z < W.length; Z++) {
            const K = W[Z],
              te = _(K);
            typeof K == "number" || typeof K == "boolean"
              ? ((D.__data[0] = K),
                n.bufferSubData(n.UNIFORM_BUFFER, G + q, D.__data))
              : K.isMatrix3
              ? ((D.__data[0] = K.elements[0]),
                (D.__data[1] = K.elements[1]),
                (D.__data[2] = K.elements[2]),
                (D.__data[3] = 0),
                (D.__data[4] = K.elements[3]),
                (D.__data[5] = K.elements[4]),
                (D.__data[6] = K.elements[5]),
                (D.__data[7] = 0),
                (D.__data[8] = K.elements[6]),
                (D.__data[9] = K.elements[7]),
                (D.__data[10] = K.elements[8]),
                (D.__data[11] = 0))
              : (K.toArray(D.__data, q),
                (q += te.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, G, D.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function m(A, S, w, C) {
    const b = A.value,
      P = S + "_" + w;
    if (C[P] === void 0)
      return (
        typeof b == "number" || typeof b == "boolean"
          ? (C[P] = b)
          : (C[P] = b.clone()),
        !0
      );
    {
      const I = C[P];
      if (typeof b == "number" || typeof b == "boolean") {
        if (I !== b) return (C[P] = b), !0;
      } else if (I.equals(b) === !1) return I.copy(b), !0;
    }
    return !1;
  }
  function v(A) {
    const S = A.uniforms;
    let w = 0;
    const C = 16;
    for (let P = 0, I = S.length; P < I; P++) {
      const R = Array.isArray(S[P]) ? S[P] : [S[P]];
      for (let T = 0, D = R.length; T < D; T++) {
        const G = R[T],
          W = Array.isArray(G.value) ? G.value : [G.value];
        for (let q = 0, Z = W.length; q < Z; q++) {
          const K = W[q],
            te = _(K),
            O = w % C,
            Y = O % te.boundary,
            F = O + Y;
          (w += Y),
            F !== 0 && C - F < te.storage && (w += C - F),
            (G.__data = new Float32Array(
              te.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (G.__offset = w),
            (w += te.storage);
        }
      }
    }
    const b = w % C;
    return b > 0 && (w += C - b), (A.__size = w), (A.__cache = {}), this;
  }
  function _(A) {
    const S = { boundary: 0, storage: 0 };
    return (
      typeof A == "number" || typeof A == "boolean"
        ? ((S.boundary = 4), (S.storage = 4))
        : A.isVector2
        ? ((S.boundary = 8), (S.storage = 8))
        : A.isVector3 || A.isColor
        ? ((S.boundary = 16), (S.storage = 12))
        : A.isVector4
        ? ((S.boundary = 16), (S.storage = 16))
        : A.isMatrix3
        ? ((S.boundary = 48), (S.storage = 48))
        : A.isMatrix4
        ? ((S.boundary = 64), (S.storage = 64))
        : A.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            A
          ),
      S
    );
  }
  function x(A) {
    const S = A.target;
    S.removeEventListener("dispose", x);
    const w = o.indexOf(S.__bindingPointIndex);
    o.splice(w, 1), n.deleteBuffer(r[S.id]), delete r[S.id], delete s[S.id];
  }
  function g() {
    for (const A in r) n.deleteBuffer(r[A]);
    (o = []), (r = {}), (s = {});
  }
  return { bind: l, update: u, dispose: g };
}
class rO {
  constructor(e = {}) {
    const {
      canvas: t = sN(),
      context: i = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: c = "default",
      failIfMajorPerformanceCaveat: d = !1,
      reverseDepthBuffer: p = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let m;
    if (i !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        i instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      m = i.getContextAttributes().alpha;
    } else m = o;
    const v = new Uint32Array(4),
      _ = new Int32Array(4);
    let x = null,
      g = null;
    const A = [],
      S = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Fr),
      (this.toneMapping = Vo),
      (this.toneMappingExposure = 1);
    const w = this;
    let C = !1,
      b = 0,
      P = 0,
      I = null,
      R = -1,
      T = null;
    const D = new tn(),
      G = new tn();
    let W = null;
    const q = new Ze(0);
    let Z = 0,
      K = t.width,
      te = t.height,
      O = 1,
      Y = null,
      F = null;
    const se = new tn(0, 0, K, te),
      Me = new tn(0, 0, K, te);
    let De = !1;
    const re = new Xm();
    let xe = !1,
      Ce = !1;
    this.transmissionResolutionScale = 1;
    const Se = new _t(),
      Xe = new _t(),
      et = new z(),
      Ye = new tn(),
      Fe = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let de = !1;
    function ce() {
      return I === null ? O : 1;
    }
    let k = i;
    function Ve(N, $) {
      return t.getContext(N, $);
    }
    try {
      const N = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: c,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Xh}`),
        t.addEventListener("webglcontextlost", ge, !1),
        t.addEventListener("webglcontextrestored", Ue, !1),
        t.addEventListener("webglcontextcreationerror", ke, !1),
        k === null)
      ) {
        const $ = "webgl2";
        if (((k = Ve($, N)), k === null))
          throw Ve($)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (N) {
      throw (console.error("THREE.WebGLRenderer: " + N.message), N);
    }
    let we,
      J,
      Te,
      st,
      Le,
      U,
      L,
      ie,
      fe,
      ye,
      me,
      Pe,
      Ie,
      ze,
      Mt,
      Re,
      Ne,
      mt,
      dt,
      Ke,
      X,
      pe,
      He,
      V;
    function be() {
      (we = new b7(k)),
        we.init(),
        (pe = new iO(k, we)),
        (J = new S7(k, we, e, pe)),
        (Te = new lJ(k, we)),
        J.reverseDepthBuffer && p && Te.buffers.depth.setReversed(!0),
        (st = new B7(k)),
        (Le = new KX()),
        (U = new uJ(k, we, Te, Le, J, pe, st)),
        (L = new w7(w)),
        (ie = new C7(w)),
        (fe = new U8(k)),
        (He = new x7(k, fe)),
        (ye = new R7(k, fe, st, He)),
        (me = new D7(k, ye, fe, st)),
        (dt = new I7(k, J, U)),
        (Re = new M7(Le)),
        (Pe = new YX(w, L, ie, we, J, He, Re)),
        (Ie = new gJ(w, Le)),
        (ze = new ZX()),
        (Mt = new iJ(we)),
        (mt = new _7(w, L, ie, Te, me, m, l)),
        (Ne = new oJ(w, me, J)),
        (V = new vJ(k, st, J, Te)),
        (Ke = new A7(k, we, st)),
        (X = new P7(k, we, st)),
        (st.programs = Pe.programs),
        (w.capabilities = J),
        (w.extensions = we),
        (w.properties = Le),
        (w.renderLists = ze),
        (w.shadowMap = Ne),
        (w.state = Te),
        (w.info = st);
    }
    be();
    const ue = new pJ(w, k);
    (this.xr = ue),
      (this.getContext = function () {
        return k;
      }),
      (this.getContextAttributes = function () {
        return k.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const N = we.get("WEBGL_lose_context");
        N && N.loseContext();
      }),
      (this.forceContextRestore = function () {
        const N = we.get("WEBGL_lose_context");
        N && N.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return O;
      }),
      (this.setPixelRatio = function (N) {
        N !== void 0 && ((O = N), this.setSize(K, te, !1));
      }),
      (this.getSize = function (N) {
        return N.set(K, te);
      }),
      (this.setSize = function (N, $, ae = !0) {
        if (ue.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (K = N),
          (te = $),
          (t.width = Math.floor(N * O)),
          (t.height = Math.floor($ * O)),
          ae === !0 &&
            ((t.style.width = N + "px"), (t.style.height = $ + "px")),
          this.setViewport(0, 0, N, $);
      }),
      (this.getDrawingBufferSize = function (N) {
        return N.set(K * O, te * O).floor();
      }),
      (this.setDrawingBufferSize = function (N, $, ae) {
        (K = N),
          (te = $),
          (O = ae),
          (t.width = Math.floor(N * ae)),
          (t.height = Math.floor($ * ae)),
          this.setViewport(0, 0, N, $);
      }),
      (this.getCurrentViewport = function (N) {
        return N.copy(D);
      }),
      (this.getViewport = function (N) {
        return N.copy(se);
      }),
      (this.setViewport = function (N, $, ae, oe) {
        N.isVector4 ? se.set(N.x, N.y, N.z, N.w) : se.set(N, $, ae, oe),
          Te.viewport(D.copy(se).multiplyScalar(O).round());
      }),
      (this.getScissor = function (N) {
        return N.copy(Me);
      }),
      (this.setScissor = function (N, $, ae, oe) {
        N.isVector4 ? Me.set(N.x, N.y, N.z, N.w) : Me.set(N, $, ae, oe),
          Te.scissor(G.copy(Me).multiplyScalar(O).round());
      }),
      (this.getScissorTest = function () {
        return De;
      }),
      (this.setScissorTest = function (N) {
        Te.setScissorTest((De = N));
      }),
      (this.setOpaqueSort = function (N) {
        Y = N;
      }),
      (this.setTransparentSort = function (N) {
        F = N;
      }),
      (this.getClearColor = function (N) {
        return N.copy(mt.getClearColor());
      }),
      (this.setClearColor = function () {
        mt.setClearColor.apply(mt, arguments);
      }),
      (this.getClearAlpha = function () {
        return mt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        mt.setClearAlpha.apply(mt, arguments);
      }),
      (this.clear = function (N = !0, $ = !0, ae = !0) {
        let oe = 0;
        if (N) {
          let Q = !1;
          if (I !== null) {
            const Ee = I.texture.format;
            Q = Ee === ax || Ee === ox || Ee === km;
          }
          if (Q) {
            const Ee = I.texture.type,
              Je =
                Ee === xo ||
                Ee === Ua ||
                Ee === Eh ||
                Ee === Ac ||
                Ee === ix ||
                Ee === rx,
              it = mt.getClearColor(),
              $e = mt.getClearAlpha(),
              ct = it.r,
              pt = it.g,
              Ge = it.b;
            Je
              ? ((v[0] = ct),
                (v[1] = pt),
                (v[2] = Ge),
                (v[3] = $e),
                k.clearBufferuiv(k.COLOR, 0, v))
              : ((_[0] = ct),
                (_[1] = pt),
                (_[2] = Ge),
                (_[3] = $e),
                k.clearBufferiv(k.COLOR, 0, _));
          } else oe |= k.COLOR_BUFFER_BIT;
        }
        $ && (oe |= k.DEPTH_BUFFER_BIT),
          ae &&
            ((oe |= k.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          k.clear(oe);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", ge, !1),
          t.removeEventListener("webglcontextrestored", Ue, !1),
          t.removeEventListener("webglcontextcreationerror", ke, !1),
          mt.dispose(),
          ze.dispose(),
          Mt.dispose(),
          Le.dispose(),
          L.dispose(),
          ie.dispose(),
          me.dispose(),
          He.dispose(),
          V.dispose(),
          Pe.dispose(),
          ue.dispose(),
          ue.removeEventListener("sessionstart", je),
          ue.removeEventListener("sessionend", Tt),
          ut.stop();
      });
    function ge(N) {
      N.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (C = !0);
    }
    function Ue() {
      console.log("THREE.WebGLRenderer: Context Restored."), (C = !1);
      const N = st.autoReset,
        $ = Ne.enabled,
        ae = Ne.autoUpdate,
        oe = Ne.needsUpdate,
        Q = Ne.type;
      be(),
        (st.autoReset = N),
        (Ne.enabled = $),
        (Ne.autoUpdate = ae),
        (Ne.needsUpdate = oe),
        (Ne.type = Q);
    }
    function ke(N) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        N.statusMessage
      );
    }
    function ft(N) {
      const $ = N.target;
      $.removeEventListener("dispose", ft), Ct($);
    }
    function Ct(N) {
      cn(N), Le.remove(N);
    }
    function cn(N) {
      const $ = Le.get(N).programs;
      $ !== void 0 &&
        ($.forEach(function (ae) {
          Pe.releaseProgram(ae);
        }),
        N.isShaderMaterial && Pe.releaseShaderCache(N));
    }
    this.renderBufferDirect = function (N, $, ae, oe, Q, Ee) {
      $ === null && ($ = Fe);
      const Je = Q.isMesh && Q.matrixWorld.determinant() < 0,
        it = sr(N, $, ae, oe, Q);
      Te.setMaterial(oe, Je);
      let $e = ae.index,
        ct = 1;
      if (oe.wireframe === !0) {
        if ((($e = ye.getWireframeAttribute(ae)), $e === void 0)) return;
        ct = 2;
      }
      const pt = ae.drawRange,
        Ge = ae.attributes.position;
      let rt = pt.start * ct,
        kt = (pt.start + pt.count) * ct;
      Ee !== null &&
        ((rt = Math.max(rt, Ee.start * ct)),
        (kt = Math.min(kt, (Ee.start + Ee.count) * ct))),
        $e !== null
          ? ((rt = Math.max(rt, 0)), (kt = Math.min(kt, $e.count)))
          : Ge != null &&
            ((rt = Math.max(rt, 0)), (kt = Math.min(kt, Ge.count)));
      const Xt = kt - rt;
      if (Xt < 0 || Xt === 1 / 0) return;
      He.setup(Q, oe, it, ae, $e);
      let Jt,
        Ot = Ke;
      if (
        ($e !== null && ((Jt = fe.get($e)), (Ot = X), Ot.setIndex(Jt)),
        Q.isMesh)
      )
        oe.wireframe === !0
          ? (Te.setLineWidth(oe.wireframeLinewidth * ce()), Ot.setMode(k.LINES))
          : Ot.setMode(k.TRIANGLES);
      else if (Q.isLine) {
        let gt = oe.linewidth;
        gt === void 0 && (gt = 1),
          Te.setLineWidth(gt * ce()),
          Q.isLineSegments
            ? Ot.setMode(k.LINES)
            : Q.isLineLoop
            ? Ot.setMode(k.LINE_LOOP)
            : Ot.setMode(k.LINE_STRIP);
      } else
        Q.isPoints
          ? Ot.setMode(k.POINTS)
          : Q.isSprite && Ot.setMode(k.TRIANGLES);
      if (Q.isBatchedMesh)
        if (Q._multiDrawInstances !== null)
          Ot.renderMultiDrawInstances(
            Q._multiDrawStarts,
            Q._multiDrawCounts,
            Q._multiDrawCount,
            Q._multiDrawInstances
          );
        else if (we.get("WEBGL_multi_draw"))
          Ot.renderMultiDraw(
            Q._multiDrawStarts,
            Q._multiDrawCounts,
            Q._multiDrawCount
          );
        else {
          const gt = Q._multiDrawStarts,
            on = Q._multiDrawCounts,
            Qt = Q._multiDrawCount,
            Tr = $e ? fe.get($e).bytesPerElement : 1,
            qo = Le.get(oe).currentProgram.getUniforms();
          for (let _i = 0; _i < Qt; _i++)
            qo.setValue(k, "_gl_DrawID", _i), Ot.render(gt[_i] / Tr, on[_i]);
        }
      else if (Q.isInstancedMesh) Ot.renderInstances(rt, Xt, Q.count);
      else if (ae.isInstancedBufferGeometry) {
        const gt =
            ae._maxInstanceCount !== void 0 ? ae._maxInstanceCount : 1 / 0,
          on = Math.min(ae.instanceCount, gt);
        Ot.renderInstances(rt, Xt, on);
      } else Ot.render(rt, Xt);
    };
    function We(N, $, ae) {
      N.transparent === !0 && N.side === Vs && N.forceSinglePass === !1
        ? ((N.side = Ar),
          (N.needsUpdate = !0),
          hn(N, $, ae),
          (N.side = Yo),
          (N.needsUpdate = !0),
          hn(N, $, ae),
          (N.side = Vs))
        : hn(N, $, ae);
    }
    (this.compile = function (N, $, ae = null) {
      ae === null && (ae = N),
        (g = Mt.get(ae)),
        g.init($),
        S.push(g),
        ae.traverseVisible(function (Q) {
          Q.isLight &&
            Q.layers.test($.layers) &&
            (g.pushLight(Q), Q.castShadow && g.pushShadow(Q));
        }),
        N !== ae &&
          N.traverseVisible(function (Q) {
            Q.isLight &&
              Q.layers.test($.layers) &&
              (g.pushLight(Q), Q.castShadow && g.pushShadow(Q));
          }),
        g.setupLights();
      const oe = new Set();
      return (
        N.traverse(function (Q) {
          if (!(Q.isMesh || Q.isPoints || Q.isLine || Q.isSprite)) return;
          const Ee = Q.material;
          if (Ee)
            if (Array.isArray(Ee))
              for (let Je = 0; Je < Ee.length; Je++) {
                const it = Ee[Je];
                We(it, ae, Q), oe.add(it);
              }
            else We(Ee, ae, Q), oe.add(Ee);
        }),
        S.pop(),
        (g = null),
        oe
      );
    }),
      (this.compileAsync = function (N, $, ae = null) {
        const oe = this.compile(N, $, ae);
        return new Promise((Q) => {
          function Ee() {
            if (
              (oe.forEach(function (Je) {
                Le.get(Je).currentProgram.isReady() && oe.delete(Je);
              }),
              oe.size === 0)
            ) {
              Q(N);
              return;
            }
            setTimeout(Ee, 10);
          }
          we.get("KHR_parallel_shader_compile") !== null
            ? Ee()
            : setTimeout(Ee, 10);
        });
      });
    let nt = null;
    function Et(N) {
      nt && nt(N);
    }
    function je() {
      ut.stop();
    }
    function Tt() {
      ut.start();
    }
    const ut = new qN();
    ut.setAnimationLoop(Et),
      typeof self < "u" && ut.setContext(self),
      (this.setAnimationLoop = function (N) {
        (nt = N), ue.setAnimationLoop(N), N === null ? ut.stop() : ut.start();
      }),
      ue.addEventListener("sessionstart", je),
      ue.addEventListener("sessionend", Tt),
      (this.render = function (N, $) {
        if ($ !== void 0 && $.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (C === !0) return;
        if (
          (N.matrixWorldAutoUpdate === !0 && N.updateMatrixWorld(),
          $.parent === null &&
            $.matrixWorldAutoUpdate === !0 &&
            $.updateMatrixWorld(),
          ue.enabled === !0 &&
            ue.isPresenting === !0 &&
            (ue.cameraAutoUpdate === !0 && ue.updateCamera($),
            ($ = ue.getCamera())),
          N.isScene === !0 && N.onBeforeRender(w, N, $, I),
          (g = Mt.get(N, S.length)),
          g.init($),
          S.push(g),
          Xe.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse),
          re.setFromProjectionMatrix(Xe),
          (Ce = this.localClippingEnabled),
          (xe = Re.init(this.clippingPlanes, Ce)),
          (x = ze.get(N, A.length)),
          x.init(),
          A.push(x),
          ue.enabled === !0 && ue.isPresenting === !0)
        ) {
          const Ee = w.xr.getDepthSensingMesh();
          Ee !== null && St(Ee, $, -1 / 0, w.sortObjects);
        }
        St(N, $, 0, w.sortObjects),
          x.finish(),
          w.sortObjects === !0 && x.sort(Y, F),
          (de =
            ue.enabled === !1 ||
            ue.isPresenting === !1 ||
            ue.hasDepthSensing() === !1),
          de && mt.addToRenderList(x, N),
          this.info.render.frame++,
          xe === !0 && Re.beginShadows();
        const ae = g.state.shadowsArray;
        Ne.render(ae, N, $),
          xe === !0 && Re.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const oe = x.opaque,
          Q = x.transmissive;
        if ((g.setupLights(), $.isArrayCamera)) {
          const Ee = $.cameras;
          if (Q.length > 0)
            for (let Je = 0, it = Ee.length; Je < it; Je++) {
              const $e = Ee[Je];
              bt(oe, Q, N, $e);
            }
          de && mt.render(N);
          for (let Je = 0, it = Ee.length; Je < it; Je++) {
            const $e = Ee[Je];
            Bn(x, N, $e, $e.viewport);
          }
        } else Q.length > 0 && bt(oe, Q, N, $), de && mt.render(N), Bn(x, N, $);
        I !== null &&
          P === 0 &&
          (U.updateMultisampleRenderTarget(I), U.updateRenderTargetMipmap(I)),
          N.isScene === !0 && N.onAfterRender(w, N, $),
          He.resetDefaultState(),
          (R = -1),
          (T = null),
          S.pop(),
          S.length > 0
            ? ((g = S[S.length - 1]),
              xe === !0 && Re.setGlobalState(w.clippingPlanes, g.state.camera))
            : (g = null),
          A.pop(),
          A.length > 0 ? (x = A[A.length - 1]) : (x = null);
      });
    function St(N, $, ae, oe) {
      if (N.visible === !1) return;
      if (N.layers.test($.layers)) {
        if (N.isGroup) ae = N.renderOrder;
        else if (N.isLOD) N.autoUpdate === !0 && N.update($);
        else if (N.isLight) g.pushLight(N), N.castShadow && g.pushShadow(N);
        else if (N.isSprite) {
          if (!N.frustumCulled || re.intersectsSprite(N)) {
            oe && Ye.setFromMatrixPosition(N.matrixWorld).applyMatrix4(Xe);
            const Je = me.update(N),
              it = N.material;
            it.visible && x.push(N, Je, it, ae, Ye.z, null);
          }
        } else if (
          (N.isMesh || N.isLine || N.isPoints) &&
          (!N.frustumCulled || re.intersectsObject(N))
        ) {
          const Je = me.update(N),
            it = N.material;
          if (
            (oe &&
              (N.boundingSphere !== void 0
                ? (N.boundingSphere === null && N.computeBoundingSphere(),
                  Ye.copy(N.boundingSphere.center))
                : (Je.boundingSphere === null && Je.computeBoundingSphere(),
                  Ye.copy(Je.boundingSphere.center)),
              Ye.applyMatrix4(N.matrixWorld).applyMatrix4(Xe)),
            Array.isArray(it))
          ) {
            const $e = Je.groups;
            for (let ct = 0, pt = $e.length; ct < pt; ct++) {
              const Ge = $e[ct],
                rt = it[Ge.materialIndex];
              rt && rt.visible && x.push(N, Je, rt, ae, Ye.z, Ge);
            }
          } else it.visible && x.push(N, Je, it, ae, Ye.z, null);
        }
      }
      const Ee = N.children;
      for (let Je = 0, it = Ee.length; Je < it; Je++) St(Ee[Je], $, ae, oe);
    }
    function Bn(N, $, ae, oe) {
      const Q = N.opaque,
        Ee = N.transmissive,
        Je = N.transparent;
      g.setupLightsView(ae),
        xe === !0 && Re.setGlobalState(w.clippingPlanes, ae),
        oe && Te.viewport(D.copy(oe)),
        Q.length > 0 && gn(Q, $, ae),
        Ee.length > 0 && gn(Ee, $, ae),
        Je.length > 0 && gn(Je, $, ae),
        Te.buffers.depth.setTest(!0),
        Te.buffers.depth.setMask(!0),
        Te.buffers.color.setMask(!0),
        Te.setPolygonOffset(!1);
    }
    function bt(N, $, ae, oe) {
      if ((ae.isScene === !0 ? ae.overrideMaterial : null) !== null) return;
      g.state.transmissionRenderTarget[oe.id] === void 0 &&
        (g.state.transmissionRenderTarget[oe.id] = new Ko(1, 1, {
          generateMipmaps: !0,
          type:
            we.has("EXT_color_buffer_half_float") ||
            we.has("EXT_color_buffer_float")
              ? jh
              : xo,
          minFilter: Xs,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: en.workingColorSpace,
        }));
      const Ee = g.state.transmissionRenderTarget[oe.id],
        Je = oe.viewport || D;
      Ee.setSize(
        Je.z * w.transmissionResolutionScale,
        Je.w * w.transmissionResolutionScale
      );
      const it = w.getRenderTarget();
      w.setRenderTarget(Ee),
        w.getClearColor(q),
        (Z = w.getClearAlpha()),
        Z < 1 && w.setClearColor(16777215, 0.5),
        w.clear(),
        de && mt.render(ae);
      const $e = w.toneMapping;
      w.toneMapping = Vo;
      const ct = oe.viewport;
      if (
        (oe.viewport !== void 0 && (oe.viewport = void 0),
        g.setupLightsView(oe),
        xe === !0 && Re.setGlobalState(w.clippingPlanes, oe),
        gn(N, ae, oe),
        U.updateMultisampleRenderTarget(Ee),
        U.updateRenderTargetMipmap(Ee),
        we.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let pt = !1;
        for (let Ge = 0, rt = $.length; Ge < rt; Ge++) {
          const kt = $[Ge],
            Xt = kt.object,
            Jt = kt.geometry,
            Ot = kt.material,
            gt = kt.group;
          if (Ot.side === Vs && Xt.layers.test(oe.layers)) {
            const on = Ot.side;
            (Ot.side = Ar),
              (Ot.needsUpdate = !0),
              Wn(Xt, ae, oe, Jt, Ot, gt),
              (Ot.side = on),
              (Ot.needsUpdate = !0),
              (pt = !0);
          }
        }
        pt === !0 &&
          (U.updateMultisampleRenderTarget(Ee), U.updateRenderTargetMipmap(Ee));
      }
      w.setRenderTarget(it),
        w.setClearColor(q, Z),
        ct !== void 0 && (oe.viewport = ct),
        (w.toneMapping = $e);
    }
    function gn(N, $, ae) {
      const oe = $.isScene === !0 ? $.overrideMaterial : null;
      for (let Q = 0, Ee = N.length; Q < Ee; Q++) {
        const Je = N[Q],
          it = Je.object,
          $e = Je.geometry,
          ct = oe === null ? Je.material : oe,
          pt = Je.group;
        it.layers.test(ae.layers) && Wn(it, $, ae, $e, ct, pt);
      }
    }
    function Wn(N, $, ae, oe, Q, Ee) {
      N.onBeforeRender(w, $, ae, oe, Q, Ee),
        N.modelViewMatrix.multiplyMatrices(
          ae.matrixWorldInverse,
          N.matrixWorld
        ),
        N.normalMatrix.getNormalMatrix(N.modelViewMatrix),
        Q.onBeforeRender(w, $, ae, oe, N, Ee),
        Q.transparent === !0 && Q.side === Vs && Q.forceSinglePass === !1
          ? ((Q.side = Ar),
            (Q.needsUpdate = !0),
            w.renderBufferDirect(ae, $, oe, Q, N, Ee),
            (Q.side = Yo),
            (Q.needsUpdate = !0),
            w.renderBufferDirect(ae, $, oe, Q, N, Ee),
            (Q.side = Vs))
          : w.renderBufferDirect(ae, $, oe, Q, N, Ee),
        N.onAfterRender(w, $, ae, oe, Q, Ee);
    }
    function hn(N, $, ae) {
      $.isScene !== !0 && ($ = Fe);
      const oe = Le.get(N),
        Q = g.state.lights,
        Ee = g.state.shadowsArray,
        Je = Q.state.version,
        it = Pe.getParameters(N, Q.state, Ee, $, ae),
        $e = Pe.getProgramCacheKey(it);
      let ct = oe.programs;
      (oe.environment = N.isMeshStandardMaterial ? $.environment : null),
        (oe.fog = $.fog),
        (oe.envMap = (N.isMeshStandardMaterial ? ie : L).get(
          N.envMap || oe.environment
        )),
        (oe.envMapRotation =
          oe.environment !== null && N.envMap === null
            ? $.environmentRotation
            : N.envMapRotation),
        ct === void 0 &&
          (N.addEventListener("dispose", ft),
          (ct = new Map()),
          (oe.programs = ct));
      let pt = ct.get($e);
      if (pt !== void 0) {
        if (oe.currentProgram === pt && oe.lightsStateVersion === Je)
          return sn(N, it), pt;
      } else
        (it.uniforms = Pe.getUniforms(N)),
          N.onBeforeCompile(it, w),
          (pt = Pe.acquireProgram(it, $e)),
          ct.set($e, pt),
          (oe.uniforms = it.uniforms);
      const Ge = oe.uniforms;
      return (
        ((!N.isShaderMaterial && !N.isRawShaderMaterial) ||
          N.clipping === !0) &&
          (Ge.clippingPlanes = Re.uniform),
        sn(N, it),
        (oe.needsLights = yi(N)),
        (oe.lightsStateVersion = Je),
        oe.needsLights &&
          ((Ge.ambientLightColor.value = Q.state.ambient),
          (Ge.lightProbe.value = Q.state.probe),
          (Ge.directionalLights.value = Q.state.directional),
          (Ge.directionalLightShadows.value = Q.state.directionalShadow),
          (Ge.spotLights.value = Q.state.spot),
          (Ge.spotLightShadows.value = Q.state.spotShadow),
          (Ge.rectAreaLights.value = Q.state.rectArea),
          (Ge.ltc_1.value = Q.state.rectAreaLTC1),
          (Ge.ltc_2.value = Q.state.rectAreaLTC2),
          (Ge.pointLights.value = Q.state.point),
          (Ge.pointLightShadows.value = Q.state.pointShadow),
          (Ge.hemisphereLights.value = Q.state.hemi),
          (Ge.directionalShadowMap.value = Q.state.directionalShadowMap),
          (Ge.directionalShadowMatrix.value = Q.state.directionalShadowMatrix),
          (Ge.spotShadowMap.value = Q.state.spotShadowMap),
          (Ge.spotLightMatrix.value = Q.state.spotLightMatrix),
          (Ge.spotLightMap.value = Q.state.spotLightMap),
          (Ge.pointShadowMap.value = Q.state.pointShadowMap),
          (Ge.pointShadowMatrix.value = Q.state.pointShadowMatrix)),
        (oe.currentProgram = pt),
        (oe.uniformsList = null),
        pt
      );
    }
    function dn(N) {
      if (N.uniformsList === null) {
        const $ = N.currentProgram.getUniforms();
        N.uniformsList = kv.seqWithValue($.seq, N.uniforms);
      }
      return N.uniformsList;
    }
    function sn(N, $) {
      const ae = Le.get(N);
      (ae.outputColorSpace = $.outputColorSpace),
        (ae.batching = $.batching),
        (ae.batchingColor = $.batchingColor),
        (ae.instancing = $.instancing),
        (ae.instancingColor = $.instancingColor),
        (ae.instancingMorph = $.instancingMorph),
        (ae.skinning = $.skinning),
        (ae.morphTargets = $.morphTargets),
        (ae.morphNormals = $.morphNormals),
        (ae.morphColors = $.morphColors),
        (ae.morphTargetsCount = $.morphTargetsCount),
        (ae.numClippingPlanes = $.numClippingPlanes),
        (ae.numIntersection = $.numClipIntersection),
        (ae.vertexAlphas = $.vertexAlphas),
        (ae.vertexTangents = $.vertexTangents),
        (ae.toneMapping = $.toneMapping);
    }
    function sr(N, $, ae, oe, Q) {
      $.isScene !== !0 && ($ = Fe), U.resetTextureUnits();
      const Ee = $.fog,
        Je = oe.isMeshStandardMaterial ? $.environment : null,
        it =
          I === null
            ? w.outputColorSpace
            : I.isXRRenderTarget === !0
            ? I.texture.colorSpace
            : Mc,
        $e = (oe.isMeshStandardMaterial ? ie : L).get(oe.envMap || Je),
        ct =
          oe.vertexColors === !0 &&
          !!ae.attributes.color &&
          ae.attributes.color.itemSize === 4,
        pt = !!ae.attributes.tangent && (!!oe.normalMap || oe.anisotropy > 0),
        Ge = !!ae.morphAttributes.position,
        rt = !!ae.morphAttributes.normal,
        kt = !!ae.morphAttributes.color;
      let Xt = Vo;
      oe.toneMapped &&
        (I === null || I.isXRRenderTarget === !0) &&
        (Xt = w.toneMapping);
      const Jt =
          ae.morphAttributes.position ||
          ae.morphAttributes.normal ||
          ae.morphAttributes.color,
        Ot = Jt !== void 0 ? Jt.length : 0,
        gt = Le.get(oe),
        on = g.state.lights;
      if (xe === !0 && (Ce === !0 || N !== T)) {
        const Bi = N === T && oe.id === R;
        Re.setState(oe, N, Bi);
      }
      let Qt = !1;
      oe.version === gt.__version
        ? ((gt.needsLights && gt.lightsStateVersion !== on.state.version) ||
            gt.outputColorSpace !== it ||
            (Q.isBatchedMesh && gt.batching === !1) ||
            (!Q.isBatchedMesh && gt.batching === !0) ||
            (Q.isBatchedMesh &&
              gt.batchingColor === !0 &&
              Q.colorTexture === null) ||
            (Q.isBatchedMesh &&
              gt.batchingColor === !1 &&
              Q.colorTexture !== null) ||
            (Q.isInstancedMesh && gt.instancing === !1) ||
            (!Q.isInstancedMesh && gt.instancing === !0) ||
            (Q.isSkinnedMesh && gt.skinning === !1) ||
            (!Q.isSkinnedMesh && gt.skinning === !0) ||
            (Q.isInstancedMesh &&
              gt.instancingColor === !0 &&
              Q.instanceColor === null) ||
            (Q.isInstancedMesh &&
              gt.instancingColor === !1 &&
              Q.instanceColor !== null) ||
            (Q.isInstancedMesh &&
              gt.instancingMorph === !0 &&
              Q.morphTexture === null) ||
            (Q.isInstancedMesh &&
              gt.instancingMorph === !1 &&
              Q.morphTexture !== null) ||
            gt.envMap !== $e ||
            (oe.fog === !0 && gt.fog !== Ee) ||
            (gt.numClippingPlanes !== void 0 &&
              (gt.numClippingPlanes !== Re.numPlanes ||
                gt.numIntersection !== Re.numIntersection)) ||
            gt.vertexAlphas !== ct ||
            gt.vertexTangents !== pt ||
            gt.morphTargets !== Ge ||
            gt.morphNormals !== rt ||
            gt.morphColors !== kt ||
            gt.toneMapping !== Xt ||
            gt.morphTargetsCount !== Ot) &&
          (Qt = !0)
        : ((Qt = !0), (gt.__version = oe.version));
      let Tr = gt.currentProgram;
      Qt === !0 && (Tr = hn(oe, $, Q));
      let qo = !1,
        _i = !1,
        Wa = !1;
      const Kt = Tr.getUniforms(),
        Cr = gt.uniforms;
      if (
        (Te.useProgram(Tr.program) && ((qo = !0), (_i = !0), (Wa = !0)),
        oe.id !== R && ((R = oe.id), (_i = !0)),
        qo || T !== N)
      ) {
        Te.buffers.depth.getReversed()
          ? (Se.copy(N.projectionMatrix),
            f9(Se),
            h9(Se),
            Kt.setValue(k, "projectionMatrix", Se))
          : Kt.setValue(k, "projectionMatrix", N.projectionMatrix),
          Kt.setValue(k, "viewMatrix", N.matrixWorldInverse);
        const li = Kt.map.cameraPosition;
        li !== void 0 &&
          li.setValue(k, et.setFromMatrixPosition(N.matrixWorld)),
          J.logarithmicDepthBuffer &&
            Kt.setValue(
              k,
              "logDepthBufFC",
              2 / (Math.log(N.far + 1) / Math.LN2)
            ),
          (oe.isMeshPhongMaterial ||
            oe.isMeshToonMaterial ||
            oe.isMeshLambertMaterial ||
            oe.isMeshBasicMaterial ||
            oe.isMeshStandardMaterial ||
            oe.isShaderMaterial) &&
            Kt.setValue(k, "isOrthographic", N.isOrthographicCamera === !0),
          T !== N && ((T = N), (_i = !0), (Wa = !0));
      }
      if (Q.isSkinnedMesh) {
        Kt.setOptional(k, Q, "bindMatrix"),
          Kt.setOptional(k, Q, "bindMatrixInverse");
        const Bi = Q.skeleton;
        Bi &&
          (Bi.boneTexture === null && Bi.computeBoneTexture(),
          Kt.setValue(k, "boneTexture", Bi.boneTexture, U));
      }
      Q.isBatchedMesh &&
        (Kt.setOptional(k, Q, "batchingTexture"),
        Kt.setValue(k, "batchingTexture", Q._matricesTexture, U),
        Kt.setOptional(k, Q, "batchingIdTexture"),
        Kt.setValue(k, "batchingIdTexture", Q._indirectTexture, U),
        Kt.setOptional(k, Q, "batchingColorTexture"),
        Q._colorsTexture !== null &&
          Kt.setValue(k, "batchingColorTexture", Q._colorsTexture, U));
      const br = ae.morphAttributes;
      if (
        ((br.position !== void 0 ||
          br.normal !== void 0 ||
          br.color !== void 0) &&
          dt.update(Q, ae, Tr),
        (_i || gt.receiveShadow !== Q.receiveShadow) &&
          ((gt.receiveShadow = Q.receiveShadow),
          Kt.setValue(k, "receiveShadow", Q.receiveShadow)),
        oe.isMeshGouraudMaterial &&
          oe.envMap !== null &&
          ((Cr.envMap.value = $e),
          (Cr.flipEnvMap.value =
            $e.isCubeTexture && $e.isRenderTargetTexture === !1 ? -1 : 1)),
        oe.isMeshStandardMaterial &&
          oe.envMap === null &&
          $.environment !== null &&
          (Cr.envMapIntensity.value = $.environmentIntensity),
        _i &&
          (Kt.setValue(k, "toneMappingExposure", w.toneMappingExposure),
          gt.needsLights && vn(Cr, Wa),
          Ee && oe.fog === !0 && Ie.refreshFogUniforms(Cr, Ee),
          Ie.refreshMaterialUniforms(
            Cr,
            oe,
            O,
            te,
            g.state.transmissionRenderTarget[N.id]
          ),
          kv.upload(k, dn(gt), Cr, U)),
        oe.isShaderMaterial &&
          oe.uniformsNeedUpdate === !0 &&
          (kv.upload(k, dn(gt), Cr, U), (oe.uniformsNeedUpdate = !1)),
        oe.isSpriteMaterial && Kt.setValue(k, "center", Q.center),
        Kt.setValue(k, "modelViewMatrix", Q.modelViewMatrix),
        Kt.setValue(k, "normalMatrix", Q.normalMatrix),
        Kt.setValue(k, "modelMatrix", Q.matrixWorld),
        oe.isShaderMaterial || oe.isRawShaderMaterial)
      ) {
        const Bi = oe.uniformsGroups;
        for (let li = 0, Xa = Bi.length; li < Xa; li++) {
          const Qr = Bi[li];
          V.update(Qr, Tr), V.bind(Qr, Tr);
        }
      }
      return Tr;
    }
    function vn(N, $) {
      (N.ambientLightColor.needsUpdate = $),
        (N.lightProbe.needsUpdate = $),
        (N.directionalLights.needsUpdate = $),
        (N.directionalLightShadows.needsUpdate = $),
        (N.pointLights.needsUpdate = $),
        (N.pointLightShadows.needsUpdate = $),
        (N.spotLights.needsUpdate = $),
        (N.spotLightShadows.needsUpdate = $),
        (N.rectAreaLights.needsUpdate = $),
        (N.hemisphereLights.needsUpdate = $);
    }
    function yi(N) {
      return (
        N.isMeshLambertMaterial ||
        N.isMeshToonMaterial ||
        N.isMeshPhongMaterial ||
        N.isMeshStandardMaterial ||
        N.isShadowMaterial ||
        (N.isShaderMaterial && N.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return b;
    }),
      (this.getActiveMipmapLevel = function () {
        return P;
      }),
      (this.getRenderTarget = function () {
        return I;
      }),
      (this.setRenderTargetTextures = function (N, $, ae) {
        (Le.get(N.texture).__webglTexture = $),
          (Le.get(N.depthTexture).__webglTexture = ae);
        const oe = Le.get(N);
        (oe.__hasExternalTextures = !0),
          (oe.__autoAllocateDepthBuffer = ae === void 0),
          oe.__autoAllocateDepthBuffer ||
            (we.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (oe.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (N, $) {
        const ae = Le.get(N);
        (ae.__webglFramebuffer = $),
          (ae.__useDefaultFramebuffer = $ === void 0);
      });
    const Er = k.createFramebuffer();
    (this.setRenderTarget = function (N, $ = 0, ae = 0) {
      (I = N), (b = $), (P = ae);
      let oe = !0,
        Q = null,
        Ee = !1,
        Je = !1;
      if (N) {
        const $e = Le.get(N);
        if ($e.__useDefaultFramebuffer !== void 0)
          Te.bindFramebuffer(k.FRAMEBUFFER, null), (oe = !1);
        else if ($e.__webglFramebuffer === void 0) U.setupRenderTarget(N);
        else if ($e.__hasExternalTextures)
          U.rebindTextures(
            N,
            Le.get(N.texture).__webglTexture,
            Le.get(N.depthTexture).__webglTexture
          );
        else if (N.depthBuffer) {
          const Ge = N.depthTexture;
          if ($e.__boundDepthTexture !== Ge) {
            if (
              Ge !== null &&
              Le.has(Ge) &&
              (N.width !== Ge.image.width || N.height !== Ge.image.height)
            )
              throw new Error(
                "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
              );
            U.setupDepthRenderbuffer(N);
          }
        }
        const ct = N.texture;
        (ct.isData3DTexture ||
          ct.isDataArrayTexture ||
          ct.isCompressedArrayTexture) &&
          (Je = !0);
        const pt = Le.get(N).__webglFramebuffer;
        N.isWebGLCubeRenderTarget
          ? (Array.isArray(pt[$]) ? (Q = pt[$][ae]) : (Q = pt[$]), (Ee = !0))
          : N.samples > 0 && U.useMultisampledRTT(N) === !1
          ? (Q = Le.get(N).__webglMultisampledFramebuffer)
          : Array.isArray(pt)
          ? (Q = pt[ae])
          : (Q = pt),
          D.copy(N.viewport),
          G.copy(N.scissor),
          (W = N.scissorTest);
      } else
        D.copy(se).multiplyScalar(O).floor(),
          G.copy(Me).multiplyScalar(O).floor(),
          (W = De);
      if (
        (ae !== 0 && (Q = Er),
        Te.bindFramebuffer(k.FRAMEBUFFER, Q) && oe && Te.drawBuffers(N, Q),
        Te.viewport(D),
        Te.scissor(G),
        Te.setScissorTest(W),
        Ee)
      ) {
        const $e = Le.get(N.texture);
        k.framebufferTexture2D(
          k.FRAMEBUFFER,
          k.COLOR_ATTACHMENT0,
          k.TEXTURE_CUBE_MAP_POSITIVE_X + $,
          $e.__webglTexture,
          ae
        );
      } else if (Je) {
        const $e = Le.get(N.texture),
          ct = $;
        k.framebufferTextureLayer(
          k.FRAMEBUFFER,
          k.COLOR_ATTACHMENT0,
          $e.__webglTexture,
          ae,
          ct
        );
      } else if (N !== null && ae !== 0) {
        const $e = Le.get(N.texture);
        k.framebufferTexture2D(
          k.FRAMEBUFFER,
          k.COLOR_ATTACHMENT0,
          k.TEXTURE_2D,
          $e.__webglTexture,
          ae
        );
      }
      R = -1;
    }),
      (this.readRenderTargetPixels = function (N, $, ae, oe, Q, Ee, Je) {
        if (!(N && N.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let it = Le.get(N).__webglFramebuffer;
        if ((N.isWebGLCubeRenderTarget && Je !== void 0 && (it = it[Je]), it)) {
          Te.bindFramebuffer(k.FRAMEBUFFER, it);
          try {
            const $e = N.texture,
              ct = $e.format,
              pt = $e.type;
            if (!J.textureFormatReadable(ct)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!J.textureTypeReadable(pt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            $ >= 0 &&
              $ <= N.width - oe &&
              ae >= 0 &&
              ae <= N.height - Q &&
              k.readPixels($, ae, oe, Q, pe.convert(ct), pe.convert(pt), Ee);
          } finally {
            const $e = I !== null ? Le.get(I).__webglFramebuffer : null;
            Te.bindFramebuffer(k.FRAMEBUFFER, $e);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        N,
        $,
        ae,
        oe,
        Q,
        Ee,
        Je
      ) {
        if (!(N && N.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let it = Le.get(N).__webglFramebuffer;
        if ((N.isWebGLCubeRenderTarget && Je !== void 0 && (it = it[Je]), it)) {
          const $e = N.texture,
            ct = $e.format,
            pt = $e.type;
          if (!J.textureFormatReadable(ct))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
            );
          if (!J.textureTypeReadable(pt))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          if ($ >= 0 && $ <= N.width - oe && ae >= 0 && ae <= N.height - Q) {
            Te.bindFramebuffer(k.FRAMEBUFFER, it);
            const Ge = k.createBuffer();
            k.bindBuffer(k.PIXEL_PACK_BUFFER, Ge),
              k.bufferData(k.PIXEL_PACK_BUFFER, Ee.byteLength, k.STREAM_READ),
              k.readPixels($, ae, oe, Q, pe.convert(ct), pe.convert(pt), 0);
            const rt = I !== null ? Le.get(I).__webglFramebuffer : null;
            Te.bindFramebuffer(k.FRAMEBUFFER, rt);
            const kt = k.fenceSync(k.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              k.flush(),
              await c9(k, kt, 4),
              k.bindBuffer(k.PIXEL_PACK_BUFFER, Ge),
              k.getBufferSubData(k.PIXEL_PACK_BUFFER, 0, Ee),
              k.deleteBuffer(Ge),
              k.deleteSync(kt),
              Ee
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
            );
        }
      }),
      (this.copyFramebufferToTexture = function (N, $ = null, ae = 0) {
        N.isTexture !== !0 &&
          (Cf(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed."
          ),
          ($ = arguments[0] || null),
          (N = arguments[1]));
        const oe = Math.pow(2, -ae),
          Q = Math.floor(N.image.width * oe),
          Ee = Math.floor(N.image.height * oe),
          Je = $ !== null ? $.x : 0,
          it = $ !== null ? $.y : 0;
        U.setTexture2D(N, 0),
          k.copyTexSubImage2D(k.TEXTURE_2D, ae, 0, 0, Je, it, Q, Ee),
          Te.unbindTexture();
      });
    const Xn = k.createFramebuffer(),
      Jn = k.createFramebuffer();
    (this.copyTextureToTexture = function (
      N,
      $,
      ae = null,
      oe = null,
      Q = 0,
      Ee = null
    ) {
      N.isTexture !== !0 &&
        (Cf(
          "WebGLRenderer: copyTextureToTexture function signature has changed."
        ),
        (oe = arguments[0] || null),
        (N = arguments[1]),
        ($ = arguments[2]),
        (Ee = arguments[3] || 0),
        (ae = null)),
        Ee === null &&
          (Q !== 0
            ? (Cf(
                "WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."
              ),
              (Ee = Q),
              (Q = 0))
            : (Ee = 0));
      let Je, it, $e, ct, pt, Ge, rt, kt, Xt;
      const Jt = N.isCompressedTexture ? N.mipmaps[Ee] : N.image;
      if (ae !== null)
        (Je = ae.max.x - ae.min.x),
          (it = ae.max.y - ae.min.y),
          ($e = ae.isBox3 ? ae.max.z - ae.min.z : 1),
          (ct = ae.min.x),
          (pt = ae.min.y),
          (Ge = ae.isBox3 ? ae.min.z : 0);
      else {
        const br = Math.pow(2, -Q);
        (Je = Math.floor(Jt.width * br)),
          (it = Math.floor(Jt.height * br)),
          N.isDataArrayTexture
            ? ($e = Jt.depth)
            : N.isData3DTexture
            ? ($e = Math.floor(Jt.depth * br))
            : ($e = 1),
          (ct = 0),
          (pt = 0),
          (Ge = 0);
      }
      oe !== null
        ? ((rt = oe.x), (kt = oe.y), (Xt = oe.z))
        : ((rt = 0), (kt = 0), (Xt = 0));
      const Ot = pe.convert($.format),
        gt = pe.convert($.type);
      let on;
      $.isData3DTexture
        ? (U.setTexture3D($, 0), (on = k.TEXTURE_3D))
        : $.isDataArrayTexture || $.isCompressedArrayTexture
        ? (U.setTexture2DArray($, 0), (on = k.TEXTURE_2D_ARRAY))
        : (U.setTexture2D($, 0), (on = k.TEXTURE_2D)),
        k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL, $.flipY),
        k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha),
        k.pixelStorei(k.UNPACK_ALIGNMENT, $.unpackAlignment);
      const Qt = k.getParameter(k.UNPACK_ROW_LENGTH),
        Tr = k.getParameter(k.UNPACK_IMAGE_HEIGHT),
        qo = k.getParameter(k.UNPACK_SKIP_PIXELS),
        _i = k.getParameter(k.UNPACK_SKIP_ROWS),
        Wa = k.getParameter(k.UNPACK_SKIP_IMAGES);
      k.pixelStorei(k.UNPACK_ROW_LENGTH, Jt.width),
        k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, Jt.height),
        k.pixelStorei(k.UNPACK_SKIP_PIXELS, ct),
        k.pixelStorei(k.UNPACK_SKIP_ROWS, pt),
        k.pixelStorei(k.UNPACK_SKIP_IMAGES, Ge);
      const Kt = N.isDataArrayTexture || N.isData3DTexture,
        Cr = $.isDataArrayTexture || $.isData3DTexture;
      if (N.isDepthTexture) {
        const br = Le.get(N),
          Bi = Le.get($),
          li = Le.get(br.__renderTarget),
          Xa = Le.get(Bi.__renderTarget);
        Te.bindFramebuffer(k.READ_FRAMEBUFFER, li.__webglFramebuffer),
          Te.bindFramebuffer(k.DRAW_FRAMEBUFFER, Xa.__webglFramebuffer);
        for (let Qr = 0; Qr < $e; Qr++)
          Kt &&
            (k.framebufferTextureLayer(
              k.READ_FRAMEBUFFER,
              k.COLOR_ATTACHMENT0,
              Le.get(N).__webglTexture,
              Q,
              Ge + Qr
            ),
            k.framebufferTextureLayer(
              k.DRAW_FRAMEBUFFER,
              k.COLOR_ATTACHMENT0,
              Le.get($).__webglTexture,
              Ee,
              Xt + Qr
            )),
            k.blitFramebuffer(
              ct,
              pt,
              Je,
              it,
              rt,
              kt,
              Je,
              it,
              k.DEPTH_BUFFER_BIT,
              k.NEAREST
            );
        Te.bindFramebuffer(k.READ_FRAMEBUFFER, null),
          Te.bindFramebuffer(k.DRAW_FRAMEBUFFER, null);
      } else if (Q !== 0 || N.isRenderTargetTexture || Le.has(N)) {
        const br = Le.get(N),
          Bi = Le.get($);
        Te.bindFramebuffer(k.READ_FRAMEBUFFER, Xn),
          Te.bindFramebuffer(k.DRAW_FRAMEBUFFER, Jn);
        for (let li = 0; li < $e; li++)
          Kt
            ? k.framebufferTextureLayer(
                k.READ_FRAMEBUFFER,
                k.COLOR_ATTACHMENT0,
                br.__webglTexture,
                Q,
                Ge + li
              )
            : k.framebufferTexture2D(
                k.READ_FRAMEBUFFER,
                k.COLOR_ATTACHMENT0,
                k.TEXTURE_2D,
                br.__webglTexture,
                Q
              ),
            Cr
              ? k.framebufferTextureLayer(
                  k.DRAW_FRAMEBUFFER,
                  k.COLOR_ATTACHMENT0,
                  Bi.__webglTexture,
                  Ee,
                  Xt + li
                )
              : k.framebufferTexture2D(
                  k.DRAW_FRAMEBUFFER,
                  k.COLOR_ATTACHMENT0,
                  k.TEXTURE_2D,
                  Bi.__webglTexture,
                  Ee
                ),
            Q !== 0
              ? k.blitFramebuffer(
                  ct,
                  pt,
                  Je,
                  it,
                  rt,
                  kt,
                  Je,
                  it,
                  k.COLOR_BUFFER_BIT,
                  k.NEAREST
                )
              : Cr
              ? k.copyTexSubImage3D(on, Ee, rt, kt, Xt + li, ct, pt, Je, it)
              : k.copyTexSubImage2D(on, Ee, rt, kt, ct, pt, Je, it);
        Te.bindFramebuffer(k.READ_FRAMEBUFFER, null),
          Te.bindFramebuffer(k.DRAW_FRAMEBUFFER, null);
      } else
        Cr
          ? N.isDataTexture || N.isData3DTexture
            ? k.texSubImage3D(on, Ee, rt, kt, Xt, Je, it, $e, Ot, gt, Jt.data)
            : $.isCompressedArrayTexture
            ? k.compressedTexSubImage3D(
                on,
                Ee,
                rt,
                kt,
                Xt,
                Je,
                it,
                $e,
                Ot,
                Jt.data
              )
            : k.texSubImage3D(on, Ee, rt, kt, Xt, Je, it, $e, Ot, gt, Jt)
          : N.isDataTexture
          ? k.texSubImage2D(k.TEXTURE_2D, Ee, rt, kt, Je, it, Ot, gt, Jt.data)
          : N.isCompressedTexture
          ? k.compressedTexSubImage2D(
              k.TEXTURE_2D,
              Ee,
              rt,
              kt,
              Jt.width,
              Jt.height,
              Ot,
              Jt.data
            )
          : k.texSubImage2D(k.TEXTURE_2D, Ee, rt, kt, Je, it, Ot, gt, Jt);
      k.pixelStorei(k.UNPACK_ROW_LENGTH, Qt),
        k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, Tr),
        k.pixelStorei(k.UNPACK_SKIP_PIXELS, qo),
        k.pixelStorei(k.UNPACK_SKIP_ROWS, _i),
        k.pixelStorei(k.UNPACK_SKIP_IMAGES, Wa),
        Ee === 0 && $.generateMipmaps && k.generateMipmap(on),
        Te.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (
        N,
        $,
        ae = null,
        oe = null,
        Q = 0
      ) {
        return (
          N.isTexture !== !0 &&
            (Cf(
              "WebGLRenderer: copyTextureToTexture3D function signature has changed."
            ),
            (ae = arguments[0] || null),
            (oe = arguments[1] || null),
            (N = arguments[2]),
            ($ = arguments[3]),
            (Q = arguments[4] || 0)),
          Cf(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(N, $, ae, oe, Q)
        );
      }),
      (this.initRenderTarget = function (N) {
        Le.get(N).__webglFramebuffer === void 0 && U.setupRenderTarget(N);
      }),
      (this.initTexture = function (N) {
        N.isCubeTexture
          ? U.setTextureCube(N, 0)
          : N.isData3DTexture
          ? U.setTexture3D(N, 0)
          : N.isDataArrayTexture || N.isCompressedArrayTexture
          ? U.setTexture2DArray(N, 0)
          : U.setTexture2D(N, 0),
          Te.unbindTexture();
      }),
      (this.resetState = function () {
        (b = 0), (P = 0), (I = null), Te.reset(), He.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return po;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorspace = en._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = en._getUnpackColorSpace());
  }
}
const yJ = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: $E,
      AddEquation: gl,
      AddOperation: FF,
      AdditiveAnimationBlendMode: uT,
      AdditiveBlending: JM,
      AgXToneMapping: zF,
      AlphaFormat: iT,
      AlwaysCompare: nN,
      AlwaysDepth: Cy,
      AlwaysStencilFunc: QM,
      AmbientLight: kN,
      AnimationAction: KN,
      AnimationClip: Ph,
      AnimationLoader: L5,
      AnimationMixer: a8,
      AnimationObjectGroup: s8,
      AnimationUtils: P5,
      ArcCurve: pN,
      ArrayCamera: JN,
      ArrowHelper: R8,
      AttachedBindMode: KM,
      Audio: jN,
      AudioAnalyser: K5,
      AudioContext: zT,
      AudioListener: J5,
      AudioLoader: V5,
      AxesHelper: P8,
      BackSide: Ar,
      BasicDepthPacking: jF,
      BasicShadowMap: mF,
      BatchedMesh: dN,
      Bone: dx,
      BooleanKeyframeTrack: Oc,
      Box2: m8,
      Box3: er,
      Box3Helper: C8,
      BoxGeometry: Nc,
      BoxHelper: T8,
      BufferAttribute: rn,
      BufferGeometry: Lt,
      BufferGeometryLoader: WN,
      ByteType: eT,
      Cache: Ma,
      Camera: Hm,
      CameraHelper: E8,
      CanvasTexture: e5,
      CapsuleGeometry: gx,
      CatmullRomCurve3: mN,
      CineonToneMapping: UF,
      CircleGeometry: vx,
      ClampToEdgeWrapping: fs,
      Clock: HT,
      Color: Ze,
      ColorKeyframeTrack: LT,
      ColorManagement: en,
      CompressedArrayTexture: q9,
      CompressedCubeTexture: $9,
      CompressedTexture: px,
      CompressedTextureLoader: F5,
      ConeGeometry: yx,
      ConstantAlphaFactor: IF,
      ConstantColorFactor: PF,
      Controls: I8,
      CubeCamera: mT,
      CubeReflectionMapping: Oa,
      CubeRefractionMapping: kl,
      CubeTexture: Gm,
      CubeTextureLoader: N5,
      CubeUVReflectionMapping: Jh,
      CubicBezierCurve: ET,
      CubicBezierCurve3: gN,
      CubicInterpolant: LN,
      CullFaceBack: XM,
      CullFaceFront: pF,
      CullFaceFrontBack: vV,
      CullFaceNone: dF,
      Curve: Mo,
      CurvePath: yN,
      CustomBlending: gF,
      CustomToneMapping: kF,
      CylinderGeometry: Yh,
      Cylindrical: p8,
      Data3DTexture: cx,
      DataArrayTexture: zm,
      DataTexture: Wo,
      DataTextureLoader: O5,
      DataUtils: C9,
      DecrementStencilOp: bV,
      DecrementWrapStencilOp: PV,
      DefaultLoadingManager: Jf,
      DepthFormat: ic,
      DepthStencilFormat: Sc,
      DepthTexture: MT,
      DetachedBindMode: GF,
      DirectionalLight: kT,
      DirectionalLightHelper: w8,
      DiscreteInterpolant: FN,
      DodecahedronGeometry: _x,
      DoubleSide: Vs,
      DstAlphaFactor: EF,
      DstColorFactor: CF,
      DynamicCopyUsage: WV,
      DynamicDrawUsage: rc,
      DynamicReadUsage: HV,
      EdgesGeometry: _N,
      EllipseCurve: mx,
      EqualCompare: qF,
      EqualDepth: Ry,
      EqualStencilFunc: LV,
      EquirectangularReflectionMapping: om,
      EquirectangularRefractionMapping: am,
      Euler: ys,
      EventDispatcher: Zo,
      ExtrudeGeometry: Ax,
      FileLoader: _s,
      Float16BufferAttribute: D9,
      Float32BufferAttribute: ht,
      FloatType: kr,
      Fog: hx,
      FogExp2: fx,
      FramebufferTexture: Z9,
      FrontSide: Yo,
      Frustum: Xm,
      GLBufferAttribute: d8,
      GLSL1: JV,
      GLSL3: ZM,
      GreaterCompare: $F,
      GreaterDepth: By,
      GreaterEqualCompare: tN,
      GreaterEqualDepth: Py,
      GreaterEqualStencilFunc: UV,
      GreaterStencilFunc: NV,
      GridHelper: S8,
      Group: Sa,
      HalfFloatType: jh,
      HemisphereLight: UN,
      HemisphereLightHelper: A8,
      IcosahedronGeometry: Sx,
      ImageBitmapLoader: XN,
      ImageLoader: vm,
      ImageUtils: oN,
      IncrementStencilOp: CV,
      IncrementWrapStencilOp: RV,
      InstancedBufferAttribute: wc,
      InstancedBufferGeometry: VN,
      InstancedInterleavedBuffer: h8,
      InstancedMesh: xT,
      Int16BufferAttribute: B9,
      Int32BufferAttribute: I9,
      Int8BufferAttribute: b9,
      IntType: nx,
      InterleavedBuffer: Vm,
      InterleavedBufferAttribute: Hl,
      Interpolant: Qh,
      InterpolateDiscrete: Th,
      InterpolateLinear: Ch,
      InterpolateSmooth: Uv,
      InvertStencilOp: BV,
      KeepStencilOp: Iu,
      KeyframeTrack: wo,
      LOD: hN,
      LatheGeometry: jm,
      Layers: oc,
      LessCompare: ZF,
      LessDepth: by,
      LessEqualCompare: fT,
      LessEqualDepth: xc,
      LessEqualStencilFunc: FV,
      LessStencilFunc: DV,
      Light: ql,
      LightProbe: GN,
      Line: ka,
      Line3: g8,
      LineBasicMaterial: ir,
      LineCurve: TT,
      LineCurve3: vN,
      LineDashedMaterial: BN,
      LineLoop: AT,
      LineSegments: So,
      LinearFilter: Zn,
      LinearInterpolant: DT,
      LinearMipMapLinearFilter: AV,
      LinearMipMapNearestFilter: xV,
      LinearMipmapLinearFilter: Xs,
      LinearMipmapNearestFilter: ah,
      LinearSRGBColorSpace: Mc,
      LinearToneMapping: NF,
      LinearTransfer: um,
      Loader: rr,
      LoaderUtils: Il,
      LoadingManager: FT,
      LoopOnce: VF,
      LoopPingPong: XF,
      LoopRepeat: WF,
      LuminanceAlphaFormat: oT,
      LuminanceFormat: sT,
      MOUSE: Pu,
      Material: mi,
      MaterialLoader: Rx,
      MathUtils: iN,
      Matrix2: XT,
      Matrix3: It,
      Matrix4: _t,
      MaxEquation: xF,
      Mesh: qn,
      MeshBasicMaterial: hs,
      MeshDepthMaterial: PT,
      MeshDistanceMaterial: BT,
      MeshLambertMaterial: RN,
      MeshMatcapMaterial: PN,
      MeshNormalMaterial: bN,
      MeshPhongMaterial: TN,
      MeshPhysicalMaterial: eo,
      MeshStandardMaterial: Qm,
      MeshToonMaterial: CN,
      MinEquation: _F,
      MirroredRepeatWrapping: wh,
      MixOperation: LF,
      MultiplyBlending: YM,
      MultiplyOperation: Um,
      NearestFilter: bi,
      NearestMipMapLinearFilter: _V,
      NearestMipMapNearestFilter: yV,
      NearestMipmapLinearFilter: Wu,
      NearestMipmapNearestFilter: tx,
      NeutralToneMapping: HF,
      NeverCompare: QF,
      NeverDepth: Ty,
      NeverStencilFunc: IV,
      NoBlending: Ca,
      NoColorSpace: va,
      NoToneMapping: Vo,
      NormalAnimationBlendMode: lx,
      NormalBlending: nc,
      NotEqualCompare: eN,
      NotEqualDepth: Iy,
      NotEqualStencilFunc: OV,
      NumberKeyframeTrack: Tc,
      Object3D: qt,
      ObjectLoader: H5,
      ObjectSpaceNormalMap: KF,
      OctahedronGeometry: Ym,
      OneFactor: SF,
      OneMinusConstantAlphaFactor: DF,
      OneMinusConstantColorFactor: BF,
      OneMinusDstAlphaFactor: TF,
      OneMinusDstColorFactor: bF,
      OneMinusSrcAlphaFactor: Ey,
      OneMinusSrcColorFactor: wF,
      OrthographicCamera: yo,
      PCFShadowMap: $_,
      PCFSoftShadowMap: mp,
      PMREMGenerator: sw,
      Path: dm,
      PerspectiveCamera: bn,
      Plane: ma,
      PlaneGeometry: Kh,
      PlaneHelper: b8,
      PointLight: UT,
      PointLightHelper: _8,
      Points: ST,
      PointsMaterial: Jm,
      PolarGridHelper: M8,
      PolyhedronGeometry: Zl,
      PositionalAudio: Y5,
      PropertyBinding: $t,
      PropertyMixer: YN,
      QuadraticBezierCurve: CT,
      QuadraticBezierCurve3: bT,
      Quaternion: Ri,
      QuaternionKeyframeTrack: Cc,
      QuaternionLinearInterpolant: NN,
      RED_GREEN_RGTC2_Format: i_,
      RED_RGTC1_Format: lT,
      REVISION: Xh,
      RGBADepthPacking: YF,
      RGBAFormat: $i,
      RGBAIntegerFormat: ax,
      RGBA_ASTC_10x10_Format: Zy,
      RGBA_ASTC_10x5_Format: Yy,
      RGBA_ASTC_10x6_Format: Ky,
      RGBA_ASTC_10x8_Format: Qy,
      RGBA_ASTC_12x10_Format: qy,
      RGBA_ASTC_12x12_Format: $y,
      RGBA_ASTC_4x4_Format: zy,
      RGBA_ASTC_5x4_Format: Hy,
      RGBA_ASTC_5x5_Format: Gy,
      RGBA_ASTC_6x5_Format: Vy,
      RGBA_ASTC_6x6_Format: Wy,
      RGBA_ASTC_8x5_Format: Xy,
      RGBA_ASTC_8x6_Format: Jy,
      RGBA_ASTC_8x8_Format: jy,
      RGBA_BPTC_Format: xp,
      RGBA_ETC2_EAC_Format: ky,
      RGBA_PVRTC_2BPPV1_Format: Ny,
      RGBA_PVRTC_4BPPV1_Format: Fy,
      RGBA_S3TC_DXT1_Format: vp,
      RGBA_S3TC_DXT3_Format: yp,
      RGBA_S3TC_DXT5_Format: _p,
      RGBDepthPacking: MV,
      RGBFormat: rT,
      RGBIntegerFormat: SV,
      RGB_BPTC_SIGNED_Format: e_,
      RGB_BPTC_UNSIGNED_Format: t_,
      RGB_ETC1_Format: Oy,
      RGB_ETC2_Format: Uy,
      RGB_PVRTC_2BPPV1_Format: Ly,
      RGB_PVRTC_4BPPV1_Format: Dy,
      RGB_S3TC_DXT1_Format: gp,
      RGDepthPacking: wV,
      RGFormat: aT,
      RGIntegerFormat: ox,
      RawShaderMaterial: EN,
      Ray: Fc,
      Raycaster: QN,
      RectAreaLight: zN,
      RedFormat: sx,
      RedIntegerFormat: km,
      ReinhardToneMapping: OF,
      RenderTarget: ux,
      RenderTarget3D: l8,
      RenderTargetArray: u8,
      RepeatWrapping: zl,
      ReplaceStencilOp: TV,
      ReverseSubtractEquation: yF,
      RingGeometry: Mx,
      SIGNED_RED_GREEN_RGTC2_Format: r_,
      SIGNED_RED_RGTC1_Format: n_,
      SRGBColorSpace: Fr,
      SRGBTransfer: pn,
      Scene: vT,
      ShaderChunk: Nt,
      ShaderLib: ho,
      ShaderMaterial: Ao,
      ShadowMaterial: wN,
      Shape: ac,
      ShapeGeometry: wx,
      ShapePath: B8,
      ShapeUtils: Xo,
      ShortType: tT,
      Skeleton: Wm,
      SkeletonHelper: y8,
      SkinnedMesh: _T,
      Source: ju,
      Sphere: Ni,
      SphereGeometry: Km,
      Spherical: iw,
      SphericalHarmonics3: HN,
      SplineCurve: RT,
      SpotLight: OT,
      SpotLightHelper: v8,
      Sprite: fN,
      SpriteMaterial: yT,
      SrcAlphaFactor: wy,
      SrcAlphaSaturateFactor: RF,
      SrcColorFactor: MF,
      StaticCopyUsage: VV,
      StaticDrawUsage: cm,
      StaticReadUsage: zV,
      StereoCamera: W5,
      StreamCopyUsage: XV,
      StreamDrawUsage: kV,
      StreamReadUsage: GV,
      StringKeyframeTrack: Uc,
      SubtractEquation: vF,
      SubtractiveBlending: jM,
      TOUCH: Bu,
      TangentSpaceNormalMap: Ql,
      TetrahedronGeometry: Ex,
      Texture: Pn,
      TextureLoader: ON,
      TextureUtils: O8,
      TorusGeometry: Tx,
      TorusKnotGeometry: Cx,
      Triangle: Or,
      TriangleFanDrawMode: s_,
      TriangleStripDrawMode: cT,
      TrianglesDrawMode: JF,
      TubeGeometry: bx,
      UVMapping: ex,
      Uint16BufferAttribute: dT,
      Uint32BufferAttribute: pT,
      Uint8BufferAttribute: R9,
      Uint8ClampedBufferAttribute: P9,
      Uniform: WT,
      UniformsGroup: f8,
      UniformsLib: Qe,
      UniformsUtils: uN,
      UnsignedByteType: xo,
      UnsignedInt248Type: Ac,
      UnsignedInt5999Type: nT,
      UnsignedIntType: Ua,
      UnsignedShort4444Type: ix,
      UnsignedShort5551Type: rx,
      UnsignedShortType: Eh,
      VSMShadowMap: uo,
      Vector2: Ae,
      Vector3: z,
      Vector4: tn,
      VectorKeyframeTrack: bc,
      VideoTexture: Q9,
      WebGL3DRenderTarget: v9,
      WebGLArrayRenderTarget: g9,
      WebGLCoordinateSystem: po,
      WebGLCubeRenderTarget: gT,
      WebGLRenderTarget: Ko,
      WebGLRenderer: rO,
      WebGLUtils: iO,
      WebGPUCoordinateSystem: fm,
      WireframeGeometry: MN,
      WrapAroundEnding: lm,
      ZeroCurvatureEnding: Xu,
      ZeroFactor: AF,
      ZeroSlopeEnding: Ju,
      ZeroStencilOp: EV,
      createCanvasElement: sN,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var sO = { exports: {} },
  kc = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ kc.ConcurrentRoot = 1;
kc.ContinuousEventPriority = 4;
kc.DefaultEventPriority = 16;
kc.DiscreteEventPriority = 1;
kc.IdleEventPriority = 536870912;
kc.LegacyRoot = 0;
sO.exports = kc;
var Yf = sO.exports;
function _J(n) {
  let e;
  const t = new Set(),
    i = (u, c) => {
      const d = typeof u == "function" ? u(e) : u;
      if (d !== e) {
        const p = e;
        (e = c ? d : Object.assign({}, e, d)), t.forEach((m) => m(e, p));
      }
    },
    r = () => e,
    s = (u, c = r, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = c(e);
      function m() {
        const v = c(e);
        if (!d(p, v)) {
          const _ = p;
          u((p = v), _);
        }
      }
      return t.add(m), () => t.delete(m);
    },
    l = {
      setState: i,
      getState: r,
      subscribe: (u, c, d) =>
        c || d ? s(u, c, d) : (t.add(u), () => t.delete(u)),
      destroy: () => t.clear(),
    };
  return (e = n(i, r, l)), l;
}
const xJ =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  vB = xJ ? j.useEffect : j.useLayoutEffect;
function AJ(n) {
  const e = typeof n == "function" ? _J(n) : n,
    t = (i = e.getState, r = Object.is) => {
      const [, s] = j.useReducer((x) => x + 1, 0),
        o = e.getState(),
        a = j.useRef(o),
        l = j.useRef(i),
        u = j.useRef(r),
        c = j.useRef(!1),
        d = j.useRef();
      d.current === void 0 && (d.current = i(o));
      let p,
        m = !1;
      (a.current !== o || l.current !== i || u.current !== r || c.current) &&
        ((p = i(o)), (m = !r(d.current, p))),
        vB(() => {
          m && (d.current = p),
            (a.current = o),
            (l.current = i),
            (u.current = r),
            (c.current = !1);
        });
      const v = j.useRef(o);
      vB(() => {
        const x = () => {
            try {
              const A = e.getState(),
                S = l.current(A);
              u.current(d.current, S) ||
                ((a.current = A), (d.current = S), s());
            } catch {
              (c.current = !0), s();
            }
          },
          g = e.subscribe(x);
        return e.getState() !== v.current && x(), g;
      }, []);
      const _ = m ? p : d.current;
      return j.useDebugValue(_), _;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const i = [t, e];
      return {
        next() {
          const r = i.length <= 0;
          return { value: i.shift(), done: r };
        },
      };
    }),
    t
  );
}
const SJ = (n) => typeof n == "object" && typeof n.then == "function",
  Ku = [];
function oO(n, e, t = (i, r) => i === r) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const i = n.length;
  if (e.length !== i) return !1;
  for (let r = 0; r < i; r++) if (!t(n[r], e[r])) return !1;
  return !0;
}
function aO(n, e = null, t = !1, i = {}) {
  e === null && (e = [n]);
  for (const s of Ku)
    if (oO(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return (
          i.lifespan &&
            i.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, i.lifespan))),
          s.response
        );
      if (!t) throw s.promise;
    }
  const r = {
    keys: e,
    equal: i.equal,
    remove: () => {
      const s = Ku.indexOf(r);
      s !== -1 && Ku.splice(s, 1);
    },
    promise: (SJ(n) ? n : n(...e))
      .then((s) => {
        (r.response = s),
          i.lifespan &&
            i.lifespan > 0 &&
            (r.timeout = setTimeout(r.remove, i.lifespan));
      })
      .catch((s) => (r.error = s)),
  };
  if ((Ku.push(r), !t)) throw r.promise;
}
const MJ = (n, e, t) => aO(n, e, !1, t),
  wJ = (n, e, t) => void aO(n, e, !0, t),
  EJ = (n) => {
    if (n === void 0 || n.length === 0) Ku.splice(0, Ku.length);
    else {
      const e = Ku.find((t) => oO(n, t.keys, t.equal));
      e && e.remove();
    }
  };
var lO = { exports: {} },
  uO = { exports: {} },
  cO = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(O, Y) {
    var F = O.length;
    O.push(Y);
    e: for (; 0 < F; ) {
      var se = (F - 1) >>> 1,
        Me = O[se];
      if (0 < r(Me, Y)) (O[se] = Y), (O[F] = Me), (F = se);
      else break e;
    }
  }
  function t(O) {
    return O.length === 0 ? null : O[0];
  }
  function i(O) {
    if (O.length === 0) return null;
    var Y = O[0],
      F = O.pop();
    if (F !== Y) {
      O[0] = F;
      e: for (var se = 0, Me = O.length, De = Me >>> 1; se < De; ) {
        var re = 2 * (se + 1) - 1,
          xe = O[re],
          Ce = re + 1,
          Se = O[Ce];
        if (0 > r(xe, F))
          Ce < Me && 0 > r(Se, xe)
            ? ((O[se] = Se), (O[Ce] = F), (se = Ce))
            : ((O[se] = xe), (O[re] = F), (se = re));
        else if (Ce < Me && 0 > r(Se, F)) (O[se] = Se), (O[Ce] = F), (se = Ce);
        else break e;
      }
    }
    return Y;
  }
  function r(O, Y) {
    var F = O.sortIndex - Y.sortIndex;
    return F !== 0 ? F : O.id - Y.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    u = [],
    c = 1,
    d = null,
    p = 3,
    m = !1,
    v = !1,
    _ = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    A = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(O) {
    for (var Y = t(u); Y !== null; ) {
      if (Y.callback === null) i(u);
      else if (Y.startTime <= O)
        i(u), (Y.sortIndex = Y.expirationTime), e(l, Y);
      else break;
      Y = t(u);
    }
  }
  function w(O) {
    if (((_ = !1), S(O), !v))
      if (t(l) !== null) (v = !0), K(C);
      else {
        var Y = t(u);
        Y !== null && te(w, Y.startTime - O);
      }
  }
  function C(O, Y) {
    (v = !1), _ && ((_ = !1), g(I), (I = -1)), (m = !0);
    var F = p;
    try {
      for (
        S(Y), d = t(l);
        d !== null && (!(d.expirationTime > Y) || (O && !D()));

      ) {
        var se = d.callback;
        if (typeof se == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var Me = se(d.expirationTime <= Y);
          (Y = n.unstable_now()),
            typeof Me == "function" ? (d.callback = Me) : d === t(l) && i(l),
            S(Y);
        } else i(l);
        d = t(l);
      }
      if (d !== null) var De = !0;
      else {
        var re = t(u);
        re !== null && te(w, re.startTime - Y), (De = !1);
      }
      return De;
    } finally {
      (d = null), (p = F), (m = !1);
    }
  }
  var b = !1,
    P = null,
    I = -1,
    R = 5,
    T = -1;
  function D() {
    return !(n.unstable_now() - T < R);
  }
  function G() {
    if (P !== null) {
      var O = n.unstable_now();
      T = O;
      var Y = !0;
      try {
        Y = P(!0, O);
      } finally {
        Y ? W() : ((b = !1), (P = null));
      }
    } else b = !1;
  }
  var W;
  if (typeof A == "function")
    W = function () {
      A(G);
    };
  else if (typeof MessageChannel < "u") {
    var q = new MessageChannel(),
      Z = q.port2;
    (q.port1.onmessage = G),
      (W = function () {
        Z.postMessage(null);
      });
  } else
    W = function () {
      x(G, 0);
    };
  function K(O) {
    (P = O), b || ((b = !0), W());
  }
  function te(O, Y) {
    I = x(function () {
      O(n.unstable_now());
    }, Y);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (O) {
      O.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      v || m || ((v = !0), K(C));
    }),
    (n.unstable_forceFrameRate = function (O) {
      0 > O || 125 < O
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < O ? Math.floor(1e3 / O) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (O) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var Y = 3;
          break;
        default:
          Y = p;
      }
      var F = p;
      p = Y;
      try {
        return O();
      } finally {
        p = F;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (O, Y) {
      switch (O) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          O = 3;
      }
      var F = p;
      p = O;
      try {
        return Y();
      } finally {
        p = F;
      }
    }),
    (n.unstable_scheduleCallback = function (O, Y, F) {
      var se = n.unstable_now();
      switch (
        (typeof F == "object" && F !== null
          ? ((F = F.delay), (F = typeof F == "number" && 0 < F ? se + F : se))
          : (F = se),
        O)
      ) {
        case 1:
          var Me = -1;
          break;
        case 2:
          Me = 250;
          break;
        case 5:
          Me = 1073741823;
          break;
        case 4:
          Me = 1e4;
          break;
        default:
          Me = 5e3;
      }
      return (
        (Me = F + Me),
        (O = {
          id: c++,
          callback: Y,
          priorityLevel: O,
          startTime: F,
          expirationTime: Me,
          sortIndex: -1,
        }),
        F > se
          ? ((O.sortIndex = F),
            e(u, O),
            t(l) === null &&
              O === t(u) &&
              (_ ? (g(I), (I = -1)) : (_ = !0), te(w, F - se)))
          : ((O.sortIndex = Me), e(l, O), v || m || ((v = !0), K(C))),
        O
      );
    }),
    (n.unstable_shouldYield = D),
    (n.unstable_wrapCallback = function (O) {
      var Y = p;
      return function () {
        var F = p;
        p = Y;
        try {
          return O.apply(this, arguments);
        } finally {
          p = F;
        }
      };
    });
})(cO);
uO.exports = cO;
var aw = uO.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var TJ = function (e) {
  var t = {},
    i = j,
    r = aw,
    s = Object.assign;
  function o(f) {
    for (
      var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + f,
        y = 1;
      y < arguments.length;
      y++
    )
      h += "&args[]=" + encodeURIComponent(arguments[y]);
    return (
      "Minified React error #" +
      f +
      "; visit " +
      h +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    u = Symbol.for("react.portal"),
    c = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    v = Symbol.for("react.context"),
    _ = Symbol.for("react.forward_ref"),
    x = Symbol.for("react.suspense"),
    g = Symbol.for("react.suspense_list"),
    A = Symbol.for("react.memo"),
    S = Symbol.for("react.lazy"),
    w = Symbol.for("react.offscreen"),
    C = Symbol.iterator;
  function b(f) {
    return f === null || typeof f != "object"
      ? null
      : ((f = (C && f[C]) || f["@@iterator"]),
        typeof f == "function" ? f : null);
  }
  function P(f) {
    if (f == null) return null;
    if (typeof f == "function") return f.displayName || f.name || null;
    if (typeof f == "string") return f;
    switch (f) {
      case c:
        return "Fragment";
      case u:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case x:
        return "Suspense";
      case g:
        return "SuspenseList";
    }
    if (typeof f == "object")
      switch (f.$$typeof) {
        case v:
          return (f.displayName || "Context") + ".Consumer";
        case m:
          return (f._context.displayName || "Context") + ".Provider";
        case _:
          var h = f.render;
          return (
            (f = f.displayName),
            f ||
              ((f = h.displayName || h.name || ""),
              (f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef")),
            f
          );
        case A:
          return (
            (h = f.displayName || null), h !== null ? h : P(f.type) || "Memo"
          );
        case S:
          (h = f._payload), (f = f._init);
          try {
            return P(f(h));
          } catch {}
      }
    return null;
  }
  function I(f) {
    var h = f.type;
    switch (f.tag) {
      case 24:
        return "Cache";
      case 9:
        return (h.displayName || "Context") + ".Consumer";
      case 10:
        return (h._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (f = h.render),
          (f = f.displayName || f.name || ""),
          h.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return h;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return P(h);
      case 8:
        return h === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
    }
    return null;
  }
  function R(f) {
    var h = f,
      y = f;
    if (f.alternate) for (; h.return; ) h = h.return;
    else {
      f = h;
      do (h = f), h.flags & 4098 && (y = h.return), (f = h.return);
      while (f);
    }
    return h.tag === 3 ? y : null;
  }
  function T(f) {
    if (R(f) !== f) throw Error(o(188));
  }
  function D(f) {
    var h = f.alternate;
    if (!h) {
      if (((h = R(f)), h === null)) throw Error(o(188));
      return h !== f ? null : f;
    }
    for (var y = f, M = h; ; ) {
      var E = y.return;
      if (E === null) break;
      var B = E.alternate;
      if (B === null) {
        if (((M = E.return), M !== null)) {
          y = M;
          continue;
        }
        break;
      }
      if (E.child === B.child) {
        for (B = E.child; B; ) {
          if (B === y) return T(E), f;
          if (B === M) return T(E), h;
          B = B.sibling;
        }
        throw Error(o(188));
      }
      if (y.return !== M.return) (y = E), (M = B);
      else {
        for (var H = !1, ee = E.child; ee; ) {
          if (ee === y) {
            (H = !0), (y = E), (M = B);
            break;
          }
          if (ee === M) {
            (H = !0), (M = E), (y = B);
            break;
          }
          ee = ee.sibling;
        }
        if (!H) {
          for (ee = B.child; ee; ) {
            if (ee === y) {
              (H = !0), (y = B), (M = E);
              break;
            }
            if (ee === M) {
              (H = !0), (M = B), (y = E);
              break;
            }
            ee = ee.sibling;
          }
          if (!H) throw Error(o(189));
        }
      }
      if (y.alternate !== M) throw Error(o(190));
    }
    if (y.tag !== 3) throw Error(o(188));
    return y.stateNode.current === y ? f : h;
  }
  function G(f) {
    return (f = D(f)), f !== null ? W(f) : null;
  }
  function W(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      var h = W(f);
      if (h !== null) return h;
      f = f.sibling;
    }
    return null;
  }
  function q(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      if (f.tag !== 4) {
        var h = q(f);
        if (h !== null) return h;
      }
      f = f.sibling;
    }
    return null;
  }
  var Z = Array.isArray,
    K = e.getPublicInstance,
    te = e.getRootHostContext,
    O = e.getChildHostContext,
    Y = e.prepareForCommit,
    F = e.resetAfterCommit,
    se = e.createInstance,
    Me = e.appendInitialChild,
    De = e.finalizeInitialChildren,
    re = e.prepareUpdate,
    xe = e.shouldSetTextContent,
    Ce = e.createTextInstance,
    Se = e.scheduleTimeout,
    Xe = e.cancelTimeout,
    et = e.noTimeout,
    Ye = e.isPrimaryRenderer,
    Fe = e.supportsMutation,
    de = e.supportsPersistence,
    ce = e.supportsHydration,
    k = e.getInstanceFromNode,
    Ve = e.preparePortalMount,
    we = e.getCurrentEventPriority,
    J = e.detachDeletedInstance,
    Te = e.supportsMicrotasks,
    st = e.scheduleMicrotask,
    Le = e.supportsTestSelectors,
    U = e.findFiberRoot,
    L = e.getBoundingRect,
    ie = e.getTextContent,
    fe = e.isHiddenSubtree,
    ye = e.matchAccessibilityRole,
    me = e.setFocusIfFocusable,
    Pe = e.setupIntersectionObserver,
    Ie = e.appendChild,
    ze = e.appendChildToContainer,
    Mt = e.commitTextUpdate,
    Re = e.commitMount,
    Ne = e.commitUpdate,
    mt = e.insertBefore,
    dt = e.insertInContainerBefore,
    Ke = e.removeChild,
    X = e.removeChildFromContainer,
    pe = e.resetTextContent,
    He = e.hideInstance,
    V = e.hideTextInstance,
    be = e.unhideInstance,
    ue = e.unhideTextInstance,
    ge = e.clearContainer,
    Ue = e.cloneInstance,
    ke = e.createContainerChildSet,
    ft = e.appendChildToContainerChildSet,
    Ct = e.finalizeContainerChildren,
    cn = e.replaceContainerChildren,
    We = e.cloneHiddenInstance,
    nt = e.cloneHiddenTextInstance,
    Et = e.canHydrateInstance,
    je = e.canHydrateTextInstance,
    Tt = e.canHydrateSuspenseInstance,
    ut = e.isSuspenseInstancePending,
    St = e.isSuspenseInstanceFallback,
    Bn = e.registerSuspenseInstanceRetry,
    bt = e.getNextHydratableSibling,
    gn = e.getFirstHydratableChild,
    Wn = e.getFirstHydratableChildWithinContainer,
    hn = e.getFirstHydratableChildWithinSuspenseInstance,
    dn = e.hydrateInstance,
    sn = e.hydrateTextInstance,
    sr = e.hydrateSuspenseInstance,
    vn = e.getNextHydratableInstanceAfterSuspenseInstance,
    yi = e.commitHydratedContainer,
    Er = e.commitHydratedSuspenseInstance,
    Xn = e.clearSuspenseBoundary,
    Jn = e.clearSuspenseBoundaryFromContainer,
    N = e.shouldDeleteUnhydratedTailInstances,
    $ = e.didNotMatchHydratedContainerTextInstance,
    ae = e.didNotMatchHydratedTextInstance,
    oe;
  function Q(f) {
    if (oe === void 0)
      try {
        throw Error();
      } catch (y) {
        var h = y.stack.trim().match(/\n( *(at )?)/);
        oe = (h && h[1]) || "";
      }
    return (
      `
` +
      oe +
      f
    );
  }
  var Ee = !1;
  function Je(f, h) {
    if (!f || Ee) return "";
    Ee = !0;
    var y = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (h)
        if (
          ((h = function () {
            throw Error();
          }),
          Object.defineProperty(h.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(h, []);
          } catch (Oe) {
            var M = Oe;
          }
          Reflect.construct(f, [], h);
        } else {
          try {
            h.call();
          } catch (Oe) {
            M = Oe;
          }
          f.call(h.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Oe) {
          M = Oe;
        }
        f();
      }
    } catch (Oe) {
      if (Oe && M && typeof Oe.stack == "string") {
        for (
          var E = Oe.stack.split(`
`),
            B = M.stack.split(`
`),
            H = E.length - 1,
            ee = B.length - 1;
          1 <= H && 0 <= ee && E[H] !== B[ee];

        )
          ee--;
        for (; 1 <= H && 0 <= ee; H--, ee--)
          if (E[H] !== B[ee]) {
            if (H !== 1 || ee !== 1)
              do
                if ((H--, ee--, 0 > ee || E[H] !== B[ee])) {
                  var ve =
                    `
` + E[H].replace(" at new ", " at ");
                  return (
                    f.displayName &&
                      ve.includes("<anonymous>") &&
                      (ve = ve.replace("<anonymous>", f.displayName)),
                    ve
                  );
                }
              while (1 <= H && 0 <= ee);
            break;
          }
      }
    } finally {
      (Ee = !1), (Error.prepareStackTrace = y);
    }
    return (f = f ? f.displayName || f.name : "") ? Q(f) : "";
  }
  var it = Object.prototype.hasOwnProperty,
    $e = [],
    ct = -1;
  function pt(f) {
    return { current: f };
  }
  function Ge(f) {
    0 > ct || ((f.current = $e[ct]), ($e[ct] = null), ct--);
  }
  function rt(f, h) {
    ct++, ($e[ct] = f.current), (f.current = h);
  }
  var kt = {},
    Xt = pt(kt),
    Jt = pt(!1),
    Ot = kt;
  function gt(f, h) {
    var y = f.type.contextTypes;
    if (!y) return kt;
    var M = f.stateNode;
    if (M && M.__reactInternalMemoizedUnmaskedChildContext === h)
      return M.__reactInternalMemoizedMaskedChildContext;
    var E = {},
      B;
    for (B in y) E[B] = h[B];
    return (
      M &&
        ((f = f.stateNode),
        (f.__reactInternalMemoizedUnmaskedChildContext = h),
        (f.__reactInternalMemoizedMaskedChildContext = E)),
      E
    );
  }
  function on(f) {
    return (f = f.childContextTypes), f != null;
  }
  function Qt() {
    Ge(Jt), Ge(Xt);
  }
  function Tr(f, h, y) {
    if (Xt.current !== kt) throw Error(o(168));
    rt(Xt, h), rt(Jt, y);
  }
  function qo(f, h, y) {
    var M = f.stateNode;
    if (((h = h.childContextTypes), typeof M.getChildContext != "function"))
      return y;
    M = M.getChildContext();
    for (var E in M) if (!(E in h)) throw Error(o(108, I(f) || "Unknown", E));
    return s({}, y, M);
  }
  function _i(f) {
    return (
      (f =
        ((f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext) ||
        kt),
      (Ot = Xt.current),
      rt(Xt, f),
      rt(Jt, Jt.current),
      !0
    );
  }
  function Wa(f, h, y) {
    var M = f.stateNode;
    if (!M) throw Error(o(169));
    y
      ? ((f = qo(f, h, Ot)),
        (M.__reactInternalMemoizedMergedChildContext = f),
        Ge(Jt),
        Ge(Xt),
        rt(Xt, f))
      : Ge(Jt),
      rt(Jt, y);
  }
  var Kt = Math.clz32 ? Math.clz32 : Bi,
    Cr = Math.log,
    br = Math.LN2;
  function Bi(f) {
    return (f >>>= 0), f === 0 ? 32 : (31 - ((Cr(f) / br) | 0)) | 0;
  }
  var li = 64,
    Xa = 4194304;
  function Qr(f) {
    switch (f & -f) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return f & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return f;
    }
  }
  function ag(f, h) {
    var y = f.pendingLanes;
    if (y === 0) return 0;
    var M = 0,
      E = f.suspendedLanes,
      B = f.pingedLanes,
      H = y & 268435455;
    if (H !== 0) {
      var ee = H & ~E;
      ee !== 0 ? (M = Qr(ee)) : ((B &= H), B !== 0 && (M = Qr(B)));
    } else (H = y & ~E), H !== 0 ? (M = Qr(H)) : B !== 0 && (M = Qr(B));
    if (M === 0) return 0;
    if (
      h !== 0 &&
      h !== M &&
      !(h & E) &&
      ((E = M & -M), (B = h & -h), E >= B || (E === 16 && (B & 4194240) !== 0))
    )
      return h;
    if ((M & 4 && (M |= y & 16), (h = f.entangledLanes), h !== 0))
      for (f = f.entanglements, h &= M; 0 < h; )
        (y = 31 - Kt(h)), (E = 1 << y), (M |= f[y]), (h &= ~E);
    return M;
  }
  function Ez(f, h) {
    switch (f) {
      case 1:
      case 2:
      case 4:
        return h + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return h + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Tz(f, h) {
    for (
      var y = f.suspendedLanes,
        M = f.pingedLanes,
        E = f.expirationTimes,
        B = f.pendingLanes;
      0 < B;

    ) {
      var H = 31 - Kt(B),
        ee = 1 << H,
        ve = E[H];
      ve === -1
        ? (!(ee & y) || ee & M) && (E[H] = Ez(ee, h))
        : ve <= h && (f.expiredLanes |= ee),
        (B &= ~ee);
    }
  }
  function Wx(f) {
    return (
      (f = f.pendingLanes & -1073741825),
      f !== 0 ? f : f & 1073741824 ? 1073741824 : 0
    );
  }
  function Xx(f) {
    for (var h = [], y = 0; 31 > y; y++) h.push(f);
    return h;
  }
  function qh(f, h, y) {
    (f.pendingLanes |= h),
      h !== 536870912 && ((f.suspendedLanes = 0), (f.pingedLanes = 0)),
      (f = f.eventTimes),
      (h = 31 - Kt(h)),
      (f[h] = y);
  }
  function Cz(f, h) {
    var y = f.pendingLanes & ~h;
    (f.pendingLanes = h),
      (f.suspendedLanes = 0),
      (f.pingedLanes = 0),
      (f.expiredLanes &= h),
      (f.mutableReadLanes &= h),
      (f.entangledLanes &= h),
      (h = f.entanglements);
    var M = f.eventTimes;
    for (f = f.expirationTimes; 0 < y; ) {
      var E = 31 - Kt(y),
        B = 1 << E;
      (h[E] = 0), (M[E] = -1), (f[E] = -1), (y &= ~B);
    }
  }
  function Jx(f, h) {
    var y = (f.entangledLanes |= h);
    for (f = f.entanglements; y; ) {
      var M = 31 - Kt(y),
        E = 1 << M;
      (E & h) | (f[M] & h) && (f[M] |= h), (y &= ~E);
    }
  }
  var an = 0;
  function YC(f) {
    return (
      (f &= -f), 1 < f ? (4 < f ? (f & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var jx = r.unstable_scheduleCallback,
    KC = r.unstable_cancelCallback,
    bz = r.unstable_shouldYield,
    Rz = r.unstable_requestPaint,
    xi = r.unstable_now,
    Yx = r.unstable_ImmediatePriority,
    Pz = r.unstable_UserBlockingPriority,
    Kx = r.unstable_NormalPriority,
    Bz = r.unstable_IdlePriority,
    lg = null,
    Eo = null;
  function Iz(f) {
    if (Eo && typeof Eo.onCommitFiberRoot == "function")
      try {
        Eo.onCommitFiberRoot(lg, f, void 0, (f.current.flags & 128) === 128);
      } catch {}
  }
  function Dz(f, h) {
    return (f === h && (f !== 0 || 1 / f === 1 / h)) || (f !== f && h !== h);
  }
  var To = typeof Object.is == "function" ? Object.is : Dz,
    $o = null,
    ug = !1,
    Qx = !1;
  function QC(f) {
    $o === null ? ($o = [f]) : $o.push(f);
  }
  function Lz(f) {
    (ug = !0), QC(f);
  }
  function Co() {
    if (!Qx && $o !== null) {
      Qx = !0;
      var f = 0,
        h = an;
      try {
        var y = $o;
        for (an = 1; f < y.length; f++) {
          var M = y[f];
          do M = M(!0);
          while (M !== null);
        }
        ($o = null), (ug = !1);
      } catch (E) {
        throw ($o !== null && ($o = $o.slice(f + 1)), jx(Yx, Co), E);
      } finally {
        (an = h), (Qx = !1);
      }
    }
    return null;
  }
  var Fz = a.ReactCurrentBatchConfig;
  function cg(f, h) {
    if (To(f, h)) return !0;
    if (
      typeof f != "object" ||
      f === null ||
      typeof h != "object" ||
      h === null
    )
      return !1;
    var y = Object.keys(f),
      M = Object.keys(h);
    if (y.length !== M.length) return !1;
    for (M = 0; M < y.length; M++) {
      var E = y[M];
      if (!it.call(h, E) || !To(f[E], h[E])) return !1;
    }
    return !0;
  }
  function Nz(f) {
    switch (f.tag) {
      case 5:
        return Q(f.type);
      case 16:
        return Q("Lazy");
      case 13:
        return Q("Suspense");
      case 19:
        return Q("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (f = Je(f.type, !1)), f;
      case 11:
        return (f = Je(f.type.render, !1)), f;
      case 1:
        return (f = Je(f.type, !0)), f;
      default:
        return "";
    }
  }
  function to(f, h) {
    if (f && f.defaultProps) {
      (h = s({}, h)), (f = f.defaultProps);
      for (var y in f) h[y] === void 0 && (h[y] = f[y]);
      return h;
    }
    return h;
  }
  var fg = pt(null),
    hg = null,
    Wc = null,
    Zx = null;
  function qx() {
    Zx = Wc = hg = null;
  }
  function ZC(f, h, y) {
    Ye
      ? (rt(fg, h._currentValue), (h._currentValue = y))
      : (rt(fg, h._currentValue2), (h._currentValue2 = y));
  }
  function $x(f) {
    var h = fg.current;
    Ge(fg), Ye ? (f._currentValue = h) : (f._currentValue2 = h);
  }
  function eA(f, h, y) {
    for (; f !== null; ) {
      var M = f.alternate;
      if (
        ((f.childLanes & h) !== h
          ? ((f.childLanes |= h), M !== null && (M.childLanes |= h))
          : M !== null && (M.childLanes & h) !== h && (M.childLanes |= h),
        f === y)
      )
        break;
      f = f.return;
    }
  }
  function Xc(f, h) {
    (hg = f),
      (Zx = Wc = null),
      (f = f.dependencies),
      f !== null &&
        f.firstContext !== null &&
        (f.lanes & h && ($r = !0), (f.firstContext = null));
  }
  function Es(f) {
    var h = Ye ? f._currentValue : f._currentValue2;
    if (Zx !== f)
      if (((f = { context: f, memoizedValue: h, next: null }), Wc === null)) {
        if (hg === null) throw Error(o(308));
        (Wc = f), (hg.dependencies = { lanes: 0, firstContext: f });
      } else Wc = Wc.next = f;
    return h;
  }
  var bo = null,
    Ja = !1;
  function tA(f) {
    f.updateQueue = {
      baseState: f.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function qC(f, h) {
    (f = f.updateQueue),
      h.updateQueue === f &&
        (h.updateQueue = {
          baseState: f.baseState,
          firstBaseUpdate: f.firstBaseUpdate,
          lastBaseUpdate: f.lastBaseUpdate,
          shared: f.shared,
          effects: f.effects,
        });
  }
  function ea(f, h) {
    return {
      eventTime: f,
      lane: h,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function ja(f, h) {
    var y = f.updateQueue;
    y !== null &&
      ((y = y.shared),
      ei !== null && f.mode & 1 && !(zt & 2)
        ? ((f = y.interleaved),
          f === null
            ? ((h.next = h), bo === null ? (bo = [y]) : bo.push(y))
            : ((h.next = f.next), (f.next = h)),
          (y.interleaved = h))
        : ((f = y.pending),
          f === null ? (h.next = h) : ((h.next = f.next), (f.next = h)),
          (y.pending = h)));
  }
  function dg(f, h, y) {
    if (
      ((h = h.updateQueue), h !== null && ((h = h.shared), (y & 4194240) !== 0))
    ) {
      var M = h.lanes;
      (M &= f.pendingLanes), (y |= M), (h.lanes = y), Jx(f, y);
    }
  }
  function $C(f, h) {
    var y = f.updateQueue,
      M = f.alternate;
    if (M !== null && ((M = M.updateQueue), y === M)) {
      var E = null,
        B = null;
      if (((y = y.firstBaseUpdate), y !== null)) {
        do {
          var H = {
            eventTime: y.eventTime,
            lane: y.lane,
            tag: y.tag,
            payload: y.payload,
            callback: y.callback,
            next: null,
          };
          B === null ? (E = B = H) : (B = B.next = H), (y = y.next);
        } while (y !== null);
        B === null ? (E = B = h) : (B = B.next = h);
      } else E = B = h;
      (y = {
        baseState: M.baseState,
        firstBaseUpdate: E,
        lastBaseUpdate: B,
        shared: M.shared,
        effects: M.effects,
      }),
        (f.updateQueue = y);
      return;
    }
    (f = y.lastBaseUpdate),
      f === null ? (y.firstBaseUpdate = h) : (f.next = h),
      (y.lastBaseUpdate = h);
  }
  function pg(f, h, y, M) {
    var E = f.updateQueue;
    Ja = !1;
    var B = E.firstBaseUpdate,
      H = E.lastBaseUpdate,
      ee = E.shared.pending;
    if (ee !== null) {
      E.shared.pending = null;
      var ve = ee,
        Oe = ve.next;
      (ve.next = null), H === null ? (B = Oe) : (H.next = Oe), (H = ve);
      var at = f.alternate;
      at !== null &&
        ((at = at.updateQueue),
        (ee = at.lastBaseUpdate),
        ee !== H &&
          (ee === null ? (at.firstBaseUpdate = Oe) : (ee.next = Oe),
          (at.lastBaseUpdate = ve)));
    }
    if (B !== null) {
      var Pt = E.baseState;
      (H = 0), (at = Oe = ve = null), (ee = B);
      do {
        var xt = ee.lane,
          yn = ee.eventTime;
        if ((M & xt) === xt) {
          at !== null &&
            (at = at.next =
              {
                eventTime: yn,
                lane: 0,
                tag: ee.tag,
                payload: ee.payload,
                callback: ee.callback,
                next: null,
              });
          e: {
            var yt = f,
              Gi = ee;
            switch (((xt = h), (yn = y), Gi.tag)) {
              case 1:
                if (((yt = Gi.payload), typeof yt == "function")) {
                  Pt = yt.call(yn, Pt, xt);
                  break e;
                }
                Pt = yt;
                break e;
              case 3:
                yt.flags = (yt.flags & -65537) | 128;
              case 0:
                if (
                  ((yt = Gi.payload),
                  (xt = typeof yt == "function" ? yt.call(yn, Pt, xt) : yt),
                  xt == null)
                )
                  break e;
                Pt = s({}, Pt, xt);
                break e;
              case 2:
                Ja = !0;
            }
          }
          ee.callback !== null &&
            ee.lane !== 0 &&
            ((f.flags |= 64),
            (xt = E.effects),
            xt === null ? (E.effects = [ee]) : xt.push(ee));
        } else
          (yn = {
            eventTime: yn,
            lane: xt,
            tag: ee.tag,
            payload: ee.payload,
            callback: ee.callback,
            next: null,
          }),
            at === null ? ((Oe = at = yn), (ve = Pt)) : (at = at.next = yn),
            (H |= xt);
        if (((ee = ee.next), ee === null)) {
          if (((ee = E.shared.pending), ee === null)) break;
          (xt = ee),
            (ee = xt.next),
            (xt.next = null),
            (E.lastBaseUpdate = xt),
            (E.shared.pending = null);
        }
      } while (1);
      if (
        (at === null && (ve = Pt),
        (E.baseState = ve),
        (E.firstBaseUpdate = Oe),
        (E.lastBaseUpdate = at),
        (h = E.shared.interleaved),
        h !== null)
      ) {
        E = h;
        do (H |= E.lane), (E = E.next);
        while (E !== h);
      } else B === null && (E.shared.lanes = 0);
      (ef |= H), (f.lanes = H), (f.memoizedState = Pt);
    }
  }
  function eb(f, h, y) {
    if (((f = h.effects), (h.effects = null), f !== null))
      for (h = 0; h < f.length; h++) {
        var M = f[h],
          E = M.callback;
        if (E !== null) {
          if (((M.callback = null), (M = y), typeof E != "function"))
            throw Error(o(191, E));
          E.call(M);
        }
      }
  }
  var tb = new i.Component().refs;
  function nA(f, h, y, M) {
    (h = f.memoizedState),
      (y = y(M, h)),
      (y = y == null ? h : s({}, h, y)),
      (f.memoizedState = y),
      f.lanes === 0 && (f.updateQueue.baseState = y);
  }
  var mg = {
    isMounted: function (f) {
      return (f = f._reactInternals) ? R(f) === f : !1;
    },
    enqueueSetState: function (f, h, y) {
      f = f._reactInternals;
      var M = ar(),
        E = Qa(f),
        B = ea(M, E);
      (B.payload = h),
        y != null && (B.callback = y),
        ja(f, B),
        (h = Ps(f, E, M)),
        h !== null && dg(h, f, E);
    },
    enqueueReplaceState: function (f, h, y) {
      f = f._reactInternals;
      var M = ar(),
        E = Qa(f),
        B = ea(M, E);
      (B.tag = 1),
        (B.payload = h),
        y != null && (B.callback = y),
        ja(f, B),
        (h = Ps(f, E, M)),
        h !== null && dg(h, f, E);
    },
    enqueueForceUpdate: function (f, h) {
      f = f._reactInternals;
      var y = ar(),
        M = Qa(f),
        E = ea(y, M);
      (E.tag = 2),
        h != null && (E.callback = h),
        ja(f, E),
        (h = Ps(f, M, y)),
        h !== null && dg(h, f, M);
    },
  };
  function nb(f, h, y, M, E, B, H) {
    return (
      (f = f.stateNode),
      typeof f.shouldComponentUpdate == "function"
        ? f.shouldComponentUpdate(M, B, H)
        : h.prototype && h.prototype.isPureReactComponent
        ? !cg(y, M) || !cg(E, B)
        : !0
    );
  }
  function ib(f, h, y) {
    var M = !1,
      E = kt,
      B = h.contextType;
    return (
      typeof B == "object" && B !== null
        ? (B = Es(B))
        : ((E = on(h) ? Ot : Xt.current),
          (M = h.contextTypes),
          (B = (M = M != null) ? gt(f, E) : kt)),
      (h = new h(y, B)),
      (f.memoizedState =
        h.state !== null && h.state !== void 0 ? h.state : null),
      (h.updater = mg),
      (f.stateNode = h),
      (h._reactInternals = f),
      M &&
        ((f = f.stateNode),
        (f.__reactInternalMemoizedUnmaskedChildContext = E),
        (f.__reactInternalMemoizedMaskedChildContext = B)),
      h
    );
  }
  function rb(f, h, y, M) {
    (f = h.state),
      typeof h.componentWillReceiveProps == "function" &&
        h.componentWillReceiveProps(y, M),
      typeof h.UNSAFE_componentWillReceiveProps == "function" &&
        h.UNSAFE_componentWillReceiveProps(y, M),
      h.state !== f && mg.enqueueReplaceState(h, h.state, null);
  }
  function iA(f, h, y, M) {
    var E = f.stateNode;
    (E.props = y), (E.state = f.memoizedState), (E.refs = tb), tA(f);
    var B = h.contextType;
    typeof B == "object" && B !== null
      ? (E.context = Es(B))
      : ((B = on(h) ? Ot : Xt.current), (E.context = gt(f, B))),
      (E.state = f.memoizedState),
      (B = h.getDerivedStateFromProps),
      typeof B == "function" && (nA(f, h, B, y), (E.state = f.memoizedState)),
      typeof h.getDerivedStateFromProps == "function" ||
        typeof E.getSnapshotBeforeUpdate == "function" ||
        (typeof E.UNSAFE_componentWillMount != "function" &&
          typeof E.componentWillMount != "function") ||
        ((h = E.state),
        typeof E.componentWillMount == "function" && E.componentWillMount(),
        typeof E.UNSAFE_componentWillMount == "function" &&
          E.UNSAFE_componentWillMount(),
        h !== E.state && mg.enqueueReplaceState(E, E.state, null),
        pg(f, y, E, M),
        (E.state = f.memoizedState)),
      typeof E.componentDidMount == "function" && (f.flags |= 4194308);
  }
  var Jc = [],
    jc = 0,
    gg = null,
    vg = 0,
    Ts = [],
    Cs = 0,
    tu = null,
    ta = 1,
    na = "";
  function nu(f, h) {
    (Jc[jc++] = vg), (Jc[jc++] = gg), (gg = f), (vg = h);
  }
  function sb(f, h, y) {
    (Ts[Cs++] = ta), (Ts[Cs++] = na), (Ts[Cs++] = tu), (tu = f);
    var M = ta;
    f = na;
    var E = 32 - Kt(M) - 1;
    (M &= ~(1 << E)), (y += 1);
    var B = 32 - Kt(h) + E;
    if (30 < B) {
      var H = E - (E % 5);
      (B = (M & ((1 << H) - 1)).toString(32)),
        (M >>= H),
        (E -= H),
        (ta = (1 << (32 - Kt(h) + E)) | (y << E) | M),
        (na = B + f);
    } else (ta = (1 << B) | (y << E) | M), (na = f);
  }
  function rA(f) {
    f.return !== null && (nu(f, 1), sb(f, 1, 0));
  }
  function sA(f) {
    for (; f === gg; )
      (gg = Jc[--jc]), (Jc[jc] = null), (vg = Jc[--jc]), (Jc[jc] = null);
    for (; f === tu; )
      (tu = Ts[--Cs]),
        (Ts[Cs] = null),
        (na = Ts[--Cs]),
        (Ts[Cs] = null),
        (ta = Ts[--Cs]),
        (Ts[Cs] = null);
  }
  var Zr = null,
    qr = null,
    Tn = !1,
    $h = !1,
    no = null;
  function ob(f, h) {
    var y = Bs(5, null, null, 0);
    (y.elementType = "DELETED"),
      (y.stateNode = h),
      (y.return = f),
      (h = f.deletions),
      h === null ? ((f.deletions = [y]), (f.flags |= 16)) : h.push(y);
  }
  function ab(f, h) {
    switch (f.tag) {
      case 5:
        return (
          (h = Et(h, f.type, f.pendingProps)),
          h !== null ? ((f.stateNode = h), (Zr = f), (qr = gn(h)), !0) : !1
        );
      case 6:
        return (
          (h = je(h, f.pendingProps)),
          h !== null ? ((f.stateNode = h), (Zr = f), (qr = null), !0) : !1
        );
      case 13:
        if (((h = Tt(h)), h !== null)) {
          var y = tu !== null ? { id: ta, overflow: na } : null;
          return (
            (f.memoizedState = {
              dehydrated: h,
              treeContext: y,
              retryLane: 1073741824,
            }),
            (y = Bs(18, null, null, 0)),
            (y.stateNode = h),
            (y.return = f),
            (f.child = y),
            (Zr = f),
            (qr = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function oA(f) {
    return (f.mode & 1) !== 0 && (f.flags & 128) === 0;
  }
  function aA(f) {
    if (Tn) {
      var h = qr;
      if (h) {
        var y = h;
        if (!ab(f, h)) {
          if (oA(f)) throw Error(o(418));
          h = bt(y);
          var M = Zr;
          h && ab(f, h)
            ? ob(M, y)
            : ((f.flags = (f.flags & -4097) | 2), (Tn = !1), (Zr = f));
        }
      } else {
        if (oA(f)) throw Error(o(418));
        (f.flags = (f.flags & -4097) | 2), (Tn = !1), (Zr = f);
      }
    }
  }
  function lb(f) {
    for (
      f = f.return;
      f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13;

    )
      f = f.return;
    Zr = f;
  }
  function ed(f) {
    if (!ce || f !== Zr) return !1;
    if (!Tn) return lb(f), (Tn = !0), !1;
    if (
      f.tag !== 3 &&
      (f.tag !== 5 || (N(f.type) && !xe(f.type, f.memoizedProps)))
    ) {
      var h = qr;
      if (h) {
        if (oA(f)) {
          for (f = qr; f; ) f = bt(f);
          throw Error(o(418));
        }
        for (; h; ) ob(f, h), (h = bt(h));
      }
    }
    if ((lb(f), f.tag === 13)) {
      if (!ce) throw Error(o(316));
      if (((f = f.memoizedState), (f = f !== null ? f.dehydrated : null), !f))
        throw Error(o(317));
      qr = vn(f);
    } else qr = Zr ? bt(f.stateNode) : null;
    return !0;
  }
  function Yc() {
    ce && ((qr = Zr = null), ($h = Tn = !1));
  }
  function lA(f) {
    no === null ? (no = [f]) : no.push(f);
  }
  function td(f, h, y) {
    if (
      ((f = y.ref),
      f !== null && typeof f != "function" && typeof f != "object")
    ) {
      if (y._owner) {
        if (((y = y._owner), y)) {
          if (y.tag !== 1) throw Error(o(309));
          var M = y.stateNode;
        }
        if (!M) throw Error(o(147, f));
        var E = M,
          B = "" + f;
        return h !== null &&
          h.ref !== null &&
          typeof h.ref == "function" &&
          h.ref._stringRef === B
          ? h.ref
          : ((h = function (H) {
              var ee = E.refs;
              ee === tb && (ee = E.refs = {}),
                H === null ? delete ee[B] : (ee[B] = H);
            }),
            (h._stringRef = B),
            h);
      }
      if (typeof f != "string") throw Error(o(284));
      if (!y._owner) throw Error(o(290, f));
    }
    return f;
  }
  function yg(f, h) {
    throw (
      ((f = Object.prototype.toString.call(h)),
      Error(
        o(
          31,
          f === "[object Object]"
            ? "object with keys {" + Object.keys(h).join(", ") + "}"
            : f
        )
      ))
    );
  }
  function ub(f) {
    var h = f._init;
    return h(f._payload);
  }
  function cb(f) {
    function h(le, ne) {
      if (f) {
        var he = le.deletions;
        he === null ? ((le.deletions = [ne]), (le.flags |= 16)) : he.push(ne);
      }
    }
    function y(le, ne) {
      if (!f) return null;
      for (; ne !== null; ) h(le, ne), (ne = ne.sibling);
      return null;
    }
    function M(le, ne) {
      for (le = new Map(); ne !== null; )
        ne.key !== null ? le.set(ne.key, ne) : le.set(ne.index, ne),
          (ne = ne.sibling);
      return le;
    }
    function E(le, ne) {
      return (le = qa(le, ne)), (le.index = 0), (le.sibling = null), le;
    }
    function B(le, ne, he) {
      return (
        (le.index = he),
        f
          ? ((he = le.alternate),
            he !== null
              ? ((he = he.index), he < ne ? ((le.flags |= 2), ne) : he)
              : ((le.flags |= 2), ne))
          : ((le.flags |= 1048576), ne)
      );
    }
    function H(le) {
      return f && le.alternate === null && (le.flags |= 2), le;
    }
    function ee(le, ne, he, tt) {
      return ne === null || ne.tag !== 6
        ? ((ne = XA(he, le.mode, tt)), (ne.return = le), ne)
        : ((ne = E(ne, he)), (ne.return = le), ne);
    }
    function ve(le, ne, he, tt) {
      var vt = he.type;
      return vt === c
        ? at(le, ne, he.props.children, tt, he.key)
        : ne !== null &&
          (ne.elementType === vt ||
            (typeof vt == "object" &&
              vt !== null &&
              vt.$$typeof === S &&
              ub(vt) === ne.type))
        ? ((tt = E(ne, he.props)),
          (tt.ref = td(le, ne, he)),
          (tt.return = le),
          tt)
        : ((tt = Kg(he.type, he.key, he.props, null, le.mode, tt)),
          (tt.ref = td(le, ne, he)),
          (tt.return = le),
          tt);
    }
    function Oe(le, ne, he, tt) {
      return ne === null ||
        ne.tag !== 4 ||
        ne.stateNode.containerInfo !== he.containerInfo ||
        ne.stateNode.implementation !== he.implementation
        ? ((ne = JA(he, le.mode, tt)), (ne.return = le), ne)
        : ((ne = E(ne, he.children || [])), (ne.return = le), ne);
    }
    function at(le, ne, he, tt, vt) {
      return ne === null || ne.tag !== 7
        ? ((ne = uu(he, le.mode, tt, vt)), (ne.return = le), ne)
        : ((ne = E(ne, he)), (ne.return = le), ne);
    }
    function Pt(le, ne, he) {
      if ((typeof ne == "string" && ne !== "") || typeof ne == "number")
        return (ne = XA("" + ne, le.mode, he)), (ne.return = le), ne;
      if (typeof ne == "object" && ne !== null) {
        switch (ne.$$typeof) {
          case l:
            return (
              (he = Kg(ne.type, ne.key, ne.props, null, le.mode, he)),
              (he.ref = td(le, null, ne)),
              (he.return = le),
              he
            );
          case u:
            return (ne = JA(ne, le.mode, he)), (ne.return = le), ne;
          case S:
            var tt = ne._init;
            return Pt(le, tt(ne._payload), he);
        }
        if (Z(ne) || b(ne))
          return (ne = uu(ne, le.mode, he, null)), (ne.return = le), ne;
        yg(le, ne);
      }
      return null;
    }
    function xt(le, ne, he, tt) {
      var vt = ne !== null ? ne.key : null;
      if ((typeof he == "string" && he !== "") || typeof he == "number")
        return vt !== null ? null : ee(le, ne, "" + he, tt);
      if (typeof he == "object" && he !== null) {
        switch (he.$$typeof) {
          case l:
            return he.key === vt ? ve(le, ne, he, tt) : null;
          case u:
            return he.key === vt ? Oe(le, ne, he, tt) : null;
          case S:
            return (vt = he._init), xt(le, ne, vt(he._payload), tt);
        }
        if (Z(he) || b(he))
          return vt !== null ? null : at(le, ne, he, tt, null);
        yg(le, he);
      }
      return null;
    }
    function yn(le, ne, he, tt, vt) {
      if ((typeof tt == "string" && tt !== "") || typeof tt == "number")
        return (le = le.get(he) || null), ee(ne, le, "" + tt, vt);
      if (typeof tt == "object" && tt !== null) {
        switch (tt.$$typeof) {
          case l:
            return (
              (le = le.get(tt.key === null ? he : tt.key) || null),
              ve(ne, le, tt, vt)
            );
          case u:
            return (
              (le = le.get(tt.key === null ? he : tt.key) || null),
              Oe(ne, le, tt, vt)
            );
          case S:
            var Ut = tt._init;
            return yn(le, ne, he, Ut(tt._payload), vt);
        }
        if (Z(tt) || b(tt))
          return (le = le.get(he) || null), at(ne, le, tt, vt, null);
        yg(ne, tt);
      }
      return null;
    }
    function yt(le, ne, he, tt) {
      for (
        var vt = null, Ut = null, Bt = ne, ln = (ne = 0), Si = null;
        Bt !== null && ln < he.length;
        ln++
      ) {
        Bt.index > ln ? ((Si = Bt), (Bt = null)) : (Si = Bt.sibling);
        var un = xt(le, Bt, he[ln], tt);
        if (un === null) {
          Bt === null && (Bt = Si);
          break;
        }
        f && Bt && un.alternate === null && h(le, Bt),
          (ne = B(un, ne, ln)),
          Ut === null ? (vt = un) : (Ut.sibling = un),
          (Ut = un),
          (Bt = Si);
      }
      if (ln === he.length) return y(le, Bt), Tn && nu(le, ln), vt;
      if (Bt === null) {
        for (; ln < he.length; ln++)
          (Bt = Pt(le, he[ln], tt)),
            Bt !== null &&
              ((ne = B(Bt, ne, ln)),
              Ut === null ? (vt = Bt) : (Ut.sibling = Bt),
              (Ut = Bt));
        return Tn && nu(le, ln), vt;
      }
      for (Bt = M(le, Bt); ln < he.length; ln++)
        (Si = yn(Bt, le, ln, he[ln], tt)),
          Si !== null &&
            (f &&
              Si.alternate !== null &&
              Bt.delete(Si.key === null ? ln : Si.key),
            (ne = B(Si, ne, ln)),
            Ut === null ? (vt = Si) : (Ut.sibling = Si),
            (Ut = Si));
      return (
        f &&
          Bt.forEach(function ($a) {
            return h(le, $a);
          }),
        Tn && nu(le, ln),
        vt
      );
    }
    function Gi(le, ne, he, tt) {
      var vt = b(he);
      if (typeof vt != "function") throw Error(o(150));
      if (((he = vt.call(he)), he == null)) throw Error(o(151));
      for (
        var Ut = (vt = null), Bt = ne, ln = (ne = 0), Si = null, un = he.next();
        Bt !== null && !un.done;
        ln++, un = he.next()
      ) {
        Bt.index > ln ? ((Si = Bt), (Bt = null)) : (Si = Bt.sibling);
        var $a = xt(le, Bt, un.value, tt);
        if ($a === null) {
          Bt === null && (Bt = Si);
          break;
        }
        f && Bt && $a.alternate === null && h(le, Bt),
          (ne = B($a, ne, ln)),
          Ut === null ? (vt = $a) : (Ut.sibling = $a),
          (Ut = $a),
          (Bt = Si);
      }
      if (un.done) return y(le, Bt), Tn && nu(le, ln), vt;
      if (Bt === null) {
        for (; !un.done; ln++, un = he.next())
          (un = Pt(le, un.value, tt)),
            un !== null &&
              ((ne = B(un, ne, ln)),
              Ut === null ? (vt = un) : (Ut.sibling = un),
              (Ut = un));
        return Tn && nu(le, ln), vt;
      }
      for (Bt = M(le, Bt); !un.done; ln++, un = he.next())
        (un = yn(Bt, le, ln, un.value, tt)),
          un !== null &&
            (f &&
              un.alternate !== null &&
              Bt.delete(un.key === null ? ln : un.key),
            (ne = B(un, ne, ln)),
            Ut === null ? (vt = un) : (Ut.sibling = un),
            (Ut = un));
      return (
        f &&
          Bt.forEach(function (h4) {
            return h(le, h4);
          }),
        Tn && nu(le, ln),
        vt
      );
    }
    function Is(le, ne, he, tt) {
      if (
        (typeof he == "object" &&
          he !== null &&
          he.type === c &&
          he.key === null &&
          (he = he.props.children),
        typeof he == "object" && he !== null)
      ) {
        switch (he.$$typeof) {
          case l:
            e: {
              for (var vt = he.key, Ut = ne; Ut !== null; ) {
                if (Ut.key === vt) {
                  if (((vt = he.type), vt === c)) {
                    if (Ut.tag === 7) {
                      y(le, Ut.sibling),
                        (ne = E(Ut, he.props.children)),
                        (ne.return = le),
                        (le = ne);
                      break e;
                    }
                  } else if (
                    Ut.elementType === vt ||
                    (typeof vt == "object" &&
                      vt !== null &&
                      vt.$$typeof === S &&
                      ub(vt) === Ut.type)
                  ) {
                    y(le, Ut.sibling),
                      (ne = E(Ut, he.props)),
                      (ne.ref = td(le, Ut, he)),
                      (ne.return = le),
                      (le = ne);
                    break e;
                  }
                  y(le, Ut);
                  break;
                } else h(le, Ut);
                Ut = Ut.sibling;
              }
              he.type === c
                ? ((ne = uu(he.props.children, le.mode, tt, he.key)),
                  (ne.return = le),
                  (le = ne))
                : ((tt = Kg(he.type, he.key, he.props, null, le.mode, tt)),
                  (tt.ref = td(le, ne, he)),
                  (tt.return = le),
                  (le = tt));
            }
            return H(le);
          case u:
            e: {
              for (Ut = he.key; ne !== null; ) {
                if (ne.key === Ut)
                  if (
                    ne.tag === 4 &&
                    ne.stateNode.containerInfo === he.containerInfo &&
                    ne.stateNode.implementation === he.implementation
                  ) {
                    y(le, ne.sibling),
                      (ne = E(ne, he.children || [])),
                      (ne.return = le),
                      (le = ne);
                    break e;
                  } else {
                    y(le, ne);
                    break;
                  }
                else h(le, ne);
                ne = ne.sibling;
              }
              (ne = JA(he, le.mode, tt)), (ne.return = le), (le = ne);
            }
            return H(le);
          case S:
            return (Ut = he._init), Is(le, ne, Ut(he._payload), tt);
        }
        if (Z(he)) return yt(le, ne, he, tt);
        if (b(he)) return Gi(le, ne, he, tt);
        yg(le, he);
      }
      return (typeof he == "string" && he !== "") || typeof he == "number"
        ? ((he = "" + he),
          ne !== null && ne.tag === 6
            ? (y(le, ne.sibling), (ne = E(ne, he)), (ne.return = le), (le = ne))
            : (y(le, ne),
              (ne = XA(he, le.mode, tt)),
              (ne.return = le),
              (le = ne)),
          H(le))
        : y(le, ne);
    }
    return Is;
  }
  var Kc = cb(!0),
    fb = cb(!1),
    nd = {},
    bs = pt(nd),
    id = pt(nd),
    Qc = pt(nd);
  function Ro(f) {
    if (f === nd) throw Error(o(174));
    return f;
  }
  function uA(f, h) {
    rt(Qc, h), rt(id, f), rt(bs, nd), (f = te(h)), Ge(bs), rt(bs, f);
  }
  function Zc() {
    Ge(bs), Ge(id), Ge(Qc);
  }
  function hb(f) {
    var h = Ro(Qc.current),
      y = Ro(bs.current);
    (h = O(y, f.type, h)), y !== h && (rt(id, f), rt(bs, h));
  }
  function cA(f) {
    id.current === f && (Ge(bs), Ge(id));
  }
  var In = pt(0);
  function _g(f) {
    for (var h = f; h !== null; ) {
      if (h.tag === 13) {
        var y = h.memoizedState;
        if (y !== null && ((y = y.dehydrated), y === null || ut(y) || St(y)))
          return h;
      } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
        if (h.flags & 128) return h;
      } else if (h.child !== null) {
        (h.child.return = h), (h = h.child);
        continue;
      }
      if (h === f) break;
      for (; h.sibling === null; ) {
        if (h.return === null || h.return === f) return null;
        h = h.return;
      }
      (h.sibling.return = h.return), (h = h.sibling);
    }
    return null;
  }
  var fA = [];
  function hA() {
    for (var f = 0; f < fA.length; f++) {
      var h = fA[f];
      Ye
        ? (h._workInProgressVersionPrimary = null)
        : (h._workInProgressVersionSecondary = null);
    }
    fA.length = 0;
  }
  var xg = a.ReactCurrentDispatcher,
    Rs = a.ReactCurrentBatchConfig,
    qc = 0,
    zn = null,
    ki = null,
    Ai = null,
    Ag = !1,
    rd = !1,
    sd = 0,
    Oz = 0;
  function zi() {
    throw Error(o(321));
  }
  function dA(f, h) {
    if (h === null) return !1;
    for (var y = 0; y < h.length && y < f.length; y++)
      if (!To(f[y], h[y])) return !1;
    return !0;
  }
  function pA(f, h, y, M, E, B) {
    if (
      ((qc = B),
      (zn = h),
      (h.memoizedState = null),
      (h.updateQueue = null),
      (h.lanes = 0),
      (xg.current = f === null || f.memoizedState === null ? Hz : Gz),
      (f = y(M, E)),
      rd)
    ) {
      B = 0;
      do {
        if (((rd = !1), (sd = 0), 25 <= B)) throw Error(o(301));
        (B += 1),
          (Ai = ki = null),
          (h.updateQueue = null),
          (xg.current = Vz),
          (f = y(M, E));
      } while (rd);
    }
    if (
      ((xg.current = Tg),
      (h = ki !== null && ki.next !== null),
      (qc = 0),
      (Ai = ki = zn = null),
      (Ag = !1),
      h)
    )
      throw Error(o(300));
    return f;
  }
  function mA() {
    var f = sd !== 0;
    return (sd = 0), f;
  }
  function ia() {
    var f = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Ai === null ? (zn.memoizedState = Ai = f) : (Ai = Ai.next = f), Ai;
  }
  function Po() {
    if (ki === null) {
      var f = zn.alternate;
      f = f !== null ? f.memoizedState : null;
    } else f = ki.next;
    var h = Ai === null ? zn.memoizedState : Ai.next;
    if (h !== null) (Ai = h), (ki = f);
    else {
      if (f === null) throw Error(o(310));
      (ki = f),
        (f = {
          memoizedState: ki.memoizedState,
          baseState: ki.baseState,
          baseQueue: ki.baseQueue,
          queue: ki.queue,
          next: null,
        }),
        Ai === null ? (zn.memoizedState = Ai = f) : (Ai = Ai.next = f);
    }
    return Ai;
  }
  function iu(f, h) {
    return typeof h == "function" ? h(f) : h;
  }
  function Sg(f) {
    var h = Po(),
      y = h.queue;
    if (y === null) throw Error(o(311));
    y.lastRenderedReducer = f;
    var M = ki,
      E = M.baseQueue,
      B = y.pending;
    if (B !== null) {
      if (E !== null) {
        var H = E.next;
        (E.next = B.next), (B.next = H);
      }
      (M.baseQueue = E = B), (y.pending = null);
    }
    if (E !== null) {
      (B = E.next), (M = M.baseState);
      var ee = (H = null),
        ve = null,
        Oe = B;
      do {
        var at = Oe.lane;
        if ((qc & at) === at)
          ve !== null &&
            (ve = ve.next =
              {
                lane: 0,
                action: Oe.action,
                hasEagerState: Oe.hasEagerState,
                eagerState: Oe.eagerState,
                next: null,
              }),
            (M = Oe.hasEagerState ? Oe.eagerState : f(M, Oe.action));
        else {
          var Pt = {
            lane: at,
            action: Oe.action,
            hasEagerState: Oe.hasEagerState,
            eagerState: Oe.eagerState,
            next: null,
          };
          ve === null ? ((ee = ve = Pt), (H = M)) : (ve = ve.next = Pt),
            (zn.lanes |= at),
            (ef |= at);
        }
        Oe = Oe.next;
      } while (Oe !== null && Oe !== B);
      ve === null ? (H = M) : (ve.next = ee),
        To(M, h.memoizedState) || ($r = !0),
        (h.memoizedState = M),
        (h.baseState = H),
        (h.baseQueue = ve),
        (y.lastRenderedState = M);
    }
    if (((f = y.interleaved), f !== null)) {
      E = f;
      do (B = E.lane), (zn.lanes |= B), (ef |= B), (E = E.next);
      while (E !== f);
    } else E === null && (y.lanes = 0);
    return [h.memoizedState, y.dispatch];
  }
  function Mg(f) {
    var h = Po(),
      y = h.queue;
    if (y === null) throw Error(o(311));
    y.lastRenderedReducer = f;
    var M = y.dispatch,
      E = y.pending,
      B = h.memoizedState;
    if (E !== null) {
      y.pending = null;
      var H = (E = E.next);
      do (B = f(B, H.action)), (H = H.next);
      while (H !== E);
      To(B, h.memoizedState) || ($r = !0),
        (h.memoizedState = B),
        h.baseQueue === null && (h.baseState = B),
        (y.lastRenderedState = B);
    }
    return [B, M];
  }
  function db() {}
  function pb(f, h) {
    var y = zn,
      M = Po(),
      E = h(),
      B = !To(M.memoizedState, E);
    if (
      (B && ((M.memoizedState = E), ($r = !0)),
      (M = M.queue),
      ad(vb.bind(null, y, M, f), [f]),
      M.getSnapshot !== h || B || (Ai !== null && Ai.memoizedState.tag & 1))
    ) {
      if (
        ((y.flags |= 2048),
        od(9, gb.bind(null, y, M, E, h), void 0, null),
        ei === null)
      )
        throw Error(o(349));
      qc & 30 || mb(y, h, E);
    }
    return E;
  }
  function mb(f, h, y) {
    (f.flags |= 16384),
      (f = { getSnapshot: h, value: y }),
      (h = zn.updateQueue),
      h === null
        ? ((h = { lastEffect: null, stores: null }),
          (zn.updateQueue = h),
          (h.stores = [f]))
        : ((y = h.stores), y === null ? (h.stores = [f]) : y.push(f));
  }
  function gb(f, h, y, M) {
    (h.value = y), (h.getSnapshot = M), yb(h) && Ps(f, 1, -1);
  }
  function vb(f, h, y) {
    return y(function () {
      yb(h) && Ps(f, 1, -1);
    });
  }
  function yb(f) {
    var h = f.getSnapshot;
    f = f.value;
    try {
      var y = h();
      return !To(f, y);
    } catch {
      return !0;
    }
  }
  function gA(f) {
    var h = ia();
    return (
      typeof f == "function" && (f = f()),
      (h.memoizedState = h.baseState = f),
      (f = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: iu,
        lastRenderedState: f,
      }),
      (h.queue = f),
      (f = f.dispatch = zz.bind(null, zn, f)),
      [h.memoizedState, f]
    );
  }
  function od(f, h, y, M) {
    return (
      (f = { tag: f, create: h, destroy: y, deps: M, next: null }),
      (h = zn.updateQueue),
      h === null
        ? ((h = { lastEffect: null, stores: null }),
          (zn.updateQueue = h),
          (h.lastEffect = f.next = f))
        : ((y = h.lastEffect),
          y === null
            ? (h.lastEffect = f.next = f)
            : ((M = y.next), (y.next = f), (f.next = M), (h.lastEffect = f))),
      f
    );
  }
  function _b() {
    return Po().memoizedState;
  }
  function wg(f, h, y, M) {
    var E = ia();
    (zn.flags |= f),
      (E.memoizedState = od(1 | h, y, void 0, M === void 0 ? null : M));
  }
  function Eg(f, h, y, M) {
    var E = Po();
    M = M === void 0 ? null : M;
    var B = void 0;
    if (ki !== null) {
      var H = ki.memoizedState;
      if (((B = H.destroy), M !== null && dA(M, H.deps))) {
        E.memoizedState = od(h, y, B, M);
        return;
      }
    }
    (zn.flags |= f), (E.memoizedState = od(1 | h, y, B, M));
  }
  function vA(f, h) {
    return wg(8390656, 8, f, h);
  }
  function ad(f, h) {
    return Eg(2048, 8, f, h);
  }
  function xb(f, h) {
    return Eg(4, 2, f, h);
  }
  function Ab(f, h) {
    return Eg(4, 4, f, h);
  }
  function Sb(f, h) {
    if (typeof h == "function")
      return (
        (f = f()),
        h(f),
        function () {
          h(null);
        }
      );
    if (h != null)
      return (
        (f = f()),
        (h.current = f),
        function () {
          h.current = null;
        }
      );
  }
  function Mb(f, h, y) {
    return (
      (y = y != null ? y.concat([f]) : null), Eg(4, 4, Sb.bind(null, h, f), y)
    );
  }
  function yA() {}
  function wb(f, h) {
    var y = Po();
    h = h === void 0 ? null : h;
    var M = y.memoizedState;
    return M !== null && h !== null && dA(h, M[1])
      ? M[0]
      : ((y.memoizedState = [f, h]), f);
  }
  function Eb(f, h) {
    var y = Po();
    h = h === void 0 ? null : h;
    var M = y.memoizedState;
    return M !== null && h !== null && dA(h, M[1])
      ? M[0]
      : ((f = f()), (y.memoizedState = [f, h]), f);
  }
  function Uz(f, h) {
    var y = an;
    (an = y !== 0 && 4 > y ? y : 4), f(!0);
    var M = Rs.transition;
    Rs.transition = {};
    try {
      f(!1), h();
    } finally {
      (an = y), (Rs.transition = M);
    }
  }
  function Tb() {
    return Po().memoizedState;
  }
  function kz(f, h, y) {
    var M = Qa(f);
    (y = {
      lane: M,
      action: y,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      Cb(f)
        ? bb(h, y)
        : (Rb(f, h, y),
          (y = ar()),
          (f = Ps(f, M, y)),
          f !== null && Pb(f, h, M));
  }
  function zz(f, h, y) {
    var M = Qa(f),
      E = {
        lane: M,
        action: y,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (Cb(f)) bb(h, E);
    else {
      Rb(f, h, E);
      var B = f.alternate;
      if (
        f.lanes === 0 &&
        (B === null || B.lanes === 0) &&
        ((B = h.lastRenderedReducer), B !== null)
      )
        try {
          var H = h.lastRenderedState,
            ee = B(H, y);
          if (((E.hasEagerState = !0), (E.eagerState = ee), To(ee, H))) return;
        } catch {
        } finally {
        }
      (y = ar()), (f = Ps(f, M, y)), f !== null && Pb(f, h, M);
    }
  }
  function Cb(f) {
    var h = f.alternate;
    return f === zn || (h !== null && h === zn);
  }
  function bb(f, h) {
    rd = Ag = !0;
    var y = f.pending;
    y === null ? (h.next = h) : ((h.next = y.next), (y.next = h)),
      (f.pending = h);
  }
  function Rb(f, h, y) {
    ei !== null && f.mode & 1 && !(zt & 2)
      ? ((f = h.interleaved),
        f === null
          ? ((y.next = y), bo === null ? (bo = [h]) : bo.push(h))
          : ((y.next = f.next), (f.next = y)),
        (h.interleaved = y))
      : ((f = h.pending),
        f === null ? (y.next = y) : ((y.next = f.next), (f.next = y)),
        (h.pending = y));
  }
  function Pb(f, h, y) {
    if (y & 4194240) {
      var M = h.lanes;
      (M &= f.pendingLanes), (y |= M), (h.lanes = y), Jx(f, y);
    }
  }
  var Tg = {
      readContext: Es,
      useCallback: zi,
      useContext: zi,
      useEffect: zi,
      useImperativeHandle: zi,
      useInsertionEffect: zi,
      useLayoutEffect: zi,
      useMemo: zi,
      useReducer: zi,
      useRef: zi,
      useState: zi,
      useDebugValue: zi,
      useDeferredValue: zi,
      useTransition: zi,
      useMutableSource: zi,
      useSyncExternalStore: zi,
      useId: zi,
      unstable_isNewReconciler: !1,
    },
    Hz = {
      readContext: Es,
      useCallback: function (f, h) {
        return (ia().memoizedState = [f, h === void 0 ? null : h]), f;
      },
      useContext: Es,
      useEffect: vA,
      useImperativeHandle: function (f, h, y) {
        return (
          (y = y != null ? y.concat([f]) : null),
          wg(4194308, 4, Sb.bind(null, h, f), y)
        );
      },
      useLayoutEffect: function (f, h) {
        return wg(4194308, 4, f, h);
      },
      useInsertionEffect: function (f, h) {
        return wg(4, 2, f, h);
      },
      useMemo: function (f, h) {
        var y = ia();
        return (
          (h = h === void 0 ? null : h),
          (f = f()),
          (y.memoizedState = [f, h]),
          f
        );
      },
      useReducer: function (f, h, y) {
        var M = ia();
        return (
          (h = y !== void 0 ? y(h) : h),
          (M.memoizedState = M.baseState = h),
          (f = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: f,
            lastRenderedState: h,
          }),
          (M.queue = f),
          (f = f.dispatch = kz.bind(null, zn, f)),
          [M.memoizedState, f]
        );
      },
      useRef: function (f) {
        var h = ia();
        return (f = { current: f }), (h.memoizedState = f);
      },
      useState: gA,
      useDebugValue: yA,
      useDeferredValue: function (f) {
        var h = gA(f),
          y = h[0],
          M = h[1];
        return (
          vA(
            function () {
              var E = Rs.transition;
              Rs.transition = {};
              try {
                M(f);
              } finally {
                Rs.transition = E;
              }
            },
            [f]
          ),
          y
        );
      },
      useTransition: function () {
        var f = gA(!1),
          h = f[0];
        return (f = Uz.bind(null, f[1])), (ia().memoizedState = f), [h, f];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (f, h, y) {
        var M = zn,
          E = ia();
        if (Tn) {
          if (y === void 0) throw Error(o(407));
          y = y();
        } else {
          if (((y = h()), ei === null)) throw Error(o(349));
          qc & 30 || mb(M, h, y);
        }
        E.memoizedState = y;
        var B = { value: y, getSnapshot: h };
        return (
          (E.queue = B),
          vA(vb.bind(null, M, B, f), [f]),
          (M.flags |= 2048),
          od(9, gb.bind(null, M, B, y, h), void 0, null),
          y
        );
      },
      useId: function () {
        var f = ia(),
          h = ei.identifierPrefix;
        if (Tn) {
          var y = na,
            M = ta;
          (y = (M & ~(1 << (32 - Kt(M) - 1))).toString(32) + y),
            (h = ":" + h + "R" + y),
            (y = sd++),
            0 < y && (h += "H" + y.toString(32)),
            (h += ":");
        } else (y = Oz++), (h = ":" + h + "r" + y.toString(32) + ":");
        return (f.memoizedState = h);
      },
      unstable_isNewReconciler: !1,
    },
    Gz = {
      readContext: Es,
      useCallback: wb,
      useContext: Es,
      useEffect: ad,
      useImperativeHandle: Mb,
      useInsertionEffect: xb,
      useLayoutEffect: Ab,
      useMemo: Eb,
      useReducer: Sg,
      useRef: _b,
      useState: function () {
        return Sg(iu);
      },
      useDebugValue: yA,
      useDeferredValue: function (f) {
        var h = Sg(iu),
          y = h[0],
          M = h[1];
        return (
          ad(
            function () {
              var E = Rs.transition;
              Rs.transition = {};
              try {
                M(f);
              } finally {
                Rs.transition = E;
              }
            },
            [f]
          ),
          y
        );
      },
      useTransition: function () {
        var f = Sg(iu)[0],
          h = Po().memoizedState;
        return [f, h];
      },
      useMutableSource: db,
      useSyncExternalStore: pb,
      useId: Tb,
      unstable_isNewReconciler: !1,
    },
    Vz = {
      readContext: Es,
      useCallback: wb,
      useContext: Es,
      useEffect: ad,
      useImperativeHandle: Mb,
      useInsertionEffect: xb,
      useLayoutEffect: Ab,
      useMemo: Eb,
      useReducer: Mg,
      useRef: _b,
      useState: function () {
        return Mg(iu);
      },
      useDebugValue: yA,
      useDeferredValue: function (f) {
        var h = Mg(iu),
          y = h[0],
          M = h[1];
        return (
          ad(
            function () {
              var E = Rs.transition;
              Rs.transition = {};
              try {
                M(f);
              } finally {
                Rs.transition = E;
              }
            },
            [f]
          ),
          y
        );
      },
      useTransition: function () {
        var f = Mg(iu)[0],
          h = Po().memoizedState;
        return [f, h];
      },
      useMutableSource: db,
      useSyncExternalStore: pb,
      useId: Tb,
      unstable_isNewReconciler: !1,
    };
  function _A(f, h) {
    try {
      var y = "",
        M = h;
      do (y += Nz(M)), (M = M.return);
      while (M);
      var E = y;
    } catch (B) {
      E =
        `
Error generating stack: ` +
        B.message +
        `
` +
        B.stack;
    }
    return { value: f, source: h, stack: E };
  }
  function xA(f, h) {
    try {
      console.error(h.value);
    } catch (y) {
      setTimeout(function () {
        throw y;
      });
    }
  }
  var Wz = typeof WeakMap == "function" ? WeakMap : Map;
  function Bb(f, h, y) {
    (y = ea(-1, y)), (y.tag = 3), (y.payload = { element: null });
    var M = h.value;
    return (
      (y.callback = function () {
        Gg || ((Gg = !0), (UA = M)), xA(f, h);
      }),
      y
    );
  }
  function Ib(f, h, y) {
    (y = ea(-1, y)), (y.tag = 3);
    var M = f.type.getDerivedStateFromError;
    if (typeof M == "function") {
      var E = h.value;
      (y.payload = function () {
        return M(E);
      }),
        (y.callback = function () {
          xA(f, h);
        });
    }
    var B = f.stateNode;
    return (
      B !== null &&
        typeof B.componentDidCatch == "function" &&
        (y.callback = function () {
          xA(f, h),
            typeof M != "function" &&
              (Ya === null ? (Ya = new Set([this])) : Ya.add(this));
          var H = h.stack;
          this.componentDidCatch(h.value, {
            componentStack: H !== null ? H : "",
          });
        }),
      y
    );
  }
  function Db(f, h, y) {
    var M = f.pingCache;
    if (M === null) {
      M = f.pingCache = new Wz();
      var E = new Set();
      M.set(h, E);
    } else (E = M.get(h)), E === void 0 && ((E = new Set()), M.set(h, E));
    E.has(y) || (E.add(y), (f = r4.bind(null, f, h, y)), h.then(f, f));
  }
  function Lb(f) {
    do {
      var h;
      if (
        ((h = f.tag === 13) &&
          ((h = f.memoizedState),
          (h = h !== null ? h.dehydrated !== null : !0)),
        h)
      )
        return f;
      f = f.return;
    } while (f !== null);
    return null;
  }
  function Fb(f, h, y, M, E) {
    return f.mode & 1
      ? ((f.flags |= 65536), (f.lanes = E), f)
      : (f === h
          ? (f.flags |= 65536)
          : ((f.flags |= 128),
            (y.flags |= 131072),
            (y.flags &= -52805),
            y.tag === 1 &&
              (y.alternate === null
                ? (y.tag = 17)
                : ((h = ea(-1, 1)), (h.tag = 2), ja(y, h))),
            (y.lanes |= 1)),
        f);
  }
  function Bo(f) {
    f.flags |= 4;
  }
  function Nb(f, h) {
    if (f !== null && f.child === h.child) return !0;
    if (h.flags & 16) return !1;
    for (f = h.child; f !== null; ) {
      if (f.flags & 12854 || f.subtreeFlags & 12854) return !1;
      f = f.sibling;
    }
    return !0;
  }
  var ld, ud, Cg, bg;
  if (Fe)
    (ld = function (f, h) {
      for (var y = h.child; y !== null; ) {
        if (y.tag === 5 || y.tag === 6) Me(f, y.stateNode);
        else if (y.tag !== 4 && y.child !== null) {
          (y.child.return = y), (y = y.child);
          continue;
        }
        if (y === h) break;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === h) return;
          y = y.return;
        }
        (y.sibling.return = y.return), (y = y.sibling);
      }
    }),
      (ud = function () {}),
      (Cg = function (f, h, y, M, E) {
        if (((f = f.memoizedProps), f !== M)) {
          var B = h.stateNode,
            H = Ro(bs.current);
          (y = re(B, y, f, M, E, H)), (h.updateQueue = y) && Bo(h);
        }
      }),
      (bg = function (f, h, y, M) {
        y !== M && Bo(h);
      });
  else if (de) {
    ld = function (f, h, y, M) {
      for (var E = h.child; E !== null; ) {
        if (E.tag === 5) {
          var B = E.stateNode;
          y && M && (B = We(B, E.type, E.memoizedProps, E)), Me(f, B);
        } else if (E.tag === 6)
          (B = E.stateNode),
            y && M && (B = nt(B, E.memoizedProps, E)),
            Me(f, B);
        else if (E.tag !== 4) {
          if (E.tag === 22 && E.memoizedState !== null)
            (B = E.child), B !== null && (B.return = E), ld(f, E, !0, !0);
          else if (E.child !== null) {
            (E.child.return = E), (E = E.child);
            continue;
          }
        }
        if (E === h) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === h) return;
          E = E.return;
        }
        (E.sibling.return = E.return), (E = E.sibling);
      }
    };
    var Ob = function (f, h, y, M) {
      for (var E = h.child; E !== null; ) {
        if (E.tag === 5) {
          var B = E.stateNode;
          y && M && (B = We(B, E.type, E.memoizedProps, E)), ft(f, B);
        } else if (E.tag === 6)
          (B = E.stateNode),
            y && M && (B = nt(B, E.memoizedProps, E)),
            ft(f, B);
        else if (E.tag !== 4) {
          if (E.tag === 22 && E.memoizedState !== null)
            (B = E.child), B !== null && (B.return = E), Ob(f, E, !0, !0);
          else if (E.child !== null) {
            (E.child.return = E), (E = E.child);
            continue;
          }
        }
        if (E === h) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === h) return;
          E = E.return;
        }
        (E.sibling.return = E.return), (E = E.sibling);
      }
    };
    (ud = function (f, h) {
      var y = h.stateNode;
      if (!Nb(f, h)) {
        f = y.containerInfo;
        var M = ke(f);
        Ob(M, h, !1, !1), (y.pendingChildren = M), Bo(h), Ct(f, M);
      }
    }),
      (Cg = function (f, h, y, M, E) {
        var B = f.stateNode,
          H = f.memoizedProps;
        if ((f = Nb(f, h)) && H === M) h.stateNode = B;
        else {
          var ee = h.stateNode,
            ve = Ro(bs.current),
            Oe = null;
          H !== M && (Oe = re(ee, y, H, M, E, ve)),
            f && Oe === null
              ? (h.stateNode = B)
              : ((B = Ue(B, Oe, y, H, M, h, f, ee)),
                De(B, y, M, E, ve) && Bo(h),
                (h.stateNode = B),
                f ? Bo(h) : ld(B, h, !1, !1));
        }
      }),
      (bg = function (f, h, y, M) {
        y !== M
          ? ((f = Ro(Qc.current)),
            (y = Ro(bs.current)),
            (h.stateNode = Ce(M, f, y, h)),
            Bo(h))
          : (h.stateNode = f.stateNode);
      });
  } else (ud = function () {}), (Cg = function () {}), (bg = function () {});
  function cd(f, h) {
    if (!Tn)
      switch (f.tailMode) {
        case "hidden":
          h = f.tail;
          for (var y = null; h !== null; )
            h.alternate !== null && (y = h), (h = h.sibling);
          y === null ? (f.tail = null) : (y.sibling = null);
          break;
        case "collapsed":
          y = f.tail;
          for (var M = null; y !== null; )
            y.alternate !== null && (M = y), (y = y.sibling);
          M === null
            ? h || f.tail === null
              ? (f.tail = null)
              : (f.tail.sibling = null)
            : (M.sibling = null);
      }
  }
  function Hi(f) {
    var h = f.alternate !== null && f.alternate.child === f.child,
      y = 0,
      M = 0;
    if (h)
      for (var E = f.child; E !== null; )
        (y |= E.lanes | E.childLanes),
          (M |= E.subtreeFlags & 14680064),
          (M |= E.flags & 14680064),
          (E.return = f),
          (E = E.sibling);
    else
      for (E = f.child; E !== null; )
        (y |= E.lanes | E.childLanes),
          (M |= E.subtreeFlags),
          (M |= E.flags),
          (E.return = f),
          (E = E.sibling);
    return (f.subtreeFlags |= M), (f.childLanes = y), h;
  }
  function Xz(f, h, y) {
    var M = h.pendingProps;
    switch ((sA(h), h.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Hi(h), null;
      case 1:
        return on(h.type) && Qt(), Hi(h), null;
      case 3:
        return (
          (M = h.stateNode),
          Zc(),
          Ge(Jt),
          Ge(Xt),
          hA(),
          M.pendingContext &&
            ((M.context = M.pendingContext), (M.pendingContext = null)),
          (f === null || f.child === null) &&
            (ed(h)
              ? Bo(h)
              : f === null ||
                (f.memoizedState.isDehydrated && !(h.flags & 256)) ||
                ((h.flags |= 1024), no !== null && (HA(no), (no = null)))),
          ud(f, h),
          Hi(h),
          null
        );
      case 5:
        cA(h), (y = Ro(Qc.current));
        var E = h.type;
        if (f !== null && h.stateNode != null)
          Cg(f, h, E, M, y),
            f.ref !== h.ref && ((h.flags |= 512), (h.flags |= 2097152));
        else {
          if (!M) {
            if (h.stateNode === null) throw Error(o(166));
            return Hi(h), null;
          }
          if (((f = Ro(bs.current)), ed(h))) {
            if (!ce) throw Error(o(175));
            (f = dn(h.stateNode, h.type, h.memoizedProps, y, f, h, !$h)),
              (h.updateQueue = f),
              f !== null && Bo(h);
          } else {
            var B = se(E, M, y, f, h);
            ld(B, h, !1, !1), (h.stateNode = B), De(B, E, M, y, f) && Bo(h);
          }
          h.ref !== null && ((h.flags |= 512), (h.flags |= 2097152));
        }
        return Hi(h), null;
      case 6:
        if (f && h.stateNode != null) bg(f, h, f.memoizedProps, M);
        else {
          if (typeof M != "string" && h.stateNode === null) throw Error(o(166));
          if (((f = Ro(Qc.current)), (y = Ro(bs.current)), ed(h))) {
            if (!ce) throw Error(o(176));
            if (
              ((f = h.stateNode),
              (M = h.memoizedProps),
              (y = sn(f, M, h, !$h)) && ((E = Zr), E !== null))
            )
              switch (((B = (E.mode & 1) !== 0), E.tag)) {
                case 3:
                  $(E.stateNode.containerInfo, f, M, B);
                  break;
                case 5:
                  ae(E.type, E.memoizedProps, E.stateNode, f, M, B);
              }
            y && Bo(h);
          } else h.stateNode = Ce(M, f, y, h);
        }
        return Hi(h), null;
      case 13:
        if (
          (Ge(In),
          (M = h.memoizedState),
          Tn && qr !== null && h.mode & 1 && !(h.flags & 128))
        ) {
          for (f = qr; f; ) f = bt(f);
          return Yc(), (h.flags |= 98560), h;
        }
        if (M !== null && M.dehydrated !== null) {
          if (((M = ed(h)), f === null)) {
            if (!M) throw Error(o(318));
            if (!ce) throw Error(o(344));
            if (
              ((f = h.memoizedState),
              (f = f !== null ? f.dehydrated : null),
              !f)
            )
              throw Error(o(317));
            sr(f, h);
          } else
            Yc(), !(h.flags & 128) && (h.memoizedState = null), (h.flags |= 4);
          return Hi(h), null;
        }
        return (
          no !== null && (HA(no), (no = null)),
          h.flags & 128
            ? ((h.lanes = y), h)
            : ((M = M !== null),
              (y = !1),
              f === null ? ed(h) : (y = f.memoizedState !== null),
              M &&
                !y &&
                ((h.child.flags |= 8192),
                h.mode & 1 &&
                  (f === null || In.current & 1 ? ui === 0 && (ui = 3) : VA())),
              h.updateQueue !== null && (h.flags |= 4),
              Hi(h),
              null)
        );
      case 4:
        return (
          Zc(),
          ud(f, h),
          f === null && Ve(h.stateNode.containerInfo),
          Hi(h),
          null
        );
      case 10:
        return $x(h.type._context), Hi(h), null;
      case 17:
        return on(h.type) && Qt(), Hi(h), null;
      case 19:
        if ((Ge(In), (E = h.memoizedState), E === null)) return Hi(h), null;
        if (((M = (h.flags & 128) !== 0), (B = E.rendering), B === null))
          if (M) cd(E, !1);
          else {
            if (ui !== 0 || (f !== null && f.flags & 128))
              for (f = h.child; f !== null; ) {
                if (((B = _g(f)), B !== null)) {
                  for (
                    h.flags |= 128,
                      cd(E, !1),
                      f = B.updateQueue,
                      f !== null && ((h.updateQueue = f), (h.flags |= 4)),
                      h.subtreeFlags = 0,
                      f = y,
                      M = h.child;
                    M !== null;

                  )
                    (y = M),
                      (E = f),
                      (y.flags &= 14680066),
                      (B = y.alternate),
                      B === null
                        ? ((y.childLanes = 0),
                          (y.lanes = E),
                          (y.child = null),
                          (y.subtreeFlags = 0),
                          (y.memoizedProps = null),
                          (y.memoizedState = null),
                          (y.updateQueue = null),
                          (y.dependencies = null),
                          (y.stateNode = null))
                        : ((y.childLanes = B.childLanes),
                          (y.lanes = B.lanes),
                          (y.child = B.child),
                          (y.subtreeFlags = 0),
                          (y.deletions = null),
                          (y.memoizedProps = B.memoizedProps),
                          (y.memoizedState = B.memoizedState),
                          (y.updateQueue = B.updateQueue),
                          (y.type = B.type),
                          (E = B.dependencies),
                          (y.dependencies =
                            E === null
                              ? null
                              : {
                                  lanes: E.lanes,
                                  firstContext: E.firstContext,
                                })),
                      (M = M.sibling);
                  return rt(In, (In.current & 1) | 2), h.child;
                }
                f = f.sibling;
              }
            E.tail !== null &&
              xi() > OA &&
              ((h.flags |= 128), (M = !0), cd(E, !1), (h.lanes = 4194304));
          }
        else {
          if (!M)
            if (((f = _g(B)), f !== null)) {
              if (
                ((h.flags |= 128),
                (M = !0),
                (f = f.updateQueue),
                f !== null && ((h.updateQueue = f), (h.flags |= 4)),
                cd(E, !0),
                E.tail === null &&
                  E.tailMode === "hidden" &&
                  !B.alternate &&
                  !Tn)
              )
                return Hi(h), null;
            } else
              2 * xi() - E.renderingStartTime > OA &&
                y !== 1073741824 &&
                ((h.flags |= 128), (M = !0), cd(E, !1), (h.lanes = 4194304));
          E.isBackwards
            ? ((B.sibling = h.child), (h.child = B))
            : ((f = E.last),
              f !== null ? (f.sibling = B) : (h.child = B),
              (E.last = B));
        }
        return E.tail !== null
          ? ((h = E.tail),
            (E.rendering = h),
            (E.tail = h.sibling),
            (E.renderingStartTime = xi()),
            (h.sibling = null),
            (f = In.current),
            rt(In, M ? (f & 1) | 2 : f & 1),
            h)
          : (Hi(h), null);
      case 22:
      case 23:
        return (
          GA(),
          (M = h.memoizedState !== null),
          f !== null && (f.memoizedState !== null) !== M && (h.flags |= 8192),
          M && h.mode & 1
            ? es & 1073741824 &&
              (Hi(h), Fe && h.subtreeFlags & 6 && (h.flags |= 8192))
            : Hi(h),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, h.tag));
  }
  var Jz = a.ReactCurrentOwner,
    $r = !1;
  function or(f, h, y, M) {
    h.child = f === null ? fb(h, null, y, M) : Kc(h, f.child, y, M);
  }
  function Ub(f, h, y, M, E) {
    y = y.render;
    var B = h.ref;
    return (
      Xc(h, E),
      (M = pA(f, h, y, M, B, E)),
      (y = mA()),
      f !== null && !$r
        ? ((h.updateQueue = f.updateQueue),
          (h.flags &= -2053),
          (f.lanes &= ~E),
          ra(f, h, E))
        : (Tn && y && rA(h), (h.flags |= 1), or(f, h, M, E), h.child)
    );
  }
  function kb(f, h, y, M, E) {
    if (f === null) {
      var B = y.type;
      return typeof B == "function" &&
        !WA(B) &&
        B.defaultProps === void 0 &&
        y.compare === null &&
        y.defaultProps === void 0
        ? ((h.tag = 15), (h.type = B), zb(f, h, B, M, E))
        : ((f = Kg(y.type, null, M, h, h.mode, E)),
          (f.ref = h.ref),
          (f.return = h),
          (h.child = f));
    }
    if (((B = f.child), !(f.lanes & E))) {
      var H = B.memoizedProps;
      if (
        ((y = y.compare), (y = y !== null ? y : cg), y(H, M) && f.ref === h.ref)
      )
        return ra(f, h, E);
    }
    return (
      (h.flags |= 1),
      (f = qa(B, M)),
      (f.ref = h.ref),
      (f.return = h),
      (h.child = f)
    );
  }
  function zb(f, h, y, M, E) {
    if (f !== null && cg(f.memoizedProps, M) && f.ref === h.ref)
      if ((($r = !1), (f.lanes & E) !== 0)) f.flags & 131072 && ($r = !0);
      else return (h.lanes = f.lanes), ra(f, h, E);
    return AA(f, h, y, M, E);
  }
  function Hb(f, h, y) {
    var M = h.pendingProps,
      E = M.children,
      B = f !== null ? f.memoizedState : null;
    if (M.mode === "hidden")
      if (!(h.mode & 1))
        (h.memoizedState = { baseLanes: 0, cachePool: null }),
          rt($c, es),
          (es |= y);
      else if (y & 1073741824)
        (h.memoizedState = { baseLanes: 0, cachePool: null }),
          (M = B !== null ? B.baseLanes : y),
          rt($c, es),
          (es |= M);
      else
        return (
          (f = B !== null ? B.baseLanes | y : y),
          (h.lanes = h.childLanes = 1073741824),
          (h.memoizedState = { baseLanes: f, cachePool: null }),
          (h.updateQueue = null),
          rt($c, es),
          (es |= f),
          null
        );
    else
      B !== null ? ((M = B.baseLanes | y), (h.memoizedState = null)) : (M = y),
        rt($c, es),
        (es |= M);
    return or(f, h, E, y), h.child;
  }
  function Gb(f, h) {
    var y = h.ref;
    ((f === null && y !== null) || (f !== null && f.ref !== y)) &&
      ((h.flags |= 512), (h.flags |= 2097152));
  }
  function AA(f, h, y, M, E) {
    var B = on(y) ? Ot : Xt.current;
    return (
      (B = gt(h, B)),
      Xc(h, E),
      (y = pA(f, h, y, M, B, E)),
      (M = mA()),
      f !== null && !$r
        ? ((h.updateQueue = f.updateQueue),
          (h.flags &= -2053),
          (f.lanes &= ~E),
          ra(f, h, E))
        : (Tn && M && rA(h), (h.flags |= 1), or(f, h, y, E), h.child)
    );
  }
  function Vb(f, h, y, M, E) {
    if (on(y)) {
      var B = !0;
      _i(h);
    } else B = !1;
    if ((Xc(h, E), h.stateNode === null))
      f !== null &&
        ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
        ib(h, y, M),
        iA(h, y, M, E),
        (M = !0);
    else if (f === null) {
      var H = h.stateNode,
        ee = h.memoizedProps;
      H.props = ee;
      var ve = H.context,
        Oe = y.contextType;
      typeof Oe == "object" && Oe !== null
        ? (Oe = Es(Oe))
        : ((Oe = on(y) ? Ot : Xt.current), (Oe = gt(h, Oe)));
      var at = y.getDerivedStateFromProps,
        Pt =
          typeof at == "function" ||
          typeof H.getSnapshotBeforeUpdate == "function";
      Pt ||
        (typeof H.UNSAFE_componentWillReceiveProps != "function" &&
          typeof H.componentWillReceiveProps != "function") ||
        ((ee !== M || ve !== Oe) && rb(h, H, M, Oe)),
        (Ja = !1);
      var xt = h.memoizedState;
      (H.state = xt),
        pg(h, M, H, E),
        (ve = h.memoizedState),
        ee !== M || xt !== ve || Jt.current || Ja
          ? (typeof at == "function" &&
              (nA(h, y, at, M), (ve = h.memoizedState)),
            (ee = Ja || nb(h, y, ee, M, xt, ve, Oe))
              ? (Pt ||
                  (typeof H.UNSAFE_componentWillMount != "function" &&
                    typeof H.componentWillMount != "function") ||
                  (typeof H.componentWillMount == "function" &&
                    H.componentWillMount(),
                  typeof H.UNSAFE_componentWillMount == "function" &&
                    H.UNSAFE_componentWillMount()),
                typeof H.componentDidMount == "function" &&
                  (h.flags |= 4194308))
              : (typeof H.componentDidMount == "function" &&
                  (h.flags |= 4194308),
                (h.memoizedProps = M),
                (h.memoizedState = ve)),
            (H.props = M),
            (H.state = ve),
            (H.context = Oe),
            (M = ee))
          : (typeof H.componentDidMount == "function" && (h.flags |= 4194308),
            (M = !1));
    } else {
      (H = h.stateNode),
        qC(f, h),
        (ee = h.memoizedProps),
        (Oe = h.type === h.elementType ? ee : to(h.type, ee)),
        (H.props = Oe),
        (Pt = h.pendingProps),
        (xt = H.context),
        (ve = y.contextType),
        typeof ve == "object" && ve !== null
          ? (ve = Es(ve))
          : ((ve = on(y) ? Ot : Xt.current), (ve = gt(h, ve)));
      var yn = y.getDerivedStateFromProps;
      (at =
        typeof yn == "function" ||
        typeof H.getSnapshotBeforeUpdate == "function") ||
        (typeof H.UNSAFE_componentWillReceiveProps != "function" &&
          typeof H.componentWillReceiveProps != "function") ||
        ((ee !== Pt || xt !== ve) && rb(h, H, M, ve)),
        (Ja = !1),
        (xt = h.memoizedState),
        (H.state = xt),
        pg(h, M, H, E);
      var yt = h.memoizedState;
      ee !== Pt || xt !== yt || Jt.current || Ja
        ? (typeof yn == "function" && (nA(h, y, yn, M), (yt = h.memoizedState)),
          (Oe = Ja || nb(h, y, Oe, M, xt, yt, ve) || !1)
            ? (at ||
                (typeof H.UNSAFE_componentWillUpdate != "function" &&
                  typeof H.componentWillUpdate != "function") ||
                (typeof H.componentWillUpdate == "function" &&
                  H.componentWillUpdate(M, yt, ve),
                typeof H.UNSAFE_componentWillUpdate == "function" &&
                  H.UNSAFE_componentWillUpdate(M, yt, ve)),
              typeof H.componentDidUpdate == "function" && (h.flags |= 4),
              typeof H.getSnapshotBeforeUpdate == "function" &&
                (h.flags |= 1024))
            : (typeof H.componentDidUpdate != "function" ||
                (ee === f.memoizedProps && xt === f.memoizedState) ||
                (h.flags |= 4),
              typeof H.getSnapshotBeforeUpdate != "function" ||
                (ee === f.memoizedProps && xt === f.memoizedState) ||
                (h.flags |= 1024),
              (h.memoizedProps = M),
              (h.memoizedState = yt)),
          (H.props = M),
          (H.state = yt),
          (H.context = ve),
          (M = Oe))
        : (typeof H.componentDidUpdate != "function" ||
            (ee === f.memoizedProps && xt === f.memoizedState) ||
            (h.flags |= 4),
          typeof H.getSnapshotBeforeUpdate != "function" ||
            (ee === f.memoizedProps && xt === f.memoizedState) ||
            (h.flags |= 1024),
          (M = !1));
    }
    return SA(f, h, y, M, B, E);
  }
  function SA(f, h, y, M, E, B) {
    Gb(f, h);
    var H = (h.flags & 128) !== 0;
    if (!M && !H) return E && Wa(h, y, !1), ra(f, h, B);
    (M = h.stateNode), (Jz.current = h);
    var ee =
      H && typeof y.getDerivedStateFromError != "function" ? null : M.render();
    return (
      (h.flags |= 1),
      f !== null && H
        ? ((h.child = Kc(h, f.child, null, B)), (h.child = Kc(h, null, ee, B)))
        : or(f, h, ee, B),
      (h.memoizedState = M.state),
      E && Wa(h, y, !0),
      h.child
    );
  }
  function Wb(f) {
    var h = f.stateNode;
    h.pendingContext
      ? Tr(f, h.pendingContext, h.pendingContext !== h.context)
      : h.context && Tr(f, h.context, !1),
      uA(f, h.containerInfo);
  }
  function Xb(f, h, y, M, E) {
    return Yc(), lA(E), (h.flags |= 256), or(f, h, y, M), h.child;
  }
  var Rg = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Pg(f) {
    return { baseLanes: f, cachePool: null };
  }
  function Jb(f, h, y) {
    var M = h.pendingProps,
      E = In.current,
      B = !1,
      H = (h.flags & 128) !== 0,
      ee;
    if (
      ((ee = H) ||
        (ee = f !== null && f.memoizedState === null ? !1 : (E & 2) !== 0),
      ee
        ? ((B = !0), (h.flags &= -129))
        : (f === null || f.memoizedState !== null) && (E |= 1),
      rt(In, E & 1),
      f === null)
    )
      return (
        aA(h),
        (f = h.memoizedState),
        f !== null && ((f = f.dehydrated), f !== null)
          ? (h.mode & 1
              ? St(f)
                ? (h.lanes = 8)
                : (h.lanes = 1073741824)
              : (h.lanes = 1),
            null)
          : ((E = M.children),
            (f = M.fallback),
            B
              ? ((M = h.mode),
                (B = h.child),
                (E = { mode: "hidden", children: E }),
                !(M & 1) && B !== null
                  ? ((B.childLanes = 0), (B.pendingProps = E))
                  : (B = Qg(E, M, 0, null)),
                (f = uu(f, M, y, null)),
                (B.return = h),
                (f.return = h),
                (B.sibling = f),
                (h.child = B),
                (h.child.memoizedState = Pg(y)),
                (h.memoizedState = Rg),
                f)
              : MA(h, E))
      );
    if (((E = f.memoizedState), E !== null)) {
      if (((ee = E.dehydrated), ee !== null)) {
        if (H)
          return h.flags & 256
            ? ((h.flags &= -257), Bg(f, h, y, Error(o(422))))
            : h.memoizedState !== null
            ? ((h.child = f.child), (h.flags |= 128), null)
            : ((B = M.fallback),
              (E = h.mode),
              (M = Qg({ mode: "visible", children: M.children }, E, 0, null)),
              (B = uu(B, E, y, null)),
              (B.flags |= 2),
              (M.return = h),
              (B.return = h),
              (M.sibling = B),
              (h.child = M),
              h.mode & 1 && Kc(h, f.child, null, y),
              (h.child.memoizedState = Pg(y)),
              (h.memoizedState = Rg),
              B);
        if (!(h.mode & 1)) h = Bg(f, h, y, null);
        else if (St(ee)) h = Bg(f, h, y, Error(o(419)));
        else if (((M = (y & f.childLanes) !== 0), $r || M)) {
          if (((M = ei), M !== null)) {
            switch (y & -y) {
              case 4:
                B = 2;
                break;
              case 16:
                B = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                B = 32;
                break;
              case 536870912:
                B = 268435456;
                break;
              default:
                B = 0;
            }
            (M = B & (M.suspendedLanes | y) ? 0 : B),
              M !== 0 && M !== E.retryLane && ((E.retryLane = M), Ps(f, M, -1));
          }
          VA(), (h = Bg(f, h, y, Error(o(421))));
        } else
          ut(ee)
            ? ((h.flags |= 128),
              (h.child = f.child),
              (h = s4.bind(null, f)),
              Bn(ee, h),
              (h = null))
            : ((y = E.treeContext),
              ce &&
                ((qr = hn(ee)),
                (Zr = h),
                (Tn = !0),
                (no = null),
                ($h = !1),
                y !== null &&
                  ((Ts[Cs++] = ta),
                  (Ts[Cs++] = na),
                  (Ts[Cs++] = tu),
                  (ta = y.id),
                  (na = y.overflow),
                  (tu = h))),
              (h = MA(h, h.pendingProps.children)),
              (h.flags |= 4096));
        return h;
      }
      return B
        ? ((M = Yb(f, h, M.children, M.fallback, y)),
          (B = h.child),
          (E = f.child.memoizedState),
          (B.memoizedState =
            E === null
              ? Pg(y)
              : { baseLanes: E.baseLanes | y, cachePool: null }),
          (B.childLanes = f.childLanes & ~y),
          (h.memoizedState = Rg),
          M)
        : ((y = jb(f, h, M.children, y)), (h.memoizedState = null), y);
    }
    return B
      ? ((M = Yb(f, h, M.children, M.fallback, y)),
        (B = h.child),
        (E = f.child.memoizedState),
        (B.memoizedState =
          E === null ? Pg(y) : { baseLanes: E.baseLanes | y, cachePool: null }),
        (B.childLanes = f.childLanes & ~y),
        (h.memoizedState = Rg),
        M)
      : ((y = jb(f, h, M.children, y)), (h.memoizedState = null), y);
  }
  function MA(f, h) {
    return (
      (h = Qg({ mode: "visible", children: h }, f.mode, 0, null)),
      (h.return = f),
      (f.child = h)
    );
  }
  function jb(f, h, y, M) {
    var E = f.child;
    return (
      (f = E.sibling),
      (y = qa(E, { mode: "visible", children: y })),
      !(h.mode & 1) && (y.lanes = M),
      (y.return = h),
      (y.sibling = null),
      f !== null &&
        ((M = h.deletions),
        M === null ? ((h.deletions = [f]), (h.flags |= 16)) : M.push(f)),
      (h.child = y)
    );
  }
  function Yb(f, h, y, M, E) {
    var B = h.mode;
    f = f.child;
    var H = f.sibling,
      ee = { mode: "hidden", children: y };
    return (
      !(B & 1) && h.child !== f
        ? ((y = h.child),
          (y.childLanes = 0),
          (y.pendingProps = ee),
          (h.deletions = null))
        : ((y = qa(f, ee)), (y.subtreeFlags = f.subtreeFlags & 14680064)),
      H !== null ? (M = qa(H, M)) : ((M = uu(M, B, E, null)), (M.flags |= 2)),
      (M.return = h),
      (y.return = h),
      (y.sibling = M),
      (h.child = y),
      M
    );
  }
  function Bg(f, h, y, M) {
    return (
      M !== null && lA(M),
      Kc(h, f.child, null, y),
      (f = MA(h, h.pendingProps.children)),
      (f.flags |= 2),
      (h.memoizedState = null),
      f
    );
  }
  function Kb(f, h, y) {
    f.lanes |= h;
    var M = f.alternate;
    M !== null && (M.lanes |= h), eA(f.return, h, y);
  }
  function wA(f, h, y, M, E) {
    var B = f.memoizedState;
    B === null
      ? (f.memoizedState = {
          isBackwards: h,
          rendering: null,
          renderingStartTime: 0,
          last: M,
          tail: y,
          tailMode: E,
        })
      : ((B.isBackwards = h),
        (B.rendering = null),
        (B.renderingStartTime = 0),
        (B.last = M),
        (B.tail = y),
        (B.tailMode = E));
  }
  function Qb(f, h, y) {
    var M = h.pendingProps,
      E = M.revealOrder,
      B = M.tail;
    if ((or(f, h, M.children, y), (M = In.current), M & 2))
      (M = (M & 1) | 2), (h.flags |= 128);
    else {
      if (f !== null && f.flags & 128)
        e: for (f = h.child; f !== null; ) {
          if (f.tag === 13) f.memoizedState !== null && Kb(f, y, h);
          else if (f.tag === 19) Kb(f, y, h);
          else if (f.child !== null) {
            (f.child.return = f), (f = f.child);
            continue;
          }
          if (f === h) break e;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === h) break e;
            f = f.return;
          }
          (f.sibling.return = f.return), (f = f.sibling);
        }
      M &= 1;
    }
    if ((rt(In, M), !(h.mode & 1))) h.memoizedState = null;
    else
      switch (E) {
        case "forwards":
          for (y = h.child, E = null; y !== null; )
            (f = y.alternate),
              f !== null && _g(f) === null && (E = y),
              (y = y.sibling);
          (y = E),
            y === null
              ? ((E = h.child), (h.child = null))
              : ((E = y.sibling), (y.sibling = null)),
            wA(h, !1, E, y, B);
          break;
        case "backwards":
          for (y = null, E = h.child, h.child = null; E !== null; ) {
            if (((f = E.alternate), f !== null && _g(f) === null)) {
              h.child = E;
              break;
            }
            (f = E.sibling), (E.sibling = y), (y = E), (E = f);
          }
          wA(h, !0, y, null, B);
          break;
        case "together":
          wA(h, !1, null, null, void 0);
          break;
        default:
          h.memoizedState = null;
      }
    return h.child;
  }
  function ra(f, h, y) {
    if (
      (f !== null && (h.dependencies = f.dependencies),
      (ef |= h.lanes),
      !(y & h.childLanes))
    )
      return null;
    if (f !== null && h.child !== f.child) throw Error(o(153));
    if (h.child !== null) {
      for (
        f = h.child, y = qa(f, f.pendingProps), h.child = y, y.return = h;
        f.sibling !== null;

      )
        (f = f.sibling),
          (y = y.sibling = qa(f, f.pendingProps)),
          (y.return = h);
      y.sibling = null;
    }
    return h.child;
  }
  function jz(f, h, y) {
    switch (h.tag) {
      case 3:
        Wb(h), Yc();
        break;
      case 5:
        hb(h);
        break;
      case 1:
        on(h.type) && _i(h);
        break;
      case 4:
        uA(h, h.stateNode.containerInfo);
        break;
      case 10:
        ZC(h, h.type._context, h.memoizedProps.value);
        break;
      case 13:
        var M = h.memoizedState;
        if (M !== null)
          return M.dehydrated !== null
            ? (rt(In, In.current & 1), (h.flags |= 128), null)
            : y & h.child.childLanes
            ? Jb(f, h, y)
            : (rt(In, In.current & 1),
              (f = ra(f, h, y)),
              f !== null ? f.sibling : null);
        rt(In, In.current & 1);
        break;
      case 19:
        if (((M = (y & h.childLanes) !== 0), f.flags & 128)) {
          if (M) return Qb(f, h, y);
          h.flags |= 128;
        }
        var E = h.memoizedState;
        if (
          (E !== null &&
            ((E.rendering = null), (E.tail = null), (E.lastEffect = null)),
          rt(In, In.current),
          M)
        )
          break;
        return null;
      case 22:
      case 23:
        return (h.lanes = 0), Hb(f, h, y);
    }
    return ra(f, h, y);
  }
  function Yz(f, h) {
    switch ((sA(h), h.tag)) {
      case 1:
        return (
          on(h.type) && Qt(),
          (f = h.flags),
          f & 65536 ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 3:
        return (
          Zc(),
          Ge(Jt),
          Ge(Xt),
          hA(),
          (f = h.flags),
          f & 65536 && !(f & 128) ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 5:
        return cA(h), null;
      case 13:
        if (
          (Ge(In), (f = h.memoizedState), f !== null && f.dehydrated !== null)
        ) {
          if (h.alternate === null) throw Error(o(340));
          Yc();
        }
        return (
          (f = h.flags), f & 65536 ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 19:
        return Ge(In), null;
      case 4:
        return Zc(), null;
      case 10:
        return $x(h.type._context), null;
      case 22:
      case 23:
        return GA(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Ig = !1,
    ru = !1,
    Kz = typeof WeakSet == "function" ? WeakSet : Set,
    qe = null;
  function Dg(f, h) {
    var y = f.ref;
    if (y !== null)
      if (typeof y == "function")
        try {
          y(null);
        } catch (M) {
          Br(f, h, M);
        }
      else y.current = null;
  }
  function EA(f, h, y) {
    try {
      y();
    } catch (M) {
      Br(f, h, M);
    }
  }
  var Zb = !1;
  function Qz(f, h) {
    for (Y(f.containerInfo), qe = h; qe !== null; )
      if (
        ((f = qe), (h = f.child), (f.subtreeFlags & 1028) !== 0 && h !== null)
      )
        (h.return = f), (qe = h);
      else
        for (; qe !== null; ) {
          f = qe;
          try {
            var y = f.alternate;
            if (f.flags & 1024)
              switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (y !== null) {
                    var M = y.memoizedProps,
                      E = y.memoizedState,
                      B = f.stateNode,
                      H = B.getSnapshotBeforeUpdate(
                        f.elementType === f.type ? M : to(f.type, M),
                        E
                      );
                    B.__reactInternalSnapshotBeforeUpdate = H;
                  }
                  break;
                case 3:
                  Fe && ge(f.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (ee) {
            Br(f, f.return, ee);
          }
          if (((h = f.sibling), h !== null)) {
            (h.return = f.return), (qe = h);
            break;
          }
          qe = f.return;
        }
    return (y = Zb), (Zb = !1), y;
  }
  function su(f, h, y) {
    var M = h.updateQueue;
    if (((M = M !== null ? M.lastEffect : null), M !== null)) {
      var E = (M = M.next);
      do {
        if ((E.tag & f) === f) {
          var B = E.destroy;
          (E.destroy = void 0), B !== void 0 && EA(h, y, B);
        }
        E = E.next;
      } while (E !== M);
    }
  }
  function fd(f, h) {
    if (
      ((h = h.updateQueue), (h = h !== null ? h.lastEffect : null), h !== null)
    ) {
      var y = (h = h.next);
      do {
        if ((y.tag & f) === f) {
          var M = y.create;
          y.destroy = M();
        }
        y = y.next;
      } while (y !== h);
    }
  }
  function TA(f) {
    var h = f.ref;
    if (h !== null) {
      var y = f.stateNode;
      switch (f.tag) {
        case 5:
          f = K(y);
          break;
        default:
          f = y;
      }
      typeof h == "function" ? h(f) : (h.current = f);
    }
  }
  function qb(f, h, y) {
    if (Eo && typeof Eo.onCommitFiberUnmount == "function")
      try {
        Eo.onCommitFiberUnmount(lg, h);
      } catch {}
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((f = h.updateQueue), f !== null && ((f = f.lastEffect), f !== null))
        ) {
          var M = (f = f.next);
          do {
            var E = M,
              B = E.destroy;
            (E = E.tag),
              B !== void 0 && (E & 2 || E & 4) && EA(h, y, B),
              (M = M.next);
          } while (M !== f);
        }
        break;
      case 1:
        if (
          (Dg(h, y),
          (f = h.stateNode),
          typeof f.componentWillUnmount == "function")
        )
          try {
            (f.props = h.memoizedProps),
              (f.state = h.memoizedState),
              f.componentWillUnmount();
          } catch (H) {
            Br(h, y, H);
          }
        break;
      case 5:
        Dg(h, y);
        break;
      case 4:
        Fe
          ? rR(f, h, y)
          : de &&
            de &&
            ((h = h.stateNode.containerInfo), (y = ke(h)), cn(h, y));
    }
  }
  function $b(f, h, y) {
    for (var M = h; ; )
      if ((qb(f, M, y), M.child === null || (Fe && M.tag === 4))) {
        if (M === h) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === h) return;
          M = M.return;
        }
        (M.sibling.return = M.return), (M = M.sibling);
      } else (M.child.return = M), (M = M.child);
  }
  function eR(f) {
    var h = f.alternate;
    h !== null && ((f.alternate = null), eR(h)),
      (f.child = null),
      (f.deletions = null),
      (f.sibling = null),
      f.tag === 5 && ((h = f.stateNode), h !== null && J(h)),
      (f.stateNode = null),
      (f.return = null),
      (f.dependencies = null),
      (f.memoizedProps = null),
      (f.memoizedState = null),
      (f.pendingProps = null),
      (f.stateNode = null),
      (f.updateQueue = null);
  }
  function tR(f) {
    return f.tag === 5 || f.tag === 3 || f.tag === 4;
  }
  function nR(f) {
    e: for (;;) {
      for (; f.sibling === null; ) {
        if (f.return === null || tR(f.return)) return null;
        f = f.return;
      }
      for (
        f.sibling.return = f.return, f = f.sibling;
        f.tag !== 5 && f.tag !== 6 && f.tag !== 18;

      ) {
        if (f.flags & 2 || f.child === null || f.tag === 4) continue e;
        (f.child.return = f), (f = f.child);
      }
      if (!(f.flags & 2)) return f.stateNode;
    }
  }
  function iR(f) {
    if (Fe) {
      e: {
        for (var h = f.return; h !== null; ) {
          if (tR(h)) break e;
          h = h.return;
        }
        throw Error(o(160));
      }
      var y = h;
      switch (y.tag) {
        case 5:
          (h = y.stateNode),
            y.flags & 32 && (pe(h), (y.flags &= -33)),
            (y = nR(f)),
            bA(f, y, h);
          break;
        case 3:
        case 4:
          (h = y.stateNode.containerInfo), (y = nR(f)), CA(f, y, h);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function CA(f, h, y) {
    var M = f.tag;
    if (M === 5 || M === 6) (f = f.stateNode), h ? dt(y, f, h) : ze(y, f);
    else if (M !== 4 && ((f = f.child), f !== null))
      for (CA(f, h, y), f = f.sibling; f !== null; )
        CA(f, h, y), (f = f.sibling);
  }
  function bA(f, h, y) {
    var M = f.tag;
    if (M === 5 || M === 6) (f = f.stateNode), h ? mt(y, f, h) : Ie(y, f);
    else if (M !== 4 && ((f = f.child), f !== null))
      for (bA(f, h, y), f = f.sibling; f !== null; )
        bA(f, h, y), (f = f.sibling);
  }
  function rR(f, h, y) {
    for (var M = h, E = !1, B, H; ; ) {
      if (!E) {
        E = M.return;
        e: for (;;) {
          if (E === null) throw Error(o(160));
          switch (((B = E.stateNode), E.tag)) {
            case 5:
              H = !1;
              break e;
            case 3:
              (B = B.containerInfo), (H = !0);
              break e;
            case 4:
              (B = B.containerInfo), (H = !0);
              break e;
          }
          E = E.return;
        }
        E = !0;
      }
      if (M.tag === 5 || M.tag === 6)
        $b(f, M, y), H ? X(B, M.stateNode) : Ke(B, M.stateNode);
      else if (M.tag === 18) H ? Jn(B, M.stateNode) : Xn(B, M.stateNode);
      else if (M.tag === 4) {
        if (M.child !== null) {
          (B = M.stateNode.containerInfo),
            (H = !0),
            (M.child.return = M),
            (M = M.child);
          continue;
        }
      } else if ((qb(f, M, y), M.child !== null)) {
        (M.child.return = M), (M = M.child);
        continue;
      }
      if (M === h) break;
      for (; M.sibling === null; ) {
        if (M.return === null || M.return === h) return;
        (M = M.return), M.tag === 4 && (E = !1);
      }
      (M.sibling.return = M.return), (M = M.sibling);
    }
  }
  function RA(f, h) {
    if (Fe) {
      switch (h.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          su(3, h, h.return), fd(3, h), su(5, h, h.return);
          return;
        case 1:
          return;
        case 5:
          var y = h.stateNode;
          if (y != null) {
            var M = h.memoizedProps;
            f = f !== null ? f.memoizedProps : M;
            var E = h.type,
              B = h.updateQueue;
            (h.updateQueue = null), B !== null && Ne(y, B, E, f, M, h);
          }
          return;
        case 6:
          if (h.stateNode === null) throw Error(o(162));
          (y = h.memoizedProps),
            Mt(h.stateNode, f !== null ? f.memoizedProps : y, y);
          return;
        case 3:
          ce &&
            f !== null &&
            f.memoizedState.isDehydrated &&
            yi(h.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          Lg(h);
          return;
        case 19:
          Lg(h);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        su(3, h, h.return), fd(3, h), su(5, h, h.return);
        return;
      case 12:
        return;
      case 13:
        Lg(h);
        return;
      case 19:
        Lg(h);
        return;
      case 3:
        ce &&
          f !== null &&
          f.memoizedState.isDehydrated &&
          yi(h.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (de) {
      switch (h.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (h = h.stateNode), cn(h.containerInfo, h.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function Lg(f) {
    var h = f.updateQueue;
    if (h !== null) {
      f.updateQueue = null;
      var y = f.stateNode;
      y === null && (y = f.stateNode = new Kz()),
        h.forEach(function (M) {
          var E = o4.bind(null, f, M);
          y.has(M) || (y.add(M), M.then(E, E));
        });
    }
  }
  function Zz(f, h) {
    for (qe = h; qe !== null; ) {
      h = qe;
      var y = h.deletions;
      if (y !== null)
        for (var M = 0; M < y.length; M++) {
          var E = y[M];
          try {
            var B = f;
            Fe ? rR(B, E, h) : $b(B, E, h);
            var H = E.alternate;
            H !== null && (H.return = null), (E.return = null);
          } catch (vt) {
            Br(E, h, vt);
          }
        }
      if (((y = h.child), h.subtreeFlags & 12854 && y !== null))
        (y.return = h), (qe = y);
      else
        for (; qe !== null; ) {
          h = qe;
          try {
            var ee = h.flags;
            if ((ee & 32 && Fe && pe(h.stateNode), ee & 512)) {
              var ve = h.alternate;
              if (ve !== null) {
                var Oe = ve.ref;
                Oe !== null &&
                  (typeof Oe == "function" ? Oe(null) : (Oe.current = null));
              }
            }
            if (ee & 8192)
              switch (h.tag) {
                case 13:
                  if (h.memoizedState !== null) {
                    var at = h.alternate;
                    (at === null || at.memoizedState === null) && (NA = xi());
                  }
                  break;
                case 22:
                  var Pt = h.memoizedState !== null,
                    xt = h.alternate,
                    yn = xt !== null && xt.memoizedState !== null;
                  if (((y = h), Fe)) {
                    e: if (((M = y), (E = Pt), (B = null), Fe))
                      for (var yt = M; ; ) {
                        if (yt.tag === 5) {
                          if (B === null) {
                            B = yt;
                            var Gi = yt.stateNode;
                            E ? He(Gi) : be(yt.stateNode, yt.memoizedProps);
                          }
                        } else if (yt.tag === 6) {
                          if (B === null) {
                            var Is = yt.stateNode;
                            E ? V(Is) : ue(Is, yt.memoizedProps);
                          }
                        } else if (
                          ((yt.tag !== 22 && yt.tag !== 23) ||
                            yt.memoizedState === null ||
                            yt === M) &&
                          yt.child !== null
                        ) {
                          (yt.child.return = yt), (yt = yt.child);
                          continue;
                        }
                        if (yt === M) break;
                        for (; yt.sibling === null; ) {
                          if (yt.return === null || yt.return === M) break e;
                          B === yt && (B = null), (yt = yt.return);
                        }
                        B === yt && (B = null),
                          (yt.sibling.return = yt.return),
                          (yt = yt.sibling);
                      }
                  }
                  if (Pt && !yn && y.mode & 1) {
                    qe = y;
                    for (var le = y.child; le !== null; ) {
                      for (y = qe = le; qe !== null; ) {
                        M = qe;
                        var ne = M.child;
                        switch (M.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            su(4, M, M.return);
                            break;
                          case 1:
                            Dg(M, M.return);
                            var he = M.stateNode;
                            if (typeof he.componentWillUnmount == "function") {
                              var tt = M.return;
                              try {
                                (he.props = M.memoizedProps),
                                  (he.state = M.memoizedState),
                                  he.componentWillUnmount();
                              } catch (vt) {
                                Br(M, tt, vt);
                              }
                            }
                            break;
                          case 5:
                            Dg(M, M.return);
                            break;
                          case 22:
                            if (M.memoizedState !== null) {
                              aR(y);
                              continue;
                            }
                        }
                        ne !== null ? ((ne.return = M), (qe = ne)) : aR(y);
                      }
                      le = le.sibling;
                    }
                  }
              }
            switch (ee & 4102) {
              case 2:
                iR(h), (h.flags &= -3);
                break;
              case 6:
                iR(h), (h.flags &= -3), RA(h.alternate, h);
                break;
              case 4096:
                h.flags &= -4097;
                break;
              case 4100:
                (h.flags &= -4097), RA(h.alternate, h);
                break;
              case 4:
                RA(h.alternate, h);
            }
          } catch (vt) {
            Br(h, h.return, vt);
          }
          if (((y = h.sibling), y !== null)) {
            (y.return = h.return), (qe = y);
            break;
          }
          qe = h.return;
        }
    }
  }
  function qz(f, h, y) {
    (qe = f), sR(f);
  }
  function sR(f, h, y) {
    for (var M = (f.mode & 1) !== 0; qe !== null; ) {
      var E = qe,
        B = E.child;
      if (E.tag === 22 && M) {
        var H = E.memoizedState !== null || Ig;
        if (!H) {
          var ee = E.alternate,
            ve = (ee !== null && ee.memoizedState !== null) || ru;
          ee = Ig;
          var Oe = ru;
          if (((Ig = H), (ru = ve) && !Oe))
            for (qe = E; qe !== null; )
              (H = qe),
                (ve = H.child),
                H.tag === 22 && H.memoizedState !== null
                  ? lR(E)
                  : ve !== null
                  ? ((ve.return = H), (qe = ve))
                  : lR(E);
          for (; B !== null; ) (qe = B), sR(B), (B = B.sibling);
          (qe = E), (Ig = ee), (ru = Oe);
        }
        oR(f);
      } else
        E.subtreeFlags & 8772 && B !== null
          ? ((B.return = E), (qe = B))
          : oR(f);
    }
  }
  function oR(f) {
    for (; qe !== null; ) {
      var h = qe;
      if (h.flags & 8772) {
        var y = h.alternate;
        try {
          if (h.flags & 8772)
            switch (h.tag) {
              case 0:
              case 11:
              case 15:
                ru || fd(5, h);
                break;
              case 1:
                var M = h.stateNode;
                if (h.flags & 4 && !ru)
                  if (y === null) M.componentDidMount();
                  else {
                    var E =
                      h.elementType === h.type
                        ? y.memoizedProps
                        : to(h.type, y.memoizedProps);
                    M.componentDidUpdate(
                      E,
                      y.memoizedState,
                      M.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var B = h.updateQueue;
                B !== null && eb(h, B, M);
                break;
              case 3:
                var H = h.updateQueue;
                if (H !== null) {
                  if (((y = null), h.child !== null))
                    switch (h.child.tag) {
                      case 5:
                        y = K(h.child.stateNode);
                        break;
                      case 1:
                        y = h.child.stateNode;
                    }
                  eb(h, H, y);
                }
                break;
              case 5:
                var ee = h.stateNode;
                y === null && h.flags & 4 && Re(ee, h.type, h.memoizedProps, h);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (ce && h.memoizedState === null) {
                  var ve = h.alternate;
                  if (ve !== null) {
                    var Oe = ve.memoizedState;
                    if (Oe !== null) {
                      var at = Oe.dehydrated;
                      at !== null && Er(at);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          ru || (h.flags & 512 && TA(h));
        } catch (Pt) {
          Br(h, h.return, Pt);
        }
      }
      if (h === f) {
        qe = null;
        break;
      }
      if (((y = h.sibling), y !== null)) {
        (y.return = h.return), (qe = y);
        break;
      }
      qe = h.return;
    }
  }
  function aR(f) {
    for (; qe !== null; ) {
      var h = qe;
      if (h === f) {
        qe = null;
        break;
      }
      var y = h.sibling;
      if (y !== null) {
        (y.return = h.return), (qe = y);
        break;
      }
      qe = h.return;
    }
  }
  function lR(f) {
    for (; qe !== null; ) {
      var h = qe;
      try {
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            var y = h.return;
            try {
              fd(4, h);
            } catch (ve) {
              Br(h, y, ve);
            }
            break;
          case 1:
            var M = h.stateNode;
            if (typeof M.componentDidMount == "function") {
              var E = h.return;
              try {
                M.componentDidMount();
              } catch (ve) {
                Br(h, E, ve);
              }
            }
            var B = h.return;
            try {
              TA(h);
            } catch (ve) {
              Br(h, B, ve);
            }
            break;
          case 5:
            var H = h.return;
            try {
              TA(h);
            } catch (ve) {
              Br(h, H, ve);
            }
        }
      } catch (ve) {
        Br(h, h.return, ve);
      }
      if (h === f) {
        qe = null;
        break;
      }
      var ee = h.sibling;
      if (ee !== null) {
        (ee.return = h.return), (qe = ee);
        break;
      }
      qe = h.return;
    }
  }
  var Fg = 0,
    Ng = 1,
    Og = 2,
    Ug = 3,
    kg = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var hd = Symbol.for;
    (Fg = hd("selector.component")),
      (Ng = hd("selector.has_pseudo_class")),
      (Og = hd("selector.role")),
      (Ug = hd("selector.test_id")),
      (kg = hd("selector.text"));
  }
  function PA(f) {
    var h = k(f);
    if (h != null) {
      if (typeof h.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return h;
    }
    if (((f = U(f)), f === null)) throw Error(o(362));
    return f.stateNode.current;
  }
  function BA(f, h) {
    switch (h.$$typeof) {
      case Fg:
        if (f.type === h.value) return !0;
        break;
      case Ng:
        e: {
          (h = h.value), (f = [f, 0]);
          for (var y = 0; y < f.length; ) {
            var M = f[y++],
              E = f[y++],
              B = h[E];
            if (M.tag !== 5 || !fe(M)) {
              for (; B != null && BA(M, B); ) E++, (B = h[E]);
              if (E === h.length) {
                h = !0;
                break e;
              } else
                for (M = M.child; M !== null; ) f.push(M, E), (M = M.sibling);
            }
          }
          h = !1;
        }
        return h;
      case Og:
        if (f.tag === 5 && ye(f.stateNode, h.value)) return !0;
        break;
      case kg:
        if (
          (f.tag === 5 || f.tag === 6) &&
          ((f = ie(f)), f !== null && 0 <= f.indexOf(h.value))
        )
          return !0;
        break;
      case Ug:
        if (
          f.tag === 5 &&
          ((f = f.memoizedProps["data-testname"]),
          typeof f == "string" && f.toLowerCase() === h.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function IA(f) {
    switch (f.$$typeof) {
      case Fg:
        return "<" + (P(f.value) || "Unknown") + ">";
      case Ng:
        return ":has(" + (IA(f) || "") + ")";
      case Og:
        return '[role="' + f.value + '"]';
      case kg:
        return '"' + f.value + '"';
      case Ug:
        return '[data-testname="' + f.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function uR(f, h) {
    var y = [];
    f = [f, 0];
    for (var M = 0; M < f.length; ) {
      var E = f[M++],
        B = f[M++],
        H = h[B];
      if (E.tag !== 5 || !fe(E)) {
        for (; H != null && BA(E, H); ) B++, (H = h[B]);
        if (B === h.length) y.push(E);
        else for (E = E.child; E !== null; ) f.push(E, B), (E = E.sibling);
      }
    }
    return y;
  }
  function DA(f, h) {
    if (!Le) throw Error(o(363));
    (f = PA(f)), (f = uR(f, h)), (h = []), (f = Array.from(f));
    for (var y = 0; y < f.length; ) {
      var M = f[y++];
      if (M.tag === 5) fe(M) || h.push(M.stateNode);
      else for (M = M.child; M !== null; ) f.push(M), (M = M.sibling);
    }
    return h;
  }
  var $z = Math.ceil,
    zg = a.ReactCurrentDispatcher,
    LA = a.ReactCurrentOwner,
    jn = a.ReactCurrentBatchConfig,
    zt = 0,
    ei = null,
    ti = null,
    Ii = 0,
    es = 0,
    $c = pt(0),
    ui = 0,
    dd = null,
    ef = 0,
    Hg = 0,
    FA = 0,
    pd = null,
    Rr = null,
    NA = 0,
    OA = 1 / 0;
  function tf() {
    OA = xi() + 500;
  }
  var Gg = !1,
    UA = null,
    Ya = null,
    Vg = !1,
    Ka = null,
    Wg = 0,
    md = 0,
    kA = null,
    Xg = -1,
    Jg = 0;
  function ar() {
    return zt & 6 ? xi() : Xg !== -1 ? Xg : (Xg = xi());
  }
  function Qa(f) {
    return f.mode & 1
      ? zt & 2 && Ii !== 0
        ? Ii & -Ii
        : Fz.transition !== null
        ? (Jg === 0 &&
            ((f = li), (li <<= 1), !(li & 4194240) && (li = 64), (Jg = f)),
          Jg)
        : ((f = an), f !== 0 ? f : we())
      : 1;
  }
  function Ps(f, h, y) {
    if (50 < md) throw ((md = 0), (kA = null), Error(o(185)));
    var M = jg(f, h);
    return M === null
      ? null
      : (qh(M, h, y),
        (!(zt & 2) || M !== ei) &&
          (M === ei && (!(zt & 2) && (Hg |= h), ui === 4 && Za(M, Ii)),
          Pr(M, y),
          h === 1 && zt === 0 && !(f.mode & 1) && (tf(), ug && Co())),
        M);
  }
  function jg(f, h) {
    f.lanes |= h;
    var y = f.alternate;
    for (y !== null && (y.lanes |= h), y = f, f = f.return; f !== null; )
      (f.childLanes |= h),
        (y = f.alternate),
        y !== null && (y.childLanes |= h),
        (y = f),
        (f = f.return);
    return y.tag === 3 ? y.stateNode : null;
  }
  function Pr(f, h) {
    var y = f.callbackNode;
    Tz(f, h);
    var M = ag(f, f === ei ? Ii : 0);
    if (M === 0)
      y !== null && KC(y), (f.callbackNode = null), (f.callbackPriority = 0);
    else if (((h = M & -M), f.callbackPriority !== h)) {
      if ((y != null && KC(y), h === 1))
        f.tag === 0 ? Lz(fR.bind(null, f)) : QC(fR.bind(null, f)),
          Te
            ? st(function () {
                zt === 0 && Co();
              })
            : jx(Yx, Co),
          (y = null);
      else {
        switch (YC(M)) {
          case 1:
            y = Yx;
            break;
          case 4:
            y = Pz;
            break;
          case 16:
            y = Kx;
            break;
          case 536870912:
            y = Bz;
            break;
          default:
            y = Kx;
        }
        y = xR(y, cR.bind(null, f));
      }
      (f.callbackPriority = h), (f.callbackNode = y);
    }
  }
  function cR(f, h) {
    if (((Xg = -1), (Jg = 0), zt & 6)) throw Error(o(327));
    var y = f.callbackNode;
    if (lu() && f.callbackNode !== y) return null;
    var M = ag(f, f === ei ? Ii : 0);
    if (M === 0) return null;
    if (M & 30 || M & f.expiredLanes || h) h = Yg(f, M);
    else {
      h = M;
      var E = zt;
      zt |= 2;
      var B = pR();
      (ei !== f || Ii !== h) && (tf(), ou(f, h));
      do
        try {
          n4();
          break;
        } catch (ee) {
          dR(f, ee);
        }
      while (1);
      qx(),
        (zg.current = B),
        (zt = E),
        ti !== null ? (h = 0) : ((ei = null), (Ii = 0), (h = ui));
    }
    if (h !== 0) {
      if (
        (h === 2 && ((E = Wx(f)), E !== 0 && ((M = E), (h = zA(f, E)))),
        h === 1)
      )
        throw ((y = dd), ou(f, 0), Za(f, M), Pr(f, xi()), y);
      if (h === 6) Za(f, M);
      else {
        if (
          ((E = f.current.alternate),
          !(M & 30) &&
            !e4(E) &&
            ((h = Yg(f, M)),
            h === 2 && ((B = Wx(f)), B !== 0 && ((M = B), (h = zA(f, B)))),
            h === 1))
        )
          throw ((y = dd), ou(f, 0), Za(f, M), Pr(f, xi()), y);
        switch (((f.finishedWork = E), (f.finishedLanes = M), h)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            au(f, Rr);
            break;
          case 3:
            if (
              (Za(f, M),
              (M & 130023424) === M && ((h = NA + 500 - xi()), 10 < h))
            ) {
              if (ag(f, 0) !== 0) break;
              if (((E = f.suspendedLanes), (E & M) !== M)) {
                ar(), (f.pingedLanes |= f.suspendedLanes & E);
                break;
              }
              f.timeoutHandle = Se(au.bind(null, f, Rr), h);
              break;
            }
            au(f, Rr);
            break;
          case 4:
            if ((Za(f, M), (M & 4194240) === M)) break;
            for (h = f.eventTimes, E = -1; 0 < M; ) {
              var H = 31 - Kt(M);
              (B = 1 << H), (H = h[H]), H > E && (E = H), (M &= ~B);
            }
            if (
              ((M = E),
              (M = xi() - M),
              (M =
                (120 > M
                  ? 120
                  : 480 > M
                  ? 480
                  : 1080 > M
                  ? 1080
                  : 1920 > M
                  ? 1920
                  : 3e3 > M
                  ? 3e3
                  : 4320 > M
                  ? 4320
                  : 1960 * $z(M / 1960)) - M),
              10 < M)
            ) {
              f.timeoutHandle = Se(au.bind(null, f, Rr), M);
              break;
            }
            au(f, Rr);
            break;
          case 5:
            au(f, Rr);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Pr(f, xi()), f.callbackNode === y ? cR.bind(null, f) : null;
  }
  function zA(f, h) {
    var y = pd;
    return (
      f.current.memoizedState.isDehydrated && (ou(f, h).flags |= 256),
      (f = Yg(f, h)),
      f !== 2 && ((h = Rr), (Rr = y), h !== null && HA(h)),
      f
    );
  }
  function HA(f) {
    Rr === null ? (Rr = f) : Rr.push.apply(Rr, f);
  }
  function e4(f) {
    for (var h = f; ; ) {
      if (h.flags & 16384) {
        var y = h.updateQueue;
        if (y !== null && ((y = y.stores), y !== null))
          for (var M = 0; M < y.length; M++) {
            var E = y[M],
              B = E.getSnapshot;
            E = E.value;
            try {
              if (!To(B(), E)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((y = h.child), h.subtreeFlags & 16384 && y !== null))
        (y.return = h), (h = y);
      else {
        if (h === f) break;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === f) return !0;
          h = h.return;
        }
        (h.sibling.return = h.return), (h = h.sibling);
      }
    }
    return !0;
  }
  function Za(f, h) {
    for (
      h &= ~FA,
        h &= ~Hg,
        f.suspendedLanes |= h,
        f.pingedLanes &= ~h,
        f = f.expirationTimes;
      0 < h;

    ) {
      var y = 31 - Kt(h),
        M = 1 << y;
      (f[y] = -1), (h &= ~M);
    }
  }
  function fR(f) {
    if (zt & 6) throw Error(o(327));
    lu();
    var h = ag(f, 0);
    if (!(h & 1)) return Pr(f, xi()), null;
    var y = Yg(f, h);
    if (f.tag !== 0 && y === 2) {
      var M = Wx(f);
      M !== 0 && ((h = M), (y = zA(f, M)));
    }
    if (y === 1) throw ((y = dd), ou(f, 0), Za(f, h), Pr(f, xi()), y);
    if (y === 6) throw Error(o(345));
    return (
      (f.finishedWork = f.current.alternate),
      (f.finishedLanes = h),
      au(f, Rr),
      Pr(f, xi()),
      null
    );
  }
  function hR(f) {
    Ka !== null && Ka.tag === 0 && !(zt & 6) && lu();
    var h = zt;
    zt |= 1;
    var y = jn.transition,
      M = an;
    try {
      if (((jn.transition = null), (an = 1), f)) return f();
    } finally {
      (an = M), (jn.transition = y), (zt = h), !(zt & 6) && Co();
    }
  }
  function GA() {
    (es = $c.current), Ge($c);
  }
  function ou(f, h) {
    (f.finishedWork = null), (f.finishedLanes = 0);
    var y = f.timeoutHandle;
    if ((y !== et && ((f.timeoutHandle = et), Xe(y)), ti !== null))
      for (y = ti.return; y !== null; ) {
        var M = y;
        switch ((sA(M), M.tag)) {
          case 1:
            (M = M.type.childContextTypes), M != null && Qt();
            break;
          case 3:
            Zc(), Ge(Jt), Ge(Xt), hA();
            break;
          case 5:
            cA(M);
            break;
          case 4:
            Zc();
            break;
          case 13:
            Ge(In);
            break;
          case 19:
            Ge(In);
            break;
          case 10:
            $x(M.type._context);
            break;
          case 22:
          case 23:
            GA();
        }
        y = y.return;
      }
    if (
      ((ei = f),
      (ti = f = qa(f.current, null)),
      (Ii = es = h),
      (ui = 0),
      (dd = null),
      (FA = Hg = ef = 0),
      (Rr = pd = null),
      bo !== null)
    ) {
      for (h = 0; h < bo.length; h++)
        if (((y = bo[h]), (M = y.interleaved), M !== null)) {
          y.interleaved = null;
          var E = M.next,
            B = y.pending;
          if (B !== null) {
            var H = B.next;
            (B.next = E), (M.next = H);
          }
          y.pending = M;
        }
      bo = null;
    }
    return f;
  }
  function dR(f, h) {
    do {
      var y = ti;
      try {
        if ((qx(), (xg.current = Tg), Ag)) {
          for (var M = zn.memoizedState; M !== null; ) {
            var E = M.queue;
            E !== null && (E.pending = null), (M = M.next);
          }
          Ag = !1;
        }
        if (
          ((qc = 0),
          (Ai = ki = zn = null),
          (rd = !1),
          (sd = 0),
          (LA.current = null),
          y === null || y.return === null)
        ) {
          (ui = 1), (dd = h), (ti = null);
          break;
        }
        e: {
          var B = f,
            H = y.return,
            ee = y,
            ve = h;
          if (
            ((h = Ii),
            (ee.flags |= 32768),
            ve !== null &&
              typeof ve == "object" &&
              typeof ve.then == "function")
          ) {
            var Oe = ve,
              at = ee,
              Pt = at.tag;
            if (!(at.mode & 1) && (Pt === 0 || Pt === 11 || Pt === 15)) {
              var xt = at.alternate;
              xt
                ? ((at.updateQueue = xt.updateQueue),
                  (at.memoizedState = xt.memoizedState),
                  (at.lanes = xt.lanes))
                : ((at.updateQueue = null), (at.memoizedState = null));
            }
            var yn = Lb(H);
            if (yn !== null) {
              (yn.flags &= -257),
                Fb(yn, H, ee, B, h),
                yn.mode & 1 && Db(B, Oe, h),
                (h = yn),
                (ve = Oe);
              var yt = h.updateQueue;
              if (yt === null) {
                var Gi = new Set();
                Gi.add(ve), (h.updateQueue = Gi);
              } else yt.add(ve);
              break e;
            } else {
              if (!(h & 1)) {
                Db(B, Oe, h), VA();
                break e;
              }
              ve = Error(o(426));
            }
          } else if (Tn && ee.mode & 1) {
            var Is = Lb(H);
            if (Is !== null) {
              !(Is.flags & 65536) && (Is.flags |= 256),
                Fb(Is, H, ee, B, h),
                lA(ve);
              break e;
            }
          }
          (B = ve),
            ui !== 4 && (ui = 2),
            pd === null ? (pd = [B]) : pd.push(B),
            (ve = _A(ve, ee)),
            (ee = H);
          do {
            switch (ee.tag) {
              case 3:
                (ee.flags |= 65536), (h &= -h), (ee.lanes |= h);
                var le = Bb(ee, ve, h);
                $C(ee, le);
                break e;
              case 1:
                B = ve;
                var ne = ee.type,
                  he = ee.stateNode;
                if (
                  !(ee.flags & 128) &&
                  (typeof ne.getDerivedStateFromError == "function" ||
                    (he !== null &&
                      typeof he.componentDidCatch == "function" &&
                      (Ya === null || !Ya.has(he))))
                ) {
                  (ee.flags |= 65536), (h &= -h), (ee.lanes |= h);
                  var tt = Ib(ee, B, h);
                  $C(ee, tt);
                  break e;
                }
            }
            ee = ee.return;
          } while (ee !== null);
        }
        gR(y);
      } catch (vt) {
        (h = vt), ti === y && y !== null && (ti = y = y.return);
        continue;
      }
      break;
    } while (1);
  }
  function pR() {
    var f = zg.current;
    return (zg.current = Tg), f === null ? Tg : f;
  }
  function VA() {
    (ui === 0 || ui === 3 || ui === 2) && (ui = 4),
      ei === null || (!(ef & 268435455) && !(Hg & 268435455)) || Za(ei, Ii);
  }
  function Yg(f, h) {
    var y = zt;
    zt |= 2;
    var M = pR();
    (ei === f && Ii === h) || ou(f, h);
    do
      try {
        t4();
        break;
      } catch (E) {
        dR(f, E);
      }
    while (1);
    if ((qx(), (zt = y), (zg.current = M), ti !== null)) throw Error(o(261));
    return (ei = null), (Ii = 0), ui;
  }
  function t4() {
    for (; ti !== null; ) mR(ti);
  }
  function n4() {
    for (; ti !== null && !bz(); ) mR(ti);
  }
  function mR(f) {
    var h = _R(f.alternate, f, es);
    (f.memoizedProps = f.pendingProps),
      h === null ? gR(f) : (ti = h),
      (LA.current = null);
  }
  function gR(f) {
    var h = f;
    do {
      var y = h.alternate;
      if (((f = h.return), h.flags & 32768)) {
        if (((y = Yz(y, h)), y !== null)) {
          (y.flags &= 32767), (ti = y);
          return;
        }
        if (f !== null)
          (f.flags |= 32768), (f.subtreeFlags = 0), (f.deletions = null);
        else {
          (ui = 6), (ti = null);
          return;
        }
      } else if (((y = Xz(y, h, es)), y !== null)) {
        ti = y;
        return;
      }
      if (((h = h.sibling), h !== null)) {
        ti = h;
        return;
      }
      ti = h = f;
    } while (h !== null);
    ui === 0 && (ui = 5);
  }
  function au(f, h) {
    var y = an,
      M = jn.transition;
    try {
      (jn.transition = null), (an = 1), i4(f, h, y);
    } finally {
      (jn.transition = M), (an = y);
    }
    return null;
  }
  function i4(f, h, y) {
    do lu();
    while (Ka !== null);
    if (zt & 6) throw Error(o(327));
    var M = f.finishedWork,
      E = f.finishedLanes;
    if (M === null) return null;
    if (((f.finishedWork = null), (f.finishedLanes = 0), M === f.current))
      throw Error(o(177));
    (f.callbackNode = null), (f.callbackPriority = 0);
    var B = M.lanes | M.childLanes;
    if (
      (Cz(f, B),
      f === ei && ((ti = ei = null), (Ii = 0)),
      (!(M.subtreeFlags & 2064) && !(M.flags & 2064)) ||
        Vg ||
        ((Vg = !0),
        xR(Kx, function () {
          return lu(), null;
        })),
      (B = (M.flags & 15990) !== 0),
      M.subtreeFlags & 15990 || B)
    ) {
      (B = jn.transition), (jn.transition = null);
      var H = an;
      an = 1;
      var ee = zt;
      (zt |= 4),
        (LA.current = null),
        Qz(f, M),
        Zz(f, M),
        F(f.containerInfo),
        (f.current = M),
        qz(M),
        Rz(),
        (zt = ee),
        (an = H),
        (jn.transition = B);
    } else f.current = M;
    if (
      (Vg && ((Vg = !1), (Ka = f), (Wg = E)),
      (B = f.pendingLanes),
      B === 0 && (Ya = null),
      Iz(M.stateNode),
      Pr(f, xi()),
      h !== null)
    )
      for (y = f.onRecoverableError, M = 0; M < h.length; M++) y(h[M]);
    if (Gg) throw ((Gg = !1), (f = UA), (UA = null), f);
    return (
      Wg & 1 && f.tag !== 0 && lu(),
      (B = f.pendingLanes),
      B & 1 ? (f === kA ? md++ : ((md = 0), (kA = f))) : (md = 0),
      Co(),
      null
    );
  }
  function lu() {
    if (Ka !== null) {
      var f = YC(Wg),
        h = jn.transition,
        y = an;
      try {
        if (((jn.transition = null), (an = 16 > f ? 16 : f), Ka === null))
          var M = !1;
        else {
          if (((f = Ka), (Ka = null), (Wg = 0), zt & 6)) throw Error(o(331));
          var E = zt;
          for (zt |= 4, qe = f.current; qe !== null; ) {
            var B = qe,
              H = B.child;
            if (qe.flags & 16) {
              var ee = B.deletions;
              if (ee !== null) {
                for (var ve = 0; ve < ee.length; ve++) {
                  var Oe = ee[ve];
                  for (qe = Oe; qe !== null; ) {
                    var at = qe;
                    switch (at.tag) {
                      case 0:
                      case 11:
                      case 15:
                        su(8, at, B);
                    }
                    var Pt = at.child;
                    if (Pt !== null) (Pt.return = at), (qe = Pt);
                    else
                      for (; qe !== null; ) {
                        at = qe;
                        var xt = at.sibling,
                          yn = at.return;
                        if ((eR(at), at === Oe)) {
                          qe = null;
                          break;
                        }
                        if (xt !== null) {
                          (xt.return = yn), (qe = xt);
                          break;
                        }
                        qe = yn;
                      }
                  }
                }
                var yt = B.alternate;
                if (yt !== null) {
                  var Gi = yt.child;
                  if (Gi !== null) {
                    yt.child = null;
                    do {
                      var Is = Gi.sibling;
                      (Gi.sibling = null), (Gi = Is);
                    } while (Gi !== null);
                  }
                }
                qe = B;
              }
            }
            if (B.subtreeFlags & 2064 && H !== null) (H.return = B), (qe = H);
            else
              e: for (; qe !== null; ) {
                if (((B = qe), B.flags & 2048))
                  switch (B.tag) {
                    case 0:
                    case 11:
                    case 15:
                      su(9, B, B.return);
                  }
                var le = B.sibling;
                if (le !== null) {
                  (le.return = B.return), (qe = le);
                  break e;
                }
                qe = B.return;
              }
          }
          var ne = f.current;
          for (qe = ne; qe !== null; ) {
            H = qe;
            var he = H.child;
            if (H.subtreeFlags & 2064 && he !== null)
              (he.return = H), (qe = he);
            else
              e: for (H = ne; qe !== null; ) {
                if (((ee = qe), ee.flags & 2048))
                  try {
                    switch (ee.tag) {
                      case 0:
                      case 11:
                      case 15:
                        fd(9, ee);
                    }
                  } catch (vt) {
                    Br(ee, ee.return, vt);
                  }
                if (ee === H) {
                  qe = null;
                  break e;
                }
                var tt = ee.sibling;
                if (tt !== null) {
                  (tt.return = ee.return), (qe = tt);
                  break e;
                }
                qe = ee.return;
              }
          }
          if (
            ((zt = E),
            Co(),
            Eo && typeof Eo.onPostCommitFiberRoot == "function")
          )
            try {
              Eo.onPostCommitFiberRoot(lg, f);
            } catch {}
          M = !0;
        }
        return M;
      } finally {
        (an = y), (jn.transition = h);
      }
    }
    return !1;
  }
  function vR(f, h, y) {
    (h = _A(y, h)),
      (h = Bb(f, h, 1)),
      ja(f, h),
      (h = ar()),
      (f = jg(f, 1)),
      f !== null && (qh(f, 1, h), Pr(f, h));
  }
  function Br(f, h, y) {
    if (f.tag === 3) vR(f, f, y);
    else
      for (; h !== null; ) {
        if (h.tag === 3) {
          vR(h, f, y);
          break;
        } else if (h.tag === 1) {
          var M = h.stateNode;
          if (
            typeof h.type.getDerivedStateFromError == "function" ||
            (typeof M.componentDidCatch == "function" &&
              (Ya === null || !Ya.has(M)))
          ) {
            (f = _A(y, f)),
              (f = Ib(h, f, 1)),
              ja(h, f),
              (f = ar()),
              (h = jg(h, 1)),
              h !== null && (qh(h, 1, f), Pr(h, f));
            break;
          }
        }
        h = h.return;
      }
  }
  function r4(f, h, y) {
    var M = f.pingCache;
    M !== null && M.delete(h),
      (h = ar()),
      (f.pingedLanes |= f.suspendedLanes & y),
      ei === f &&
        (Ii & y) === y &&
        (ui === 4 || (ui === 3 && (Ii & 130023424) === Ii && 500 > xi() - NA)
          ? ou(f, 0)
          : (FA |= y)),
      Pr(f, h);
  }
  function yR(f, h) {
    h === 0 &&
      (f.mode & 1
        ? ((h = Xa), (Xa <<= 1), !(Xa & 130023424) && (Xa = 4194304))
        : (h = 1));
    var y = ar();
    (f = jg(f, h)), f !== null && (qh(f, h, y), Pr(f, y));
  }
  function s4(f) {
    var h = f.memoizedState,
      y = 0;
    h !== null && (y = h.retryLane), yR(f, y);
  }
  function o4(f, h) {
    var y = 0;
    switch (f.tag) {
      case 13:
        var M = f.stateNode,
          E = f.memoizedState;
        E !== null && (y = E.retryLane);
        break;
      case 19:
        M = f.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    M !== null && M.delete(h), yR(f, y);
  }
  var _R;
  _R = function (f, h, y) {
    if (f !== null)
      if (f.memoizedProps !== h.pendingProps || Jt.current) $r = !0;
      else {
        if (!(f.lanes & y) && !(h.flags & 128)) return ($r = !1), jz(f, h, y);
        $r = !!(f.flags & 131072);
      }
    else ($r = !1), Tn && h.flags & 1048576 && sb(h, vg, h.index);
    switch (((h.lanes = 0), h.tag)) {
      case 2:
        var M = h.type;
        f !== null &&
          ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
          (f = h.pendingProps);
        var E = gt(h, Xt.current);
        Xc(h, y), (E = pA(null, h, M, f, E, y));
        var B = mA();
        return (
          (h.flags |= 1),
          typeof E == "object" &&
          E !== null &&
          typeof E.render == "function" &&
          E.$$typeof === void 0
            ? ((h.tag = 1),
              (h.memoizedState = null),
              (h.updateQueue = null),
              on(M) ? ((B = !0), _i(h)) : (B = !1),
              (h.memoizedState =
                E.state !== null && E.state !== void 0 ? E.state : null),
              tA(h),
              (E.updater = mg),
              (h.stateNode = E),
              (E._reactInternals = h),
              iA(h, M, f, y),
              (h = SA(null, h, M, !0, B, y)))
            : ((h.tag = 0), Tn && B && rA(h), or(null, h, E, y), (h = h.child)),
          h
        );
      case 16:
        M = h.elementType;
        e: {
          switch (
            (f !== null &&
              ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
            (f = h.pendingProps),
            (E = M._init),
            (M = E(M._payload)),
            (h.type = M),
            (E = h.tag = l4(M)),
            (f = to(M, f)),
            E)
          ) {
            case 0:
              h = AA(null, h, M, f, y);
              break e;
            case 1:
              h = Vb(null, h, M, f, y);
              break e;
            case 11:
              h = Ub(null, h, M, f, y);
              break e;
            case 14:
              h = kb(null, h, M, to(M.type, f), y);
              break e;
          }
          throw Error(o(306, M, ""));
        }
        return h;
      case 0:
        return (
          (M = h.type),
          (E = h.pendingProps),
          (E = h.elementType === M ? E : to(M, E)),
          AA(f, h, M, E, y)
        );
      case 1:
        return (
          (M = h.type),
          (E = h.pendingProps),
          (E = h.elementType === M ? E : to(M, E)),
          Vb(f, h, M, E, y)
        );
      case 3:
        e: {
          if ((Wb(h), f === null)) throw Error(o(387));
          (M = h.pendingProps),
            (B = h.memoizedState),
            (E = B.element),
            qC(f, h),
            pg(h, M, null, y);
          var H = h.memoizedState;
          if (((M = H.element), ce && B.isDehydrated))
            if (
              ((B = {
                element: M,
                isDehydrated: !1,
                cache: H.cache,
                transitions: H.transitions,
              }),
              (h.updateQueue.baseState = B),
              (h.memoizedState = B),
              h.flags & 256)
            ) {
              (E = Error(o(423))), (h = Xb(f, h, M, y, E));
              break e;
            } else if (M !== E) {
              (E = Error(o(424))), (h = Xb(f, h, M, y, E));
              break e;
            } else
              for (
                ce &&
                  ((qr = Wn(h.stateNode.containerInfo)),
                  (Zr = h),
                  (Tn = !0),
                  (no = null),
                  ($h = !1)),
                  y = fb(h, null, M, y),
                  h.child = y;
                y;

              )
                (y.flags = (y.flags & -3) | 4096), (y = y.sibling);
          else {
            if ((Yc(), M === E)) {
              h = ra(f, h, y);
              break e;
            }
            or(f, h, M, y);
          }
          h = h.child;
        }
        return h;
      case 5:
        return (
          hb(h),
          f === null && aA(h),
          (M = h.type),
          (E = h.pendingProps),
          (B = f !== null ? f.memoizedProps : null),
          (H = E.children),
          xe(M, E) ? (H = null) : B !== null && xe(M, B) && (h.flags |= 32),
          Gb(f, h),
          or(f, h, H, y),
          h.child
        );
      case 6:
        return f === null && aA(h), null;
      case 13:
        return Jb(f, h, y);
      case 4:
        return (
          uA(h, h.stateNode.containerInfo),
          (M = h.pendingProps),
          f === null ? (h.child = Kc(h, null, M, y)) : or(f, h, M, y),
          h.child
        );
      case 11:
        return (
          (M = h.type),
          (E = h.pendingProps),
          (E = h.elementType === M ? E : to(M, E)),
          Ub(f, h, M, E, y)
        );
      case 7:
        return or(f, h, h.pendingProps, y), h.child;
      case 8:
        return or(f, h, h.pendingProps.children, y), h.child;
      case 12:
        return or(f, h, h.pendingProps.children, y), h.child;
      case 10:
        e: {
          if (
            ((M = h.type._context),
            (E = h.pendingProps),
            (B = h.memoizedProps),
            (H = E.value),
            ZC(h, M, H),
            B !== null)
          )
            if (To(B.value, H)) {
              if (B.children === E.children && !Jt.current) {
                h = ra(f, h, y);
                break e;
              }
            } else
              for (B = h.child, B !== null && (B.return = h); B !== null; ) {
                var ee = B.dependencies;
                if (ee !== null) {
                  H = B.child;
                  for (var ve = ee.firstContext; ve !== null; ) {
                    if (ve.context === M) {
                      if (B.tag === 1) {
                        (ve = ea(-1, y & -y)), (ve.tag = 2);
                        var Oe = B.updateQueue;
                        if (Oe !== null) {
                          Oe = Oe.shared;
                          var at = Oe.pending;
                          at === null
                            ? (ve.next = ve)
                            : ((ve.next = at.next), (at.next = ve)),
                            (Oe.pending = ve);
                        }
                      }
                      (B.lanes |= y),
                        (ve = B.alternate),
                        ve !== null && (ve.lanes |= y),
                        eA(B.return, y, h),
                        (ee.lanes |= y);
                      break;
                    }
                    ve = ve.next;
                  }
                } else if (B.tag === 10) H = B.type === h.type ? null : B.child;
                else if (B.tag === 18) {
                  if (((H = B.return), H === null)) throw Error(o(341));
                  (H.lanes |= y),
                    (ee = H.alternate),
                    ee !== null && (ee.lanes |= y),
                    eA(H, y, h),
                    (H = B.sibling);
                } else H = B.child;
                if (H !== null) H.return = B;
                else
                  for (H = B; H !== null; ) {
                    if (H === h) {
                      H = null;
                      break;
                    }
                    if (((B = H.sibling), B !== null)) {
                      (B.return = H.return), (H = B);
                      break;
                    }
                    H = H.return;
                  }
                B = H;
              }
          or(f, h, E.children, y), (h = h.child);
        }
        return h;
      case 9:
        return (
          (E = h.type),
          (M = h.pendingProps.children),
          Xc(h, y),
          (E = Es(E)),
          (M = M(E)),
          (h.flags |= 1),
          or(f, h, M, y),
          h.child
        );
      case 14:
        return (
          (M = h.type),
          (E = to(M, h.pendingProps)),
          (E = to(M.type, E)),
          kb(f, h, M, E, y)
        );
      case 15:
        return zb(f, h, h.type, h.pendingProps, y);
      case 17:
        return (
          (M = h.type),
          (E = h.pendingProps),
          (E = h.elementType === M ? E : to(M, E)),
          f !== null &&
            ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
          (h.tag = 1),
          on(M) ? ((f = !0), _i(h)) : (f = !1),
          Xc(h, y),
          ib(h, M, E),
          iA(h, M, E, y),
          SA(null, h, M, !0, f, y)
        );
      case 19:
        return Qb(f, h, y);
      case 22:
        return Hb(f, h, y);
    }
    throw Error(o(156, h.tag));
  };
  function xR(f, h) {
    return jx(f, h);
  }
  function a4(f, h, y, M) {
    (this.tag = f),
      (this.key = y),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = h),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = M),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Bs(f, h, y, M) {
    return new a4(f, h, y, M);
  }
  function WA(f) {
    return (f = f.prototype), !(!f || !f.isReactComponent);
  }
  function l4(f) {
    if (typeof f == "function") return WA(f) ? 1 : 0;
    if (f != null) {
      if (((f = f.$$typeof), f === _)) return 11;
      if (f === A) return 14;
    }
    return 2;
  }
  function qa(f, h) {
    var y = f.alternate;
    return (
      y === null
        ? ((y = Bs(f.tag, h, f.key, f.mode)),
          (y.elementType = f.elementType),
          (y.type = f.type),
          (y.stateNode = f.stateNode),
          (y.alternate = f),
          (f.alternate = y))
        : ((y.pendingProps = h),
          (y.type = f.type),
          (y.flags = 0),
          (y.subtreeFlags = 0),
          (y.deletions = null)),
      (y.flags = f.flags & 14680064),
      (y.childLanes = f.childLanes),
      (y.lanes = f.lanes),
      (y.child = f.child),
      (y.memoizedProps = f.memoizedProps),
      (y.memoizedState = f.memoizedState),
      (y.updateQueue = f.updateQueue),
      (h = f.dependencies),
      (y.dependencies =
        h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }),
      (y.sibling = f.sibling),
      (y.index = f.index),
      (y.ref = f.ref),
      y
    );
  }
  function Kg(f, h, y, M, E, B) {
    var H = 2;
    if (((M = f), typeof f == "function")) WA(f) && (H = 1);
    else if (typeof f == "string") H = 5;
    else
      e: switch (f) {
        case c:
          return uu(y.children, E, B, h);
        case d:
          (H = 8), (E |= 8);
          break;
        case p:
          return (
            (f = Bs(12, y, h, E | 2)), (f.elementType = p), (f.lanes = B), f
          );
        case x:
          return (f = Bs(13, y, h, E)), (f.elementType = x), (f.lanes = B), f;
        case g:
          return (f = Bs(19, y, h, E)), (f.elementType = g), (f.lanes = B), f;
        case w:
          return Qg(y, E, B, h);
        default:
          if (typeof f == "object" && f !== null)
            switch (f.$$typeof) {
              case m:
                H = 10;
                break e;
              case v:
                H = 9;
                break e;
              case _:
                H = 11;
                break e;
              case A:
                H = 14;
                break e;
              case S:
                (H = 16), (M = null);
                break e;
            }
          throw Error(o(130, f == null ? f : typeof f, ""));
      }
    return (
      (h = Bs(H, y, h, E)), (h.elementType = f), (h.type = M), (h.lanes = B), h
    );
  }
  function uu(f, h, y, M) {
    return (f = Bs(7, f, M, h)), (f.lanes = y), f;
  }
  function Qg(f, h, y, M) {
    return (
      (f = Bs(22, f, M, h)),
      (f.elementType = w),
      (f.lanes = y),
      (f.stateNode = {}),
      f
    );
  }
  function XA(f, h, y) {
    return (f = Bs(6, f, null, h)), (f.lanes = y), f;
  }
  function JA(f, h, y) {
    return (
      (h = Bs(4, f.children !== null ? f.children : [], f.key, h)),
      (h.lanes = y),
      (h.stateNode = {
        containerInfo: f.containerInfo,
        pendingChildren: null,
        implementation: f.implementation,
      }),
      h
    );
  }
  function u4(f, h, y, M, E) {
    (this.tag = h),
      (this.containerInfo = f),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = et),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Xx(0)),
      (this.expirationTimes = Xx(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Xx(0)),
      (this.identifierPrefix = M),
      (this.onRecoverableError = E),
      ce && (this.mutableSourceEagerHydrationData = null);
  }
  function AR(f, h, y, M, E, B, H, ee, ve) {
    return (
      (f = new u4(f, h, y, ee, ve)),
      h === 1 ? ((h = 1), B === !0 && (h |= 8)) : (h = 0),
      (B = Bs(3, null, null, h)),
      (f.current = B),
      (B.stateNode = f),
      (B.memoizedState = {
        element: M,
        isDehydrated: y,
        cache: null,
        transitions: null,
      }),
      tA(B),
      f
    );
  }
  function SR(f) {
    if (!f) return kt;
    f = f._reactInternals;
    e: {
      if (R(f) !== f || f.tag !== 1) throw Error(o(170));
      var h = f;
      do {
        switch (h.tag) {
          case 3:
            h = h.stateNode.context;
            break e;
          case 1:
            if (on(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        h = h.return;
      } while (h !== null);
      throw Error(o(171));
    }
    if (f.tag === 1) {
      var y = f.type;
      if (on(y)) return qo(f, y, h);
    }
    return h;
  }
  function MR(f) {
    var h = f._reactInternals;
    if (h === void 0)
      throw typeof f.render == "function"
        ? Error(o(188))
        : ((f = Object.keys(f).join(",")), Error(o(268, f)));
    return (f = G(h)), f === null ? null : f.stateNode;
  }
  function wR(f, h) {
    if (((f = f.memoizedState), f !== null && f.dehydrated !== null)) {
      var y = f.retryLane;
      f.retryLane = y !== 0 && y < h ? y : h;
    }
  }
  function jA(f, h) {
    wR(f, h), (f = f.alternate) && wR(f, h);
  }
  function c4(f) {
    return (f = G(f)), f === null ? null : f.stateNode;
  }
  function f4() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (f) {
      if (f.tag === 13) {
        var h = ar();
        Ps(f, 134217728, h), jA(f, 134217728);
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (f) {
      if (f.tag === 13) {
        var h = ar(),
          y = Qa(f);
        Ps(f, y, h), jA(f, y);
      }
    }),
    (t.attemptSynchronousHydration = function (f) {
      switch (f.tag) {
        case 3:
          var h = f.stateNode;
          if (h.current.memoizedState.isDehydrated) {
            var y = Qr(h.pendingLanes);
            y !== 0 && (Jx(h, y | 1), Pr(h, xi()), !(zt & 6) && (tf(), Co()));
          }
          break;
        case 13:
          var M = ar();
          hR(function () {
            return Ps(f, 1, M);
          }),
            jA(f, 1);
      }
    }),
    (t.batchedUpdates = function (f, h) {
      var y = zt;
      zt |= 1;
      try {
        return f(h);
      } finally {
        (zt = y), zt === 0 && (tf(), ug && Co());
      }
    }),
    (t.createComponentSelector = function (f) {
      return { $$typeof: Fg, value: f };
    }),
    (t.createContainer = function (f, h, y, M, E, B, H) {
      return AR(f, h, !1, null, y, M, E, B, H);
    }),
    (t.createHasPseudoClassSelector = function (f) {
      return { $$typeof: Ng, value: f };
    }),
    (t.createHydrationContainer = function (f, h, y, M, E, B, H, ee, ve) {
      return (
        (f = AR(y, M, !0, f, E, B, H, ee, ve)),
        (f.context = SR(null)),
        (y = f.current),
        (M = ar()),
        (E = Qa(y)),
        (B = ea(M, E)),
        (B.callback = h ?? null),
        ja(y, B),
        (f.current.lanes = E),
        qh(f, E, M),
        Pr(f, M),
        f
      );
    }),
    (t.createPortal = function (f, h, y) {
      var M =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: u,
        key: M == null ? null : "" + M,
        children: f,
        containerInfo: h,
        implementation: y,
      };
    }),
    (t.createRoleSelector = function (f) {
      return { $$typeof: Og, value: f };
    }),
    (t.createTestNameSelector = function (f) {
      return { $$typeof: Ug, value: f };
    }),
    (t.createTextSelector = function (f) {
      return { $$typeof: kg, value: f };
    }),
    (t.deferredUpdates = function (f) {
      var h = an,
        y = jn.transition;
      try {
        return (jn.transition = null), (an = 16), f();
      } finally {
        (an = h), (jn.transition = y);
      }
    }),
    (t.discreteUpdates = function (f, h, y, M, E) {
      var B = an,
        H = jn.transition;
      try {
        return (jn.transition = null), (an = 1), f(h, y, M, E);
      } finally {
        (an = B), (jn.transition = H), zt === 0 && tf();
      }
    }),
    (t.findAllNodes = DA),
    (t.findBoundingRects = function (f, h) {
      if (!Le) throw Error(o(363));
      (h = DA(f, h)), (f = []);
      for (var y = 0; y < h.length; y++) f.push(L(h[y]));
      for (h = f.length - 1; 0 < h; h--) {
        y = f[h];
        for (
          var M = y.x, E = M + y.width, B = y.y, H = B + y.height, ee = h - 1;
          0 <= ee;
          ee--
        )
          if (h !== ee) {
            var ve = f[ee],
              Oe = ve.x,
              at = Oe + ve.width,
              Pt = ve.y,
              xt = Pt + ve.height;
            if (M >= Oe && B >= Pt && E <= at && H <= xt) {
              f.splice(h, 1);
              break;
            } else if (M !== Oe || y.width !== ve.width || xt < B || Pt > H) {
              if (!(B !== Pt || y.height !== ve.height || at < M || Oe > E)) {
                Oe > M && ((ve.width += Oe - M), (ve.x = M)),
                  at < E && (ve.width = E - Oe),
                  f.splice(h, 1);
                break;
              }
            } else {
              Pt > B && ((ve.height += Pt - B), (ve.y = B)),
                xt < H && (ve.height = H - Pt),
                f.splice(h, 1);
              break;
            }
          }
      }
      return f;
    }),
    (t.findHostInstance = MR),
    (t.findHostInstanceWithNoPortals = function (f) {
      return (
        (f = D(f)),
        (f = f !== null ? q(f) : null),
        f === null ? null : f.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (f) {
      return MR(f);
    }),
    (t.flushControlled = function (f) {
      var h = zt;
      zt |= 1;
      var y = jn.transition,
        M = an;
      try {
        (jn.transition = null), (an = 1), f();
      } finally {
        (an = M), (jn.transition = y), (zt = h), zt === 0 && (tf(), Co());
      }
    }),
    (t.flushPassiveEffects = lu),
    (t.flushSync = hR),
    (t.focusWithin = function (f, h) {
      if (!Le) throw Error(o(363));
      for (f = PA(f), h = uR(f, h), h = Array.from(h), f = 0; f < h.length; ) {
        var y = h[f++];
        if (!fe(y)) {
          if (y.tag === 5 && me(y.stateNode)) return !0;
          for (y = y.child; y !== null; ) h.push(y), (y = y.sibling);
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return an;
    }),
    (t.getFindAllNodesFailureDescription = function (f, h) {
      if (!Le) throw Error(o(363));
      var y = 0,
        M = [];
      f = [PA(f), 0];
      for (var E = 0; E < f.length; ) {
        var B = f[E++],
          H = f[E++],
          ee = h[H];
        if (
          (B.tag !== 5 || !fe(B)) &&
          (BA(B, ee) && (M.push(IA(ee)), H++, H > y && (y = H)), H < h.length)
        )
          for (B = B.child; B !== null; ) f.push(B, H), (B = B.sibling);
      }
      if (y < h.length) {
        for (f = []; y < h.length; y++) f.push(IA(h[y]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (M.join(" > ") +
            `

No matching component was found for:
  `) +
          f.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (f) {
      if (((f = f.current), !f.child)) return null;
      switch (f.child.tag) {
        case 5:
          return K(f.child.stateNode);
        default:
          return f.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (f) {
      if (
        ((f = {
          bundleType: f.bundleType,
          version: f.version,
          rendererPackageName: f.rendererPackageName,
          rendererConfig: f.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: c4,
          findFiberByHostInstance: f.findFiberByHostInstance || f4,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        f = !1;
      else {
        var h = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (h.isDisabled || !h.supportsFiber) f = !0;
        else {
          try {
            (lg = h.inject(f)), (Eo = h);
          } catch {}
          f = !!h.checkDCE;
        }
      }
      return f;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (f, h, y, M) {
      if (!Le) throw Error(o(363));
      f = DA(f, h);
      var E = Pe(f, y, M).disconnect;
      return {
        disconnect: function () {
          E();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (f, h) {
      var y = h._getVersion;
      (y = y(h._source)),
        f.mutableSourceEagerHydrationData == null
          ? (f.mutableSourceEagerHydrationData = [h, y])
          : f.mutableSourceEagerHydrationData.push(h, y);
    }),
    (t.runWithPriority = function (f, h) {
      var y = an;
      try {
        return (an = f), h();
      } finally {
        an = y;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (f, h, y, M) {
      var E = h.current,
        B = ar(),
        H = Qa(E);
      return (
        (y = SR(y)),
        h.context === null ? (h.context = y) : (h.pendingContext = y),
        (h = ea(B, H)),
        (h.payload = { element: f }),
        (M = M === void 0 ? null : M),
        M !== null && (h.callback = M),
        ja(E, h),
        (f = Ps(E, H, B)),
        f !== null && dg(f, E, H),
        H
      );
    }),
    t
  );
};
lO.exports = TJ;
var CJ = lO.exports;
const bJ = VD(CJ),
  jT = {},
  RJ = (n) => void Object.assign(jT, n);
function PJ(n, e) {
  function t(c, { args: d = [], attach: p, ...m }, v) {
    let _ = `${c[0].toUpperCase()}${c.slice(1)}`,
      x;
    if (c === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const g = m.object;
      x = bf(g, { type: c, root: v, attach: p, primitive: !0 });
    } else {
      const g = jT[_];
      if (!g)
        throw new Error(
          `R3F: ${_} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      x = bf(new g(...d), {
        type: c,
        root: v,
        attach: p,
        memoizedProps: { args: d },
      });
    }
    return (
      x.__r3f.attach === void 0 &&
        (x.isBufferGeometry
          ? (x.__r3f.attach = "geometry")
          : x.isMaterial && (x.__r3f.attach = "material")),
      _ !== "inject" && fS(x, m),
      x
    );
  }
  function i(c, d) {
    let p = !1;
    if (d) {
      var m, v;
      (m = d.__r3f) != null && m.attach
        ? cS(c, d, d.__r3f.attach)
        : d.isObject3D && c.isObject3D && (c.add(d), (p = !0)),
        p || (v = c.__r3f) == null || v.objects.push(d),
        d.__r3f || bf(d, {}),
        (d.__r3f.parent = c),
        uw(d),
        Rf(d);
    }
  }
  function r(c, d, p) {
    let m = !1;
    if (d) {
      var v, _;
      if ((v = d.__r3f) != null && v.attach) cS(c, d, d.__r3f.attach);
      else if (d.isObject3D && c.isObject3D) {
        (d.parent = c),
          d.dispatchEvent({ type: "added" }),
          c.dispatchEvent({ type: "childadded", child: d });
        const x = c.children.filter((A) => A !== d),
          g = x.indexOf(p);
        (c.children = [...x.slice(0, g), d, ...x.slice(g)]), (m = !0);
      }
      m || (_ = c.__r3f) == null || _.objects.push(d),
        d.__r3f || bf(d, {}),
        (d.__r3f.parent = c),
        uw(d),
        Rf(d);
    }
  }
  function s(c, d, p = !1) {
    c && [...c].forEach((m) => o(d, m, p));
  }
  function o(c, d, p) {
    if (d) {
      var m, v, _;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (m = c.__r3f) != null &&
          m.objects &&
          (c.__r3f.objects = c.__r3f.objects.filter((w) => w !== d)),
        (v = d.__r3f) != null && v.attach)
      )
        SB(c, d, d.__r3f.attach);
      else if (d.isObject3D && c.isObject3D) {
        var x;
        c.remove(d), (x = d.__r3f) != null && x.root && kJ(zv(d), d);
      }
      const A = (_ = d.__r3f) == null ? void 0 : _.primitive,
        S = !A && (p === void 0 ? d.dispose !== null : p);
      if (!A) {
        var g;
        s((g = d.__r3f) == null ? void 0 : g.objects, d, S),
          s(d.children, d, S);
      }
      if ((delete d.__r3f, S && d.dispose && d.type !== "Scene")) {
        const w = () => {
          try {
            d.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? aw.unstable_scheduleCallback(aw.unstable_IdlePriority, w)
          : w();
      }
      Rf(c);
    }
  }
  function a(c, d, p, m) {
    var v;
    const _ = (v = c.__r3f) == null ? void 0 : v.parent;
    if (!_) return;
    const x = t(d, p, c.__r3f.root);
    if (c.children) {
      for (const g of c.children) g.__r3f && i(x, g);
      c.children = c.children.filter((g) => !g.__r3f);
    }
    c.__r3f.objects.forEach((g) => i(x, g)),
      (c.__r3f.objects = []),
      c.__r3f.autoRemovedBeforeAppend || o(_, c),
      x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
      i(_, x),
      x.raycast &&
        x.__r3f.eventCount &&
        zv(x).getState().internal.interaction.push(x),
      [m, m.alternate].forEach((g) => {
        g !== null &&
          ((g.stateNode = x),
          g.ref &&
            (typeof g.ref == "function" ? g.ref(x) : (g.ref.current = x)));
      });
  }
  const l = () => {};
  return {
    reconciler: bJ({
      createInstance: t,
      removeChild: o,
      appendChild: i,
      appendInitialChild: i,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (c, d) => {
        if (!d) return;
        const p = c.getState().scene;
        p.__r3f && ((p.__r3f.root = c), i(p, d));
      },
      removeChildFromContainer: (c, d) => {
        d && o(c.getState().scene, d);
      },
      insertInContainerBefore: (c, d, p) => {
        if (!d || !p) return;
        const m = c.getState().scene;
        m.__r3f && r(m, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (c) => c,
      finalizeInitialChildren(c) {
        var d;
        return !!((d = c == null ? void 0 : c.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(c, d, p, m) {
        var v;
        if (
          ((v = c == null ? void 0 : c.__r3f) != null ? v : {}).primitive &&
          m.object &&
          m.object !== c
        )
          return [!0];
        {
          const { args: x = [], children: g, ...A } = m,
            { args: S = [], children: w, ...C } = p;
          if (!Array.isArray(x))
            throw new Error("R3F: the args prop must be an array!");
          if (x.some((P, I) => P !== S[I])) return [!0];
          const b = vO(c, A, C, !0);
          return b.changes.length ? [!1, b] : null;
        }
      },
      commitUpdate(c, [d, p], m, v, _, x) {
        d ? a(c, m, _, x) : fS(c, p);
      },
      commitMount(c, d, p, m) {
        var v;
        const _ = (v = c.__r3f) != null ? v : {};
        c.raycast &&
          _.handlers &&
          _.eventCount &&
          zv(c).getState().internal.interaction.push(c);
      },
      getPublicInstance: (c) => c,
      prepareForCommit: () => null,
      preparePortalMount: (c) => bf(c.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(c) {
        var d;
        const { attach: p, parent: m } = (d = c.__r3f) != null ? d : {};
        p && m && SB(m, c, p), c.isObject3D && (c.visible = !1), Rf(c);
      },
      unhideInstance(c, d) {
        var p;
        const { attach: m, parent: v } = (p = c.__r3f) != null ? p : {};
        m && v && cS(v, c, m),
          ((c.isObject3D && d.visible == null) || d.visible) &&
            (c.visible = !0),
          Rf(c);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Yf.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Sn.fun(performance.now)
          ? performance.now
          : Sn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Sn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Sn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: fS,
  };
}
var yB, _B;
const uS = (n) => "colorSpace" in n || "outputColorSpace" in n,
  fO = () => {
    var n;
    return (n = jT.ColorManagement) != null ? n : null;
  },
  hO = (n) => n && n.isOrthographicCamera,
  BJ = (n) => n && n.hasOwnProperty("current"),
  Zm =
    typeof window < "u" &&
    (((yB = window.document) != null && yB.createElement) ||
      ((_B = window.navigator) == null ? void 0 : _B.product) === "ReactNative")
      ? j.useLayoutEffect
      : j.useEffect;
function dO(n) {
  const e = j.useRef(n);
  return Zm(() => void (e.current = n), [n]), e;
}
function IJ({ set: n }) {
  return Zm(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class pO extends j.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
pO.getDerivedStateFromError = () => ({ error: !0 });
const mO = "__default",
  xB = new Map(),
  DJ = (n) => n && !!n.memoized && !!n.changes;
function gO(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const Nd = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function zv(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Sn = {
  obj: (n) => n === Object(n) && !Sn.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: i = "reference", strict: r = !0 } = {}
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (Sn.str(n) || Sn.num(n) || Sn.boo(n)) return n === e;
    const s = Sn.obj(n);
    if (s && i === "reference") return n === e;
    const o = Sn.arr(n);
    if (o && t === "reference") return n === e;
    if ((o || s) && n === e) return !0;
    let a;
    for (a in n) if (!(a in e)) return !1;
    if (s && t === "shallow" && i === "shallow") {
      for (a in r ? e : n)
        if (!Sn.equ(n[a], e[a], { strict: r, objects: "reference" })) return !1;
    } else for (a in r ? e : n) if (n[a] !== e[a]) return !1;
    if (Sn.und(a)) {
      if (
        (o && n.length === 0 && e.length === 0) ||
        (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function LJ(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function FJ(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function bf(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function lw(n, e) {
  let t = n;
  if (e.includes("-")) {
    const i = e.split("-"),
      r = i.pop();
    return (t = i.reduce((s, o) => s[o], n)), { target: t, key: r };
  } else return { target: t, key: e };
}
const AB = /-\d+$/;
function cS(n, e, t) {
  if (Sn.str(t)) {
    if (AB.test(t)) {
      const s = t.replace(AB, ""),
        { target: o, key: a } = lw(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: i, key: r } = lw(n, t);
    (e.__r3f.previousAttach = i[r]), (i[r] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function SB(n, e, t) {
  var i, r;
  if (Sn.str(t)) {
    const { target: s, key: o } = lw(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function vO(
  n,
  { children: e, key: t, ref: i, ...r },
  { children: s, key: o, ref: a, ...l } = {},
  u = !1
) {
  const c = n.__r3f,
    d = Object.entries(r),
    p = [];
  if (u) {
    const v = Object.keys(l);
    for (let _ = 0; _ < v.length; _++)
      r.hasOwnProperty(v[_]) || d.unshift([v[_], mO + "remove"]);
  }
  d.forEach(([v, _]) => {
    var x;
    if (
      ((x = n.__r3f) != null && x.primitive && v === "object") ||
      Sn.equ(_, l[v])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v))
      return p.push([v, _, !0, []]);
    let g = [];
    v.includes("-") && (g = v.split("-")), p.push([v, _, !1, g]);
    for (const A in r) {
      const S = r[A];
      A.startsWith(`${v}-`) && p.push([A, S, !1, A.split("-")]);
    }
  });
  const m = { ...r };
  return (
    c != null &&
      c.memoizedProps &&
      c != null &&
      c.memoizedProps.args &&
      (m.args = c.memoizedProps.args),
    c != null &&
      c.memoizedProps &&
      c != null &&
      c.memoizedProps.attach &&
      (m.attach = c.memoizedProps.attach),
    { memoized: m, changes: p }
  );
}
const NJ = typeof process < "u" && !1;
function fS(n, e) {
  var t;
  const i = n.__r3f,
    r = i == null ? void 0 : i.root,
    s = r == null || r.getState == null ? void 0 : r.getState(),
    { memoized: o, changes: a } = DJ(e) ? e : vO(n, e),
    l = i == null ? void 0 : i.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = o);
  for (let p = 0; p < a.length; p++) {
    let [m, v, _, x] = a[p];
    if (uS(n)) {
      const w = "srgb",
        C = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (v = v === 3001 ? w : C))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (v = v === 3001 ? w : C));
    }
    let g = n,
      A = g[m];
    if (x.length && ((A = x.reduce((S, w) => S[w], n)), !(A && A.set))) {
      const [S, ...w] = x.reverse();
      (g = w.reverse().reduce((C, b) => C[b], n)), (m = S);
    }
    if (v === mO + "remove")
      if (g.constructor) {
        let S = xB.get(g.constructor);
        S || ((S = new g.constructor()), xB.set(g.constructor, S)), (v = S[m]);
      } else v = 0;
    if (_ && i)
      v ? (i.handlers[m] = v) : delete i.handlers[m],
        (i.eventCount = Object.keys(i.handlers).length);
    else if (A && A.set && (A.copy || A instanceof oc)) {
      if (Array.isArray(v)) A.fromArray ? A.fromArray(v) : A.set(...v);
      else if (
        A.copy &&
        v &&
        v.constructor &&
        (NJ
          ? A.constructor.name === v.constructor.name
          : A.constructor === v.constructor)
      )
        A.copy(v);
      else if (v !== void 0) {
        var u;
        const S = (u = A) == null ? void 0 : u.isColor;
        !S && A.setScalar
          ? A.setScalar(v)
          : A instanceof oc && v instanceof oc
          ? (A.mask = v.mask)
          : A.set(v),
          !fO() && s && !s.linear && S && A.convertSRGBToLinear();
      }
    } else {
      var c;
      if (
        ((g[m] = v),
        (c = g[m]) != null &&
          c.isTexture &&
          g[m].format === $i &&
          g[m].type === xo &&
          s)
      ) {
        const S = g[m];
        uS(S) && uS(s.gl)
          ? (S.colorSpace = s.gl.outputColorSpace)
          : (S.encoding = s.gl.outputEncoding);
      }
    }
    Rf(n);
  }
  if (i && i.parent && n.raycast && l !== i.eventCount) {
    const p = zv(n).getState().internal,
      m = p.interaction.indexOf(n);
    m > -1 && p.interaction.splice(m, 1), i.eventCount && p.interaction.push(n);
  }
  return (
    !(a.length === 1 && a[0][0] === "onUpdate") &&
      a.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      uw(n),
    n
  );
}
function Rf(n) {
  var e, t;
  const i =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function uw(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function OJ(n, e) {
  n.manual ||
    (hO(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function sv(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function UJ() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Yf.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Yf.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Yf.ContinuousEventPriority;
    default:
      return Yf.DefaultEventPriority;
  }
}
function yO(n, e, t, i) {
  const r = t.get(e);
  r &&
    (t.delete(e),
    t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)));
}
function kJ(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((i) => i !== e)),
    (t.initialHits = t.initialHits.filter((i) => i !== e)),
    t.hovered.forEach((i, r) => {
      (i.eventObject === e || i.object === e) && t.hovered.delete(r);
    }),
    t.capturedMap.forEach((i, r) => {
      yO(t.capturedMap, e, i, r);
    });
}
function zJ(n) {
  function e(l) {
    const { internal: u } = n.getState(),
      c = l.offsetX - u.initialClick[0],
      d = l.offsetY - u.initialClick[1];
    return Math.round(Math.sqrt(c * c + d * d));
  }
  function t(l) {
    return l.filter((u) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((c) => {
        var d;
        return (d = u.__r3f) == null ? void 0 : d.handlers["onPointer" + c];
      })
    );
  }
  function i(l, u) {
    const c = n.getState(),
      d = new Set(),
      p = [],
      m = u ? u(c.internal.interaction) : c.internal.interaction;
    for (let g = 0; g < m.length; g++) {
      const A = Nd(m[g]);
      A && (A.raycaster.camera = void 0);
    }
    c.previousRoot || c.events.compute == null || c.events.compute(l, c);
    function v(g) {
      const A = Nd(g);
      if (!A || !A.events.enabled || A.raycaster.camera === null) return [];
      if (A.raycaster.camera === void 0) {
        var S;
        A.events.compute == null ||
          A.events.compute(
            l,
            A,
            (S = A.previousRoot) == null ? void 0 : S.getState()
          ),
          A.raycaster.camera === void 0 && (A.raycaster.camera = null);
      }
      return A.raycaster.camera ? A.raycaster.intersectObject(g, !0) : [];
    }
    let _ = m
      .flatMap(v)
      .sort((g, A) => {
        const S = Nd(g.object),
          w = Nd(A.object);
        return !S || !w
          ? g.distance - A.distance
          : w.events.priority - S.events.priority || g.distance - A.distance;
      })
      .filter((g) => {
        const A = sv(g);
        return d.has(A) ? !1 : (d.add(A), !0);
      });
    c.events.filter && (_ = c.events.filter(_, c));
    for (const g of _) {
      let A = g.object;
      for (; A; ) {
        var x;
        (x = A.__r3f) != null &&
          x.eventCount &&
          p.push({ ...g, eventObject: A }),
          (A = A.parent);
      }
    }
    if ("pointerId" in l && c.internal.capturedMap.has(l.pointerId))
      for (let g of c.internal.capturedMap.get(l.pointerId).values())
        d.has(sv(g.intersection)) || p.push(g.intersection);
    return p;
  }
  function r(l, u, c, d) {
    const p = n.getState();
    if (l.length) {
      const m = { stopped: !1 };
      for (const v of l) {
        const _ = Nd(v.object) || p,
          { raycaster: x, pointer: g, camera: A, internal: S } = _,
          w = new z(g.x, g.y, 0).unproject(A),
          C = (T) => {
            var D, G;
            return (D =
              (G = S.capturedMap.get(T)) == null
                ? void 0
                : G.has(v.eventObject)) != null
              ? D
              : !1;
          },
          b = (T) => {
            const D = { intersection: v, target: u.target };
            S.capturedMap.has(T)
              ? S.capturedMap.get(T).set(v.eventObject, D)
              : S.capturedMap.set(T, new Map([[v.eventObject, D]])),
              u.target.setPointerCapture(T);
          },
          P = (T) => {
            const D = S.capturedMap.get(T);
            D && yO(S.capturedMap, v.eventObject, D, T);
          };
        let I = {};
        for (let T in u) {
          let D = u[T];
          typeof D != "function" && (I[T] = D);
        }
        let R = {
          ...v,
          ...I,
          pointer: g,
          intersections: l,
          stopped: m.stopped,
          delta: c,
          unprojectedPoint: w,
          ray: x.ray,
          camera: A,
          stopPropagation() {
            const T = "pointerId" in u && S.capturedMap.get(u.pointerId);
            if (
              (!T || T.has(v.eventObject)) &&
              ((R.stopped = m.stopped = !0),
              S.hovered.size &&
                Array.from(S.hovered.values()).find(
                  (D) => D.eventObject === v.eventObject
                ))
            ) {
              const D = l.slice(0, l.indexOf(v));
              s([...D, v]);
            }
          },
          target: {
            hasPointerCapture: C,
            setPointerCapture: b,
            releasePointerCapture: P,
          },
          currentTarget: {
            hasPointerCapture: C,
            setPointerCapture: b,
            releasePointerCapture: P,
          },
          nativeEvent: u,
        };
        if ((d(R), m.stopped === !0)) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: u } = n.getState();
    for (const c of u.hovered.values())
      if (
        !l.length ||
        !l.find(
          (d) =>
            d.object === c.object &&
            d.index === c.index &&
            d.instanceId === c.instanceId
        )
      ) {
        const p = c.eventObject.__r3f,
          m = p == null ? void 0 : p.handlers;
        if ((u.hovered.delete(sv(c)), p != null && p.eventCount)) {
          const v = { ...c, intersections: l };
          m.onPointerOut == null || m.onPointerOut(v),
            m.onPointerLeave == null || m.onPointerLeave(v);
        }
      }
  }
  function o(l, u) {
    for (let c = 0; c < u.length; c++) {
      const d = u[c].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (u) => {
          const { internal: c } = n.getState();
          "pointerId" in u &&
            c.capturedMap.has(u.pointerId) &&
            requestAnimationFrame(() => {
              c.capturedMap.has(u.pointerId) &&
                (c.capturedMap.delete(u.pointerId), s([]));
            });
        };
    }
    return function (c) {
      const { onPointerMissed: d, internal: p } = n.getState();
      p.lastEvent.current = c;
      const m = l === "onPointerMove",
        v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        x = i(c, m ? t : void 0),
        g = v ? e(c) : 0;
      l === "onPointerDown" &&
        ((p.initialClick = [c.offsetX, c.offsetY]),
        (p.initialHits = x.map((S) => S.eventObject))),
        v && !x.length && g <= 2 && (o(c, p.interaction), d && d(c)),
        m && s(x);
      function A(S) {
        const w = S.eventObject,
          C = w.__r3f,
          b = C == null ? void 0 : C.handlers;
        if (C != null && C.eventCount)
          if (m) {
            if (
              b.onPointerOver ||
              b.onPointerEnter ||
              b.onPointerOut ||
              b.onPointerLeave
            ) {
              const P = sv(S),
                I = p.hovered.get(P);
              I
                ? I.stopped && S.stopPropagation()
                : (p.hovered.set(P, S),
                  b.onPointerOver == null || b.onPointerOver(S),
                  b.onPointerEnter == null || b.onPointerEnter(S));
            }
            b.onPointerMove == null || b.onPointerMove(S);
          } else {
            const P = b[l];
            P
              ? (!v || p.initialHits.includes(w)) &&
                (o(
                  c,
                  p.interaction.filter((I) => !p.initialHits.includes(I))
                ),
                P(S))
              : v &&
                p.initialHits.includes(w) &&
                o(
                  c,
                  p.interaction.filter((I) => !p.initialHits.includes(I))
                );
          }
      }
      r(x, c, g, A);
    };
  }
  return { handlePointer: a };
}
const _O = (n) => !!(n != null && n.render),
  xO = j.createContext(null),
  HJ = (n, e) => {
    const t = AJ((a, l) => {
        const u = new z(),
          c = new z(),
          d = new z();
        function p(g = l().camera, A = c, S = l().size) {
          const { width: w, height: C, top: b, left: P } = S,
            I = w / C;
          A.isVector3 ? d.copy(A) : d.set(...A);
          const R = g.getWorldPosition(u).distanceTo(d);
          if (hO(g))
            return {
              width: w / g.zoom,
              height: C / g.zoom,
              top: b,
              left: P,
              factor: 1,
              distance: R,
              aspect: I,
            };
          {
            const T = (g.fov * Math.PI) / 180,
              D = 2 * Math.tan(T / 2) * R,
              G = D * (w / C);
            return {
              width: G,
              height: D,
              top: b,
              left: P,
              factor: w / G,
              distance: R,
              aspect: I,
            };
          }
        }
        let m;
        const v = (g) =>
            a((A) => ({ performance: { ...A.performance, current: g } })),
          _ = new Ae();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (g = 1) => n(l(), g),
          advance: (g, A) => e(g, A, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new HT(),
          pointer: _,
          mouse: _,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const g = l();
              m && clearTimeout(m),
                g.performance.current !== g.performance.min &&
                  v(g.performance.min),
                (m = setTimeout(
                  () => v(l().performance.max),
                  g.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (g) => a((A) => ({ ...A, events: { ...A.events, ...g } })),
          setSize: (g, A, S, w, C) => {
            const b = l().camera,
              P = {
                width: g,
                height: A,
                top: w || 0,
                left: C || 0,
                updateStyle: S,
              };
            a((I) => ({ size: P, viewport: { ...I.viewport, ...p(b, c, P) } }));
          },
          setDpr: (g) =>
            a((A) => {
              const S = gO(g);
              return {
                viewport: {
                  ...A.viewport,
                  dpr: S,
                  initialDpr: A.viewport.initialDpr || S,
                },
              };
            }),
          setFrameloop: (g = "always") => {
            const A = l().clock;
            A.stop(),
              (A.elapsedTime = 0),
              g !== "never" && (A.start(), (A.elapsedTime = 0)),
              a(() => ({ frameloop: g }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: j.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (g, A, S) => {
              const w = l().internal;
              return (
                (w.priority = w.priority + (A > 0 ? 1 : 0)),
                w.subscribers.push({ ref: g, priority: A, store: S }),
                (w.subscribers = w.subscribers.sort(
                  (C, b) => C.priority - b.priority
                )),
                () => {
                  const C = l().internal;
                  C != null &&
                    C.subscribers &&
                    ((C.priority = C.priority - (A > 0 ? 1 : 0)),
                    (C.subscribers = C.subscribers.filter((b) => b.ref !== g)));
                }
              );
            },
          },
        };
      }),
      i = t.getState();
    let r = i.size,
      s = i.viewport.dpr,
      o = i.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: l, viewport: u, gl: c, set: d } = t.getState();
        if (l.width !== r.width || l.height !== r.height || u.dpr !== s) {
          var p;
          (r = l), (s = u.dpr), OJ(a, l), c.setPixelRatio(u.dpr);
          const m =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                c.domElement instanceof HTMLCanvasElement;
          c.setSize(l.width, l.height, m);
        }
        a !== o &&
          ((o = a),
          d((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let ov,
  GJ = new Set(),
  VJ = new Set(),
  WJ = new Set();
function hS(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function Od(n, e) {
  switch (n) {
    case "before":
      return hS(GJ, e);
    case "after":
      return hS(VJ, e);
    case "tail":
      return hS(WJ, e);
  }
}
let dS, pS;
function mS(n, e, t) {
  let i = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((i = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      dS = e.internal.subscribers,
      ov = 0;
    ov < dS.length;
    ov++
  )
    (pS = dS[ov]), pS.ref.current(pS.store.getState(), i, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function XJ(n) {
  let e = !1,
    t = !1,
    i,
    r,
    s;
  function o(u) {
    (r = requestAnimationFrame(o)),
      (e = !0),
      (i = 0),
      Od("before", u),
      (t = !0);
    for (const d of n.values()) {
      var c;
      (s = d.store.getState()),
        s.internal.active &&
          (s.frameloop === "always" || s.internal.frames > 0) &&
          !((c = s.gl.xr) != null && c.isPresenting) &&
          (i += mS(u, s));
    }
    if (((t = !1), Od("after", u), i === 0))
      return Od("tail", u), (e = !1), cancelAnimationFrame(r);
  }
  function a(u, c = 1) {
    var d;
    if (!u) return n.forEach((p) => a(p.store.getState(), c));
    ((d = u.gl.xr) != null && d.isPresenting) ||
      !u.internal.active ||
      u.frameloop === "never" ||
      (c > 1
        ? (u.internal.frames = Math.min(60, u.internal.frames + c))
        : t
        ? (u.internal.frames = 2)
        : (u.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(o)));
  }
  function l(u, c = !0, d, p) {
    if ((c && Od("before", u), d)) mS(u, d, p);
    else for (const m of n.values()) mS(u, m.store.getState());
    c && Od("after", u);
  }
  return { loop: o, invalidate: a, advance: l };
}
function AO() {
  const n = j.useContext(xO);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function Us(n = (t) => t, e) {
  return AO()(n, e);
}
function qm(n, e = 0) {
  const t = AO(),
    i = t.getState().internal.subscribe,
    r = dO(n);
  return Zm(() => i(r, e, t), [e, i, t]), null;
}
const MB = new WeakMap();
function SO(n, e) {
  return function (t, ...i) {
    let r = MB.get(t);
    return (
      r || ((r = new t()), MB.set(t, r)),
      n && n(r),
      Promise.all(
        i.map(
          (s) =>
            new Promise((o, a) =>
              r.load(
                s,
                (l) => {
                  l.scene && Object.assign(l, LJ(l.scene)), o(l);
                },
                e,
                (l) =>
                  a(
                    new Error(
                      `Could not load ${s}: ${l == null ? void 0 : l.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function $m(n, e, t, i) {
  const r = Array.isArray(e) ? e : [e],
    s = MJ(SO(t, i), [n, ...r], { equal: Sn.equ });
  return Array.isArray(e) ? s : s[0];
}
$m.preload = function (n, e, t) {
  const i = Array.isArray(e) ? e : [e];
  return wJ(SO(t), [n, ...i]);
};
$m.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return EJ([n, ...t]);
};
const Bh = new Map(),
  { invalidate: wB, advance: EB } = XJ(Bh),
  { reconciler: u_, applyProps: Sf } = PJ(Bh, UJ),
  Mf = { objects: "shallow", strict: !1 },
  JJ = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return _O(t)
      ? t
      : new rO({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function jJ(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: i, height: r, top: s, left: o, updateStyle: a = t } = e;
    return { width: i, height: r, top: s, left: o, updateStyle: a };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: i,
      height: r,
      top: s,
      left: o,
    } = n.parentElement.getBoundingClientRect();
    return { width: i, height: r, top: s, left: o, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function YJ(n) {
  const e = Bh.get(n),
    t = e == null ? void 0 : e.fiber,
    i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error,
    s = i || HJ(wB, EB),
    o =
      t ||
      u_.createContainer(s, Yf.ConcurrentRoot, null, !1, null, "", r, null);
  e || Bh.set(n, { fiber: o, store: s });
  let a,
    l = !1,
    u;
  return {
    configure(c = {}) {
      let {
          gl: d,
          size: p,
          scene: m,
          events: v,
          onCreated: _,
          shadows: x = !1,
          linear: g = !1,
          flat: A = !1,
          legacy: S = !1,
          orthographic: w = !1,
          frameloop: C = "always",
          dpr: b = [1, 2],
          performance: P,
          raycaster: I,
          camera: R,
          onPointerMissed: T,
        } = c,
        D = s.getState(),
        G = D.gl;
      D.gl || D.set({ gl: (G = JJ(d, n)) });
      let W = D.raycaster;
      W || D.set({ raycaster: (W = new QN()) });
      const { params: q, ...Z } = I || {};
      if (
        (Sn.equ(Z, W, Mf) || Sf(W, { ...Z }),
        Sn.equ(q, W.params, Mf) || Sf(W, { params: { ...W.params, ...q } }),
        !D.camera || (D.camera === u && !Sn.equ(u, R, Mf)))
      ) {
        u = R;
        const F = R instanceof Hm,
          se = F
            ? R
            : w
            ? new yo(0, 0, 0, 0, 0.1, 1e3)
            : new bn(75, 0, 0.1, 1e3);
        F ||
          ((se.position.z = 5),
          R &&
            (Sf(se, R),
            ("aspect" in R ||
              "left" in R ||
              "right" in R ||
              "bottom" in R ||
              "top" in R) &&
              ((se.manual = !0), se.updateProjectionMatrix())),
          !D.camera && !(R != null && R.rotation) && se.lookAt(0, 0, 0)),
          D.set({ camera: se }),
          (W.camera = se);
      }
      if (!D.scene) {
        let F;
        m != null && m.isScene ? (F = m) : ((F = new vT()), m && Sf(F, m)),
          D.set({ scene: bf(F) });
      }
      if (!D.xr) {
        var K;
        const F = (De, re) => {
            const xe = s.getState();
            xe.frameloop !== "never" && EB(De, !0, xe, re);
          },
          se = () => {
            const De = s.getState();
            (De.gl.xr.enabled = De.gl.xr.isPresenting),
              De.gl.xr.setAnimationLoop(De.gl.xr.isPresenting ? F : null),
              De.gl.xr.isPresenting || wB(De);
          },
          Me = {
            connect() {
              const De = s.getState().gl;
              De.xr.addEventListener("sessionstart", se),
                De.xr.addEventListener("sessionend", se);
            },
            disconnect() {
              const De = s.getState().gl;
              De.xr.removeEventListener("sessionstart", se),
                De.xr.removeEventListener("sessionend", se);
            },
          };
        typeof ((K = G.xr) == null ? void 0 : K.addEventListener) ==
          "function" && Me.connect(),
          D.set({ xr: Me });
      }
      if (G.shadowMap) {
        const F = G.shadowMap.enabled,
          se = G.shadowMap.type;
        if (((G.shadowMap.enabled = !!x), Sn.boo(x))) G.shadowMap.type = mp;
        else if (Sn.str(x)) {
          var te;
          const Me = { basic: mF, percentage: $_, soft: mp, variance: uo };
          G.shadowMap.type = (te = Me[x]) != null ? te : mp;
        } else Sn.obj(x) && Object.assign(G.shadowMap, x);
        (F !== G.shadowMap.enabled || se !== G.shadowMap.type) &&
          (G.shadowMap.needsUpdate = !0);
      }
      const O = fO();
      O &&
        ("enabled" in O
          ? (O.enabled = !S)
          : "legacyMode" in O && (O.legacyMode = S)),
        l ||
          Sf(G, { outputEncoding: g ? 3e3 : 3001, toneMapping: A ? Vo : $E }),
        D.legacy !== S && D.set(() => ({ legacy: S })),
        D.linear !== g && D.set(() => ({ linear: g })),
        D.flat !== A && D.set(() => ({ flat: A })),
        d && !Sn.fun(d) && !_O(d) && !Sn.equ(d, G, Mf) && Sf(G, d),
        v && !D.events.handlers && D.set({ events: v(s) });
      const Y = jJ(n, p);
      return (
        Sn.equ(Y, D.size, Mf) ||
          D.setSize(Y.width, Y.height, Y.updateStyle, Y.top, Y.left),
        b && D.viewport.dpr !== gO(b) && D.setDpr(b),
        D.frameloop !== C && D.setFrameloop(C),
        D.onPointerMissed || D.set({ onPointerMissed: T }),
        P &&
          !Sn.equ(P, D.performance, Mf) &&
          D.set((F) => ({ performance: { ...F.performance, ...P } })),
        (a = _),
        (l = !0),
        this
      );
    },
    render(c) {
      return (
        l || this.configure(),
        u_.updateContainer(
          _e(KJ, { store: s, children: c, onCreated: a, rootElement: n }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      MO(n);
    },
  };
}
function KJ({ store: n, children: e, onCreated: t, rootElement: i }) {
  return (
    Zm(() => {
      const r = n.getState();
      r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(r),
        n.getState().events.connected ||
          r.events.connect == null ||
          r.events.connect(i);
    }, []),
    _e(xO.Provider, { value: n, children: e })
  );
}
function MO(n, e) {
  const t = Bh.get(n),
    i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1),
      u_.updateContainer(null, i, null, () => {
        r &&
          setTimeout(() => {
            try {
              var s, o, a, l;
              r.events.disconnect == null || r.events.disconnect(),
                (s = r.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = r.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = r.gl) != null && l.xr && r.xr.disconnect(),
                FJ(r),
                Bh.delete(n),
                e && e(n);
            } catch {}
          }, 500);
      });
  }
}
u_.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: j.version,
});
const gS = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function QJ(n) {
  const { handlePointer: e } = zJ(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, i, r) {
      i.pointer.set(
        (t.offsetX / i.size.width) * 2 - 1,
        -(t.offsetY / i.size.height) * 2 + 1
      ),
        i.raycaster.setFromCamera(i.pointer, i.camera);
    },
    connected: void 0,
    handlers: Object.keys(gS).reduce((t, i) => ({ ...t, [i]: e(i) }), {}),
    update: () => {
      var t;
      const { events: i, internal: r } = n.getState();
      (t = r.lastEvent) != null &&
        t.current &&
        i.handlers &&
        i.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var i;
      const { set: r, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        r((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
          const [l, u] = gS[o];
          t.addEventListener(l, a, { passive: u });
        });
    },
    disconnect: () => {
      const { set: t, events: i } = n.getState();
      if (i.connected) {
        var r;
        Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
          if (i && i.connected instanceof HTMLElement) {
            const [a] = gS[s];
            i.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
function TB(n, e) {
  let t;
  return (...i) => {
    window.clearTimeout(t), (t = window.setTimeout(() => n(...i), e));
  };
}
function ZJ(
  { debounce: n, scroll: e, polyfill: t, offsetSize: i } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const r = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!r)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [s, o] = j.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    a = j.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: s,
      orientationHandler: null,
    }),
    l = n ? (typeof n == "number" ? n : n.scroll) : null,
    u = n ? (typeof n == "number" ? n : n.resize) : null,
    c = j.useRef(!1);
  j.useEffect(() => ((c.current = !0), () => void (c.current = !1)));
  const [d, p, m] = j.useMemo(() => {
    const g = () => {
      if (!a.current.element) return;
      const {
          left: A,
          top: S,
          width: w,
          height: C,
          bottom: b,
          right: P,
          x: I,
          y: R,
        } = a.current.element.getBoundingClientRect(),
        T = {
          left: A,
          top: S,
          width: w,
          height: C,
          bottom: b,
          right: P,
          x: I,
          y: R,
        };
      a.current.element instanceof HTMLElement &&
        i &&
        ((T.height = a.current.element.offsetHeight),
        (T.width = a.current.element.offsetWidth)),
        Object.freeze(T),
        c.current &&
          !tj(a.current.lastBounds, T) &&
          o((a.current.lastBounds = T));
    };
    return [g, u ? TB(g, u) : g, l ? TB(g, l) : g];
  }, [o, i, l, u]);
  function v() {
    a.current.scrollContainers &&
      (a.current.scrollContainers.forEach((g) =>
        g.removeEventListener("scroll", m, !0)
      ),
      (a.current.scrollContainers = null)),
      a.current.resizeObserver &&
        (a.current.resizeObserver.disconnect(),
        (a.current.resizeObserver = null)),
      a.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              a.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              a.current.orientationHandler
            ));
  }
  function _() {
    a.current.element &&
      ((a.current.resizeObserver = new r(m)),
      a.current.resizeObserver.observe(a.current.element),
      e &&
        a.current.scrollContainers &&
        a.current.scrollContainers.forEach((g) =>
          g.addEventListener("scroll", m, { capture: !0, passive: !0 })
        ),
      (a.current.orientationHandler = () => {
        m();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            a.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            a.current.orientationHandler
          ));
  }
  const x = (g) => {
    !g ||
      g === a.current.element ||
      (v(), (a.current.element = g), (a.current.scrollContainers = wO(g)), _());
  };
  return (
    $J(m, !!e),
    qJ(p),
    j.useEffect(() => {
      v(), _();
    }, [e, m, p]),
    j.useEffect(() => v, []),
    [x, s, d]
  );
}
function qJ(n) {
  j.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function $J(n, e) {
  j.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function wO(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: i,
    overflowY: r,
  } = window.getComputedStyle(n);
  return (
    [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...wO(n.parentElement)]
  );
}
const ej = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  tj = (n, e) => ej.every((t) => n[t] === e[t]);
var nj = Object.defineProperty,
  ij = Object.defineProperties,
  rj = Object.getOwnPropertyDescriptors,
  CB = Object.getOwnPropertySymbols,
  sj = Object.prototype.hasOwnProperty,
  oj = Object.prototype.propertyIsEnumerable,
  bB = (n, e, t) =>
    e in n
      ? nj(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  RB = (n, e) => {
    for (var t in e || (e = {})) sj.call(e, t) && bB(n, t, e[t]);
    if (CB) for (var t of CB(e)) oj.call(e, t) && bB(n, t, e[t]);
    return n;
  },
  aj = (n, e) => ij(n, rj(e)),
  PB,
  BB;
typeof window < "u" &&
(((PB = window.document) != null && PB.createElement) ||
  ((BB = window.navigator) == null ? void 0 : BB.product) === "ReactNative")
  ? j.useLayoutEffect
  : j.useEffect;
function EO(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let i = e ? n.return : n.child;
  for (; i; ) {
    const r = EO(i, e, t);
    if (r) return r;
    i = e ? null : i.sibling;
  }
}
function TO(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const IB = console.error;
console.error = function () {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = IB;
    return;
  }
  return IB.apply(this, arguments);
};
const YT = TO(j.createContext(null));
class CO extends j.Component {
  render() {
    return j.createElement(
      YT.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function lj() {
  const n = j.useContext(YT);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = j.useId();
  return j.useMemo(() => {
    for (const i of [n, n == null ? void 0 : n.alternate]) {
      if (!i) continue;
      const r = EO(i, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return !0;
          o = o.next;
        }
      });
      if (r) return r;
    }
  }, [n, e]);
}
function uj() {
  const n = lj(),
    [e] = j.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const r =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      r && r !== YT && !e.has(r) && e.set(r, j.useContext(TO(r)));
    }
    t = t.return;
  }
  return e;
}
function cj() {
  const n = uj();
  return j.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (i) =>
          j.createElement(
            e,
            null,
            j.createElement(t.Provider, aj(RB({}, i), { value: n.get(t) }))
          ),
        (e) => j.createElement(CO, RB({}, e))
      ),
    [n]
  );
}
const fj = j.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: i,
      style: r,
      gl: s,
      events: o = QJ,
      eventSource: a,
      eventPrefix: l,
      shadows: u,
      linear: c,
      flat: d,
      legacy: p,
      orthographic: m,
      frameloop: v,
      dpr: _,
      performance: x,
      raycaster: g,
      camera: A,
      scene: S,
      onPointerMissed: w,
      onCreated: C,
      ...b
    },
    P
  ) {
    j.useMemo(() => RJ(yJ), []);
    const I = cj(),
      [R, T] = ZJ({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }),
      D = j.useRef(null),
      G = j.useRef(null);
    j.useImperativeHandle(P, () => D.current);
    const W = dO(w),
      [q, Z] = j.useState(!1),
      [K, te] = j.useState(!1);
    if (q) throw q;
    if (K) throw K;
    const O = j.useRef(null);
    return (
      Zm(() => {
        const F = D.current;
        T.width > 0 &&
          T.height > 0 &&
          F &&
          (O.current || (O.current = YJ(F)),
          O.current.configure({
            gl: s,
            events: o,
            shadows: u,
            linear: c,
            flat: d,
            legacy: p,
            orthographic: m,
            frameloop: v,
            dpr: _,
            performance: x,
            raycaster: g,
            camera: A,
            scene: S,
            size: T,
            onPointerMissed: (...se) =>
              W.current == null ? void 0 : W.current(...se),
            onCreated: (se) => {
              se.events.connect == null ||
                se.events.connect(a ? (BJ(a) ? a.current : a) : G.current),
                l &&
                  se.setEvents({
                    compute: (Me, De) => {
                      const re = Me[l + "X"],
                        xe = Me[l + "Y"];
                      De.pointer.set(
                        (re / De.size.width) * 2 - 1,
                        -(xe / De.size.height) * 2 + 1
                      ),
                        De.raycaster.setFromCamera(De.pointer, De.camera);
                    },
                  }),
                C == null || C(se);
            },
          }),
          O.current.render(
            _e(I, {
              children: _e(pO, {
                set: te,
                children: _e(j.Suspense, {
                  fallback: _e(IJ, { set: Z }),
                  children: e ?? null,
                }),
              }),
            })
          ));
      }),
      j.useEffect(() => {
        const F = D.current;
        if (F) return () => MO(F);
      }, []),
      _e("div", {
        ref: G,
        style: {
          position: "relative",
          width: "100%",
          height: "100%",
          overflow: "hidden",
          pointerEvents: a ? "none" : "auto",
          ...r,
        },
        ...b,
        children: _e("div", {
          ref: R,
          style: { width: "100%", height: "100%" },
          children: _e("canvas", {
            ref: D,
            style: { display: "block" },
            children: t,
          }),
        }),
      })
    );
  }),
  bO = j.forwardRef(function (e, t) {
    return _e(CO, { children: _e(fj, { ...e, ref: t }) });
  });
function za() {
  return (
    (za = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) ({}).hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    za.apply(null, arguments)
  );
}
const eg = new z(),
  KT = new z(),
  hj = new z(),
  DB = new Ae();
function dj(n, e, t) {
  const i = eg.setFromMatrixPosition(n.matrixWorld);
  i.project(e);
  const r = t.width / 2,
    s = t.height / 2;
  return [i.x * r + r, -(i.y * s) + s];
}
function pj(n, e) {
  const t = eg.setFromMatrixPosition(n.matrixWorld),
    i = KT.setFromMatrixPosition(e.matrixWorld),
    r = t.sub(i),
    s = e.getWorldDirection(hj);
  return r.angleTo(s) > Math.PI / 2;
}
function mj(n, e, t, i) {
  const r = eg.setFromMatrixPosition(n.matrixWorld),
    s = r.clone();
  s.project(e), DB.set(s.x, s.y), t.setFromCamera(DB, e);
  const o = t.intersectObjects(i, !0);
  if (o.length) {
    const a = o[0].distance;
    return r.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function gj(n, e) {
  if (e instanceof yo) return e.zoom;
  if (e instanceof bn) {
    const t = eg.setFromMatrixPosition(n.matrixWorld),
      i = KT.setFromMatrixPosition(e.matrixWorld),
      r = (e.fov * Math.PI) / 180,
      s = t.distanceTo(i);
    return 1 / (2 * Math.tan(r / 2) * s);
  } else return 1;
}
function vj(n, e, t) {
  if (e instanceof bn || e instanceof yo) {
    const i = eg.setFromMatrixPosition(n.matrixWorld),
      r = KT.setFromMatrixPosition(e.matrixWorld),
      s = i.distanceTo(r),
      o = (t[1] - t[0]) / (e.far - e.near),
      a = t[1] - o * e.far;
    return Math.round(o * s + a);
  }
}
const cw = (n) => (Math.abs(n) < 1e-10 ? 0 : n);
function RO(n, e, t = "") {
  let i = "matrix3d(";
  for (let r = 0; r !== 16; r++)
    i += cw(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
  return t + i;
}
const yj = (
    (n) => (e) =>
      RO(e, n)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  _j = (
    (n) => (e, t) =>
      RO(e, n(t), "translate(-50%,-50%)")
  )((n) => [
    1 / n,
    1 / n,
    1 / n,
    1,
    -1 / n,
    -1 / n,
    -1 / n,
    -1,
    1 / n,
    1 / n,
    1 / n,
    1,
    1,
    1,
    1,
    1,
  ]);
function xj(n) {
  return n && typeof n == "object" && "current" in n;
}
const Aj = j.forwardRef(
    (
      {
        children: n,
        eps: e = 0.001,
        style: t,
        className: i,
        prepend: r,
        center: s,
        fullscreen: o,
        portal: a,
        distanceFactor: l,
        sprite: u = !1,
        transform: c = !1,
        occlude: d,
        onOcclude: p,
        castShadow: m,
        receiveShadow: v,
        material: _,
        geometry: x,
        zIndexRange: g = [16777271, 0],
        calculatePosition: A = dj,
        as: S = "div",
        wrapperClass: w,
        pointerEvents: C = "auto",
        ...b
      },
      P
    ) => {
      const {
          gl: I,
          camera: R,
          scene: T,
          size: D,
          raycaster: G,
          events: W,
          viewport: q,
        } = Us(),
        [Z] = j.useState(() => document.createElement(S)),
        K = j.useRef(),
        te = j.useRef(null),
        O = j.useRef(0),
        Y = j.useRef([0, 0]),
        F = j.useRef(null),
        se = j.useRef(null),
        Me =
          (a == null ? void 0 : a.current) ||
          W.connected ||
          I.domElement.parentNode,
        De = j.useRef(null),
        re = j.useRef(!1),
        xe = j.useMemo(
          () =>
            (d && d !== "blending") ||
            (Array.isArray(d) && d.length && xj(d[0])),
          [d]
        );
      j.useLayoutEffect(() => {
        const Ye = I.domElement;
        d && d === "blending"
          ? ((Ye.style.zIndex = `${Math.floor(g[0] / 2)}`),
            (Ye.style.position = "absolute"),
            (Ye.style.pointerEvents = "none"))
          : ((Ye.style.zIndex = null),
            (Ye.style.position = null),
            (Ye.style.pointerEvents = null));
      }, [d]),
        j.useLayoutEffect(() => {
          if (te.current) {
            const Ye = (K.current = nF(Z));
            if ((T.updateMatrixWorld(), c))
              Z.style.cssText =
                "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
              const Fe = A(te.current, R, D);
              Z.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Fe[0]}px,${Fe[1]}px,0);transform-origin:0 0;`;
            }
            return (
              Me && (r ? Me.prepend(Z) : Me.appendChild(Z)),
              () => {
                Me && Me.removeChild(Z), Ye.unmount();
              }
            );
          }
        }, [Me, c]),
        j.useLayoutEffect(() => {
          w && (Z.className = w);
        }, [w]);
      const Ce = j.useMemo(
          () =>
            c
              ? {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: D.width,
                  height: D.height,
                  transformStyle: "preserve-3d",
                  pointerEvents: "none",
                }
              : {
                  position: "absolute",
                  transform: s ? "translate3d(-50%,-50%,0)" : "none",
                  ...(o && {
                    top: -D.height / 2,
                    left: -D.width / 2,
                    width: D.width,
                    height: D.height,
                  }),
                  ...t,
                },
          [t, s, o, D, c]
        ),
        Se = j.useMemo(() => ({ position: "absolute", pointerEvents: C }), [C]);
      j.useLayoutEffect(() => {
        if (((re.current = !1), c)) {
          var Ye;
          (Ye = K.current) == null ||
            Ye.render(
              j.createElement(
                "div",
                { ref: F, style: Ce },
                j.createElement(
                  "div",
                  { ref: se, style: Se },
                  j.createElement("div", {
                    ref: P,
                    className: i,
                    style: t,
                    children: n,
                  })
                )
              )
            );
        } else {
          var Fe;
          (Fe = K.current) == null ||
            Fe.render(
              j.createElement("div", {
                ref: P,
                style: Ce,
                className: i,
                children: n,
              })
            );
        }
      });
      const Xe = j.useRef(!0);
      qm((Ye) => {
        if (te.current) {
          R.updateMatrixWorld(), te.current.updateWorldMatrix(!0, !1);
          const Fe = c ? Y.current : A(te.current, R, D);
          if (
            c ||
            Math.abs(O.current - R.zoom) > e ||
            Math.abs(Y.current[0] - Fe[0]) > e ||
            Math.abs(Y.current[1] - Fe[1]) > e
          ) {
            const de = pj(te.current, R);
            let ce = !1;
            xe &&
              (Array.isArray(d)
                ? (ce = d.map((J) => J.current))
                : d !== "blending" && (ce = [T]));
            const k = Xe.current;
            if (ce) {
              const J = mj(te.current, R, G, ce);
              Xe.current = J && !de;
            } else Xe.current = !de;
            k !== Xe.current &&
              (p
                ? p(!Xe.current)
                : (Z.style.display = Xe.current ? "block" : "none"));
            const Ve = Math.floor(g[0] / 2),
              we = d ? (xe ? [g[0], Ve] : [Ve - 1, 0]) : g;
            if (((Z.style.zIndex = `${vj(te.current, R, we)}`), c)) {
              const [J, Te] = [D.width / 2, D.height / 2],
                st = R.projectionMatrix.elements[5] * Te,
                {
                  isOrthographicCamera: Le,
                  top: U,
                  left: L,
                  bottom: ie,
                  right: fe,
                } = R,
                ye = yj(R.matrixWorldInverse),
                me = Le
                  ? `scale(${st})translate(${cw(-(fe + L) / 2)}px,${cw(
                      (U + ie) / 2
                    )}px)`
                  : `translateZ(${st}px)`;
              let Pe = te.current.matrixWorld;
              u &&
                ((Pe = R.matrixWorldInverse
                  .clone()
                  .transpose()
                  .copyPosition(Pe)
                  .scale(te.current.scale)),
                (Pe.elements[3] = Pe.elements[7] = Pe.elements[11] = 0),
                (Pe.elements[15] = 1)),
                (Z.style.width = D.width + "px"),
                (Z.style.height = D.height + "px"),
                (Z.style.perspective = Le ? "" : `${st}px`),
                F.current &&
                  se.current &&
                  ((F.current.style.transform = `${me}${ye}translate(${J}px,${Te}px)`),
                  (se.current.style.transform = _j(Pe, 1 / ((l || 10) / 400))));
            } else {
              const J = l === void 0 ? 1 : gj(te.current, R) * l;
              Z.style.transform = `translate3d(${Fe[0]}px,${Fe[1]}px,0) scale(${J})`;
            }
            (Y.current = Fe), (O.current = R.zoom);
          }
        }
        if (!xe && De.current && !re.current)
          if (c) {
            if (F.current) {
              const Fe = F.current.children[0];
              if (
                Fe != null &&
                Fe.clientWidth &&
                Fe != null &&
                Fe.clientHeight
              ) {
                const { isOrthographicCamera: de } = R;
                if (de || x)
                  b.scale &&
                    (Array.isArray(b.scale)
                      ? b.scale instanceof z
                        ? De.current.scale.copy(b.scale.clone().divideScalar(1))
                        : De.current.scale.set(
                            1 / b.scale[0],
                            1 / b.scale[1],
                            1 / b.scale[2]
                          )
                      : De.current.scale.setScalar(1 / b.scale));
                else {
                  const ce = (l || 10) / 400,
                    k = Fe.clientWidth * ce,
                    Ve = Fe.clientHeight * ce;
                  De.current.scale.set(k, Ve, 1);
                }
                re.current = !0;
              }
            }
          } else {
            const Fe = Z.children[0];
            if (Fe != null && Fe.clientWidth && Fe != null && Fe.clientHeight) {
              const de = 1 / q.factor,
                ce = Fe.clientWidth * de,
                k = Fe.clientHeight * de;
              De.current.scale.set(ce, k, 1), (re.current = !0);
            }
            De.current.lookAt(Ye.camera.position);
          }
      });
      const et = j.useMemo(
        () => ({
          vertexShader: c
            ? void 0
            : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
          fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
        }),
        [c]
      );
      return j.createElement(
        "group",
        za({}, b, { ref: te }),
        d &&
          !xe &&
          j.createElement(
            "mesh",
            { castShadow: m, receiveShadow: v, ref: De },
            x || j.createElement("planeGeometry", null),
            _ ||
              j.createElement("shaderMaterial", {
                side: Vs,
                vertexShader: et.vertexShader,
                fragmentShader: et.fragmentShader,
              })
          )
      );
    }
  ),
  LB = (n) => {
    let e;
    const t = new Set(),
      i = (u, c) => {
        const d = typeof u == "function" ? u(e) : u;
        if (!Object.is(d, e)) {
          const p = e;
          (e =
            c ?? (typeof d != "object" || d === null)
              ? d
              : Object.assign({}, e, d)),
            t.forEach((m) => m(e, p));
        }
      },
      r = () => e,
      a = {
        setState: i,
        getState: r,
        getInitialState: () => l,
        subscribe: (u) => (t.add(u), () => t.delete(u)),
      },
      l = (e = n(i, r, a));
    return a;
  },
  Sj = (n) => (n ? LB(n) : LB),
  Mj = (n) => n;
function wj(n, e = Mj) {
  const t = zr.useSyncExternalStore(
    n.subscribe,
    () => e(n.getState()),
    () => e(n.getInitialState())
  );
  return zr.useDebugValue(t), t;
}
const FB = (n) => {
    const e = Sj(n),
      t = (i) => wj(e, i);
    return Object.assign(t, e), t;
  },
  Ej = (n) => (n ? FB(n) : FB);
let Ud = 0;
const Tj = Ej(
    (n) => (
      (Jf.onStart = (e, t, i) => {
        n({
          active: !0,
          item: e,
          loaded: t,
          total: i,
          progress: ((t - Ud) / (i - Ud)) * 100,
        });
      }),
      (Jf.onLoad = () => {
        n({ active: !1 });
      }),
      (Jf.onError = (e) => n((t) => ({ errors: [...t.errors, e] }))),
      (Jf.onProgress = (e, t, i) => {
        t === i && (Ud = i),
          n({
            active: !0,
            item: e,
            loaded: t,
            total: i,
            progress: ((t - Ud) / (i - Ud)) * 100 || 100,
          });
      }),
      { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 }
    )
  ),
  Cj = (() => parseInt(Xh.replace(/\D+/g, "")))();
function NB(n, e) {
  if (e === JF)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      n
    );
  if (e === s_ || e === cT) {
    let t = n.getIndex();
    if (t === null) {
      const o = [],
        a = n.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++) o.push(l);
        n.setIndex(o), (t = n.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          n
        );
    }
    const i = t.count - 2,
      r = [];
    if (t)
      if (e === s_)
        for (let o = 1; o <= i; o++)
          r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1));
      else
        for (let o = 0; o < i; o++)
          o % 2 === 0
            ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2)))
            : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
    r.length / 3 !== i &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = n.clone();
    return s.setIndex(r), s.clearGroups(), s;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      n
    );
}
var bj = Object.defineProperty,
  Rj = (n, e, t) =>
    e in n
      ? bj(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  Pj = (n, e, t) => (Rj(n, typeof e != "symbol" ? e + "" : e, t), t);
class Bj {
  constructor() {
    Pj(this, "_listeners");
  }
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
var Ij = Object.defineProperty,
  Dj = (n, e, t) =>
    e in n
      ? Ij(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  At = (n, e, t) => (Dj(n, typeof e != "symbol" ? e + "" : e, t), t);
const av = new Fc(),
  OB = new ma(),
  Lj = Math.cos(70 * (Math.PI / 180)),
  UB = (n, e) => ((n % e) + e) % e;
let Fj = class extends Bj {
  constructor(e, t) {
    super(),
      At(this, "object"),
      At(this, "domElement"),
      At(this, "enabled", !0),
      At(this, "target", new z()),
      At(this, "minDistance", 0),
      At(this, "maxDistance", 1 / 0),
      At(this, "minZoom", 0),
      At(this, "maxZoom", 1 / 0),
      At(this, "minPolarAngle", 0),
      At(this, "maxPolarAngle", Math.PI),
      At(this, "minAzimuthAngle", -1 / 0),
      At(this, "maxAzimuthAngle", 1 / 0),
      At(this, "enableDamping", !1),
      At(this, "dampingFactor", 0.05),
      At(this, "enableZoom", !0),
      At(this, "zoomSpeed", 1),
      At(this, "enableRotate", !0),
      At(this, "rotateSpeed", 1),
      At(this, "enablePan", !0),
      At(this, "panSpeed", 1),
      At(this, "screenSpacePanning", !0),
      At(this, "keyPanSpeed", 7),
      At(this, "zoomToCursor", !1),
      At(this, "autoRotate", !1),
      At(this, "autoRotateSpeed", 2),
      At(this, "reverseOrbit", !1),
      At(this, "reverseHorizontalOrbit", !1),
      At(this, "reverseVerticalOrbit", !1),
      At(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      At(this, "mouseButtons", {
        LEFT: Pu.ROTATE,
        MIDDLE: Pu.DOLLY,
        RIGHT: Pu.PAN,
      }),
      At(this, "touches", { ONE: Bu.ROTATE, TWO: Bu.DOLLY_PAN }),
      At(this, "target0"),
      At(this, "position0"),
      At(this, "zoom0"),
      At(this, "_domElementKeyEvents", null),
      At(this, "getPolarAngle"),
      At(this, "getAzimuthalAngle"),
      At(this, "setPolarAngle"),
      At(this, "setAzimuthalAngle"),
      At(this, "getDistance"),
      At(this, "getZoomScale"),
      At(this, "listenToKeyEvents"),
      At(this, "stopListenToKeyEvents"),
      At(this, "saveState"),
      At(this, "reset"),
      At(this, "update"),
      At(this, "connect"),
      At(this, "dispose"),
      At(this, "dollyIn"),
      At(this, "dollyOut"),
      At(this, "getScale"),
      At(this, "setScale"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => c.phi),
      (this.getAzimuthalAngle = () => c.theta),
      (this.setPolarAngle = (X) => {
        let pe = UB(X, 2 * Math.PI),
          He = c.phi;
        He < 0 && (He += 2 * Math.PI), pe < 0 && (pe += 2 * Math.PI);
        let V = Math.abs(pe - He);
        2 * Math.PI - V < V &&
          (pe < He ? (pe += 2 * Math.PI) : (He += 2 * Math.PI)),
          (d.phi = pe - He),
          i.update();
      }),
      (this.setAzimuthalAngle = (X) => {
        let pe = UB(X, 2 * Math.PI),
          He = c.theta;
        He < 0 && (He += 2 * Math.PI), pe < 0 && (pe += 2 * Math.PI);
        let V = Math.abs(pe - He);
        2 * Math.PI - V < V &&
          (pe < He ? (pe += 2 * Math.PI) : (He += 2 * Math.PI)),
          (d.theta = pe - He),
          i.update();
      }),
      (this.getDistance = () => i.object.position.distanceTo(i.target)),
      (this.listenToKeyEvents = (X) => {
        X.addEventListener("keydown", Ie), (this._domElementKeyEvents = X);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Ie),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object.zoom);
      }),
      (this.reset = () => {
        i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          (i.object.zoom = i.zoom0),
          i.object.updateProjectionMatrix(),
          i.dispatchEvent(r),
          i.update(),
          (l = a.NONE);
      }),
      (this.update = (() => {
        const X = new z(),
          pe = new z(0, 1, 0),
          He = new Ri().setFromUnitVectors(e.up, pe),
          V = He.clone().invert(),
          be = new z(),
          ue = new Ri(),
          ge = 2 * Math.PI;
        return function () {
          const ke = i.object.position;
          He.setFromUnitVectors(e.up, pe),
            V.copy(He).invert(),
            X.copy(ke).sub(i.target),
            X.applyQuaternion(He),
            c.setFromVector3(X),
            i.autoRotate && l === a.NONE && q(G()),
            i.enableDamping
              ? ((c.theta += d.theta * i.dampingFactor),
                (c.phi += d.phi * i.dampingFactor))
              : ((c.theta += d.theta), (c.phi += d.phi));
          let ft = i.minAzimuthAngle,
            Ct = i.maxAzimuthAngle;
          isFinite(ft) &&
            isFinite(Ct) &&
            (ft < -Math.PI ? (ft += ge) : ft > Math.PI && (ft -= ge),
            Ct < -Math.PI ? (Ct += ge) : Ct > Math.PI && (Ct -= ge),
            ft <= Ct
              ? (c.theta = Math.max(ft, Math.min(Ct, c.theta)))
              : (c.theta =
                  c.theta > (ft + Ct) / 2
                    ? Math.max(ft, c.theta)
                    : Math.min(Ct, c.theta))),
            (c.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, c.phi)
            )),
            c.makeSafe(),
            i.enableDamping === !0
              ? i.target.addScaledVector(m, i.dampingFactor)
              : i.target.add(m),
            (i.zoomToCursor && R) || i.object.isOrthographicCamera
              ? (c.radius = De(c.radius))
              : (c.radius = De(c.radius * p)),
            X.setFromSpherical(c),
            X.applyQuaternion(V),
            ke.copy(i.target).add(X),
            i.object.matrixAutoUpdate || i.object.updateMatrix(),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((d.theta *= 1 - i.dampingFactor),
                (d.phi *= 1 - i.dampingFactor),
                m.multiplyScalar(1 - i.dampingFactor))
              : (d.set(0, 0, 0), m.set(0, 0, 0));
          let cn = !1;
          if (i.zoomToCursor && R) {
            let We = null;
            if (i.object instanceof bn && i.object.isPerspectiveCamera) {
              const nt = X.length();
              We = De(nt * p);
              const Et = nt - We;
              i.object.position.addScaledVector(P, Et),
                i.object.updateMatrixWorld();
            } else if (i.object.isOrthographicCamera) {
              const nt = new z(I.x, I.y, 0);
              nt.unproject(i.object),
                (i.object.zoom = Math.max(
                  i.minZoom,
                  Math.min(i.maxZoom, i.object.zoom / p)
                )),
                i.object.updateProjectionMatrix(),
                (cn = !0);
              const Et = new z(I.x, I.y, 0);
              Et.unproject(i.object),
                i.object.position.sub(Et).add(nt),
                i.object.updateMatrixWorld(),
                (We = X.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (i.zoomToCursor = !1);
            We !== null &&
              (i.screenSpacePanning
                ? i.target
                    .set(0, 0, -1)
                    .transformDirection(i.object.matrix)
                    .multiplyScalar(We)
                    .add(i.object.position)
                : (av.origin.copy(i.object.position),
                  av.direction
                    .set(0, 0, -1)
                    .transformDirection(i.object.matrix),
                  Math.abs(i.object.up.dot(av.direction)) < Lj
                    ? e.lookAt(i.target)
                    : (OB.setFromNormalAndCoplanarPoint(i.object.up, i.target),
                      av.intersectPlane(OB, i.target))));
          } else
            i.object instanceof yo &&
              i.object.isOrthographicCamera &&
              ((cn = p !== 1),
              cn &&
                ((i.object.zoom = Math.max(
                  i.minZoom,
                  Math.min(i.maxZoom, i.object.zoom / p)
                )),
                i.object.updateProjectionMatrix()));
          return (
            (p = 1),
            (R = !1),
            cn ||
            be.distanceToSquared(i.object.position) > u ||
            8 * (1 - ue.dot(i.object.quaternion)) > u
              ? (i.dispatchEvent(r),
                be.copy(i.object.position),
                ue.copy(i.object.quaternion),
                (cn = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (X) => {
        (i.domElement = X),
          (i.domElement.style.touchAction = "none"),
          i.domElement.addEventListener("contextmenu", Re),
          i.domElement.addEventListener("pointerdown", L),
          i.domElement.addEventListener("pointercancel", fe),
          i.domElement.addEventListener("wheel", Pe);
      }),
      (this.dispose = () => {
        var X, pe, He, V, be, ue;
        i.domElement && (i.domElement.style.touchAction = "auto"),
          (X = i.domElement) == null ||
            X.removeEventListener("contextmenu", Re),
          (pe = i.domElement) == null ||
            pe.removeEventListener("pointerdown", L),
          (He = i.domElement) == null ||
            He.removeEventListener("pointercancel", fe),
          (V = i.domElement) == null || V.removeEventListener("wheel", Pe),
          (be = i.domElement) == null ||
            be.ownerDocument.removeEventListener("pointermove", ie),
          (ue = i.domElement) == null ||
            ue.ownerDocument.removeEventListener("pointerup", fe),
          i._domElementKeyEvents !== null &&
            i._domElementKeyEvents.removeEventListener("keydown", Ie);
      });
    const i = this,
      r = { type: "change" },
      s = { type: "start" },
      o = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let l = a.NONE;
    const u = 1e-6,
      c = new iw(),
      d = new iw();
    let p = 1;
    const m = new z(),
      v = new Ae(),
      _ = new Ae(),
      x = new Ae(),
      g = new Ae(),
      A = new Ae(),
      S = new Ae(),
      w = new Ae(),
      C = new Ae(),
      b = new Ae(),
      P = new z(),
      I = new Ae();
    let R = !1;
    const T = [],
      D = {};
    function G() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
    }
    function W() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function q(X) {
      i.reverseOrbit || i.reverseHorizontalOrbit
        ? (d.theta += X)
        : (d.theta -= X);
    }
    function Z(X) {
      i.reverseOrbit || i.reverseVerticalOrbit ? (d.phi += X) : (d.phi -= X);
    }
    const K = (() => {
        const X = new z();
        return function (He, V) {
          X.setFromMatrixColumn(V, 0), X.multiplyScalar(-He), m.add(X);
        };
      })(),
      te = (() => {
        const X = new z();
        return function (He, V) {
          i.screenSpacePanning === !0
            ? X.setFromMatrixColumn(V, 1)
            : (X.setFromMatrixColumn(V, 0), X.crossVectors(i.object.up, X)),
            X.multiplyScalar(He),
            m.add(X);
        };
      })(),
      O = (() => {
        const X = new z();
        return function (He, V) {
          const be = i.domElement;
          if (be && i.object instanceof bn && i.object.isPerspectiveCamera) {
            const ue = i.object.position;
            X.copy(ue).sub(i.target);
            let ge = X.length();
            (ge *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              K((2 * He * ge) / be.clientHeight, i.object.matrix),
              te((2 * V * ge) / be.clientHeight, i.object.matrix);
          } else
            be && i.object instanceof yo && i.object.isOrthographicCamera
              ? (K(
                  (He * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    be.clientWidth,
                  i.object.matrix
                ),
                te(
                  (V * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    be.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1));
        };
      })();
    function Y(X) {
      (i.object instanceof bn && i.object.isPerspectiveCamera) ||
      (i.object instanceof yo && i.object.isOrthographicCamera)
        ? (p = X)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function F(X) {
      Y(p / X);
    }
    function se(X) {
      Y(p * X);
    }
    function Me(X) {
      if (!i.zoomToCursor || !i.domElement) return;
      R = !0;
      const pe = i.domElement.getBoundingClientRect(),
        He = X.clientX - pe.left,
        V = X.clientY - pe.top,
        be = pe.width,
        ue = pe.height;
      (I.x = (He / be) * 2 - 1),
        (I.y = -(V / ue) * 2 + 1),
        P.set(I.x, I.y, 1)
          .unproject(i.object)
          .sub(i.object.position)
          .normalize();
    }
    function De(X) {
      return Math.max(i.minDistance, Math.min(i.maxDistance, X));
    }
    function re(X) {
      v.set(X.clientX, X.clientY);
    }
    function xe(X) {
      Me(X), w.set(X.clientX, X.clientY);
    }
    function Ce(X) {
      g.set(X.clientX, X.clientY);
    }
    function Se(X) {
      _.set(X.clientX, X.clientY),
        x.subVectors(_, v).multiplyScalar(i.rotateSpeed);
      const pe = i.domElement;
      pe &&
        (q((2 * Math.PI * x.x) / pe.clientHeight),
        Z((2 * Math.PI * x.y) / pe.clientHeight)),
        v.copy(_),
        i.update();
    }
    function Xe(X) {
      C.set(X.clientX, X.clientY),
        b.subVectors(C, w),
        b.y > 0 ? F(W()) : b.y < 0 && se(W()),
        w.copy(C),
        i.update();
    }
    function et(X) {
      A.set(X.clientX, X.clientY),
        S.subVectors(A, g).multiplyScalar(i.panSpeed),
        O(S.x, S.y),
        g.copy(A),
        i.update();
    }
    function Ye(X) {
      Me(X), X.deltaY < 0 ? se(W()) : X.deltaY > 0 && F(W()), i.update();
    }
    function Fe(X) {
      let pe = !1;
      switch (X.code) {
        case i.keys.UP:
          O(0, i.keyPanSpeed), (pe = !0);
          break;
        case i.keys.BOTTOM:
          O(0, -i.keyPanSpeed), (pe = !0);
          break;
        case i.keys.LEFT:
          O(i.keyPanSpeed, 0), (pe = !0);
          break;
        case i.keys.RIGHT:
          O(-i.keyPanSpeed, 0), (pe = !0);
          break;
      }
      pe && (X.preventDefault(), i.update());
    }
    function de() {
      if (T.length == 1) v.set(T[0].pageX, T[0].pageY);
      else {
        const X = 0.5 * (T[0].pageX + T[1].pageX),
          pe = 0.5 * (T[0].pageY + T[1].pageY);
        v.set(X, pe);
      }
    }
    function ce() {
      if (T.length == 1) g.set(T[0].pageX, T[0].pageY);
      else {
        const X = 0.5 * (T[0].pageX + T[1].pageX),
          pe = 0.5 * (T[0].pageY + T[1].pageY);
        g.set(X, pe);
      }
    }
    function k() {
      const X = T[0].pageX - T[1].pageX,
        pe = T[0].pageY - T[1].pageY,
        He = Math.sqrt(X * X + pe * pe);
      w.set(0, He);
    }
    function Ve() {
      i.enableZoom && k(), i.enablePan && ce();
    }
    function we() {
      i.enableZoom && k(), i.enableRotate && de();
    }
    function J(X) {
      if (T.length == 1) _.set(X.pageX, X.pageY);
      else {
        const He = Ke(X),
          V = 0.5 * (X.pageX + He.x),
          be = 0.5 * (X.pageY + He.y);
        _.set(V, be);
      }
      x.subVectors(_, v).multiplyScalar(i.rotateSpeed);
      const pe = i.domElement;
      pe &&
        (q((2 * Math.PI * x.x) / pe.clientHeight),
        Z((2 * Math.PI * x.y) / pe.clientHeight)),
        v.copy(_);
    }
    function Te(X) {
      if (T.length == 1) A.set(X.pageX, X.pageY);
      else {
        const pe = Ke(X),
          He = 0.5 * (X.pageX + pe.x),
          V = 0.5 * (X.pageY + pe.y);
        A.set(He, V);
      }
      S.subVectors(A, g).multiplyScalar(i.panSpeed), O(S.x, S.y), g.copy(A);
    }
    function st(X) {
      const pe = Ke(X),
        He = X.pageX - pe.x,
        V = X.pageY - pe.y,
        be = Math.sqrt(He * He + V * V);
      C.set(0, be),
        b.set(0, Math.pow(C.y / w.y, i.zoomSpeed)),
        F(b.y),
        w.copy(C);
    }
    function Le(X) {
      i.enableZoom && st(X), i.enablePan && Te(X);
    }
    function U(X) {
      i.enableZoom && st(X), i.enableRotate && J(X);
    }
    function L(X) {
      var pe, He;
      i.enabled !== !1 &&
        (T.length === 0 &&
          ((pe = i.domElement) == null ||
            pe.ownerDocument.addEventListener("pointermove", ie),
          (He = i.domElement) == null ||
            He.ownerDocument.addEventListener("pointerup", fe)),
        Ne(X),
        X.pointerType === "touch" ? ze(X) : ye(X));
    }
    function ie(X) {
      i.enabled !== !1 && (X.pointerType === "touch" ? Mt(X) : me(X));
    }
    function fe(X) {
      var pe, He, V;
      mt(X),
        T.length === 0 &&
          ((pe = i.domElement) == null || pe.releasePointerCapture(X.pointerId),
          (He = i.domElement) == null ||
            He.ownerDocument.removeEventListener("pointermove", ie),
          (V = i.domElement) == null ||
            V.ownerDocument.removeEventListener("pointerup", fe)),
        i.dispatchEvent(o),
        (l = a.NONE);
    }
    function ye(X) {
      let pe;
      switch (X.button) {
        case 0:
          pe = i.mouseButtons.LEFT;
          break;
        case 1:
          pe = i.mouseButtons.MIDDLE;
          break;
        case 2:
          pe = i.mouseButtons.RIGHT;
          break;
        default:
          pe = -1;
      }
      switch (pe) {
        case Pu.DOLLY:
          if (i.enableZoom === !1) return;
          xe(X), (l = a.DOLLY);
          break;
        case Pu.ROTATE:
          if (X.ctrlKey || X.metaKey || X.shiftKey) {
            if (i.enablePan === !1) return;
            Ce(X), (l = a.PAN);
          } else {
            if (i.enableRotate === !1) return;
            re(X), (l = a.ROTATE);
          }
          break;
        case Pu.PAN:
          if (X.ctrlKey || X.metaKey || X.shiftKey) {
            if (i.enableRotate === !1) return;
            re(X), (l = a.ROTATE);
          } else {
            if (i.enablePan === !1) return;
            Ce(X), (l = a.PAN);
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && i.dispatchEvent(s);
    }
    function me(X) {
      if (i.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (i.enableRotate === !1) return;
            Se(X);
            break;
          case a.DOLLY:
            if (i.enableZoom === !1) return;
            Xe(X);
            break;
          case a.PAN:
            if (i.enablePan === !1) return;
            et(X);
            break;
        }
    }
    function Pe(X) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        (l !== a.NONE && l !== a.ROTATE) ||
        (X.preventDefault(), i.dispatchEvent(s), Ye(X), i.dispatchEvent(o));
    }
    function Ie(X) {
      i.enabled === !1 || i.enablePan === !1 || Fe(X);
    }
    function ze(X) {
      switch ((dt(X), T.length)) {
        case 1:
          switch (i.touches.ONE) {
            case Bu.ROTATE:
              if (i.enableRotate === !1) return;
              de(), (l = a.TOUCH_ROTATE);
              break;
            case Bu.PAN:
              if (i.enablePan === !1) return;
              ce(), (l = a.TOUCH_PAN);
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case Bu.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              Ve(), (l = a.TOUCH_DOLLY_PAN);
              break;
            case Bu.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              we(), (l = a.TOUCH_DOLLY_ROTATE);
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && i.dispatchEvent(s);
    }
    function Mt(X) {
      switch ((dt(X), l)) {
        case a.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          J(X), i.update();
          break;
        case a.TOUCH_PAN:
          if (i.enablePan === !1) return;
          Te(X), i.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          Le(X), i.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          U(X), i.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function Re(X) {
      i.enabled !== !1 && X.preventDefault();
    }
    function Ne(X) {
      T.push(X);
    }
    function mt(X) {
      delete D[X.pointerId];
      for (let pe = 0; pe < T.length; pe++)
        if (T[pe].pointerId == X.pointerId) {
          T.splice(pe, 1);
          return;
        }
    }
    function dt(X) {
      let pe = D[X.pointerId];
      pe === void 0 && ((pe = new Ae()), (D[X.pointerId] = pe)),
        pe.set(X.pageX, X.pageY);
    }
    function Ke(X) {
      const pe = X.pointerId === T[0].pointerId ? T[1] : T[0];
      return D[pe.pointerId];
    }
    (this.dollyIn = (X = W()) => {
      se(X), i.update();
    }),
      (this.dollyOut = (X = W()) => {
        F(X), i.update();
      }),
      (this.getScale = () => p),
      (this.setScale = (X) => {
        Y(X), i.update();
      }),
      (this.getZoomScale = () => W()),
      t !== void 0 && this.connect(t),
      this.update();
  }
};
function c_(n) {
  if (typeof TextDecoder < "u") return new TextDecoder().decode(n);
  let e = "";
  for (let t = 0, i = n.length; t < i; t++) e += String.fromCharCode(n[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const Qu = "srgb",
  Ra = "srgb-linear",
  kB = 3001,
  Nj = 3e3;
class QT extends rr {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new Hj(t);
      }),
      this.register(function (t) {
        return new Gj(t);
      }),
      this.register(function (t) {
        return new Zj(t);
      }),
      this.register(function (t) {
        return new qj(t);
      }),
      this.register(function (t) {
        return new $j(t);
      }),
      this.register(function (t) {
        return new Wj(t);
      }),
      this.register(function (t) {
        return new Xj(t);
      }),
      this.register(function (t) {
        return new Jj(t);
      }),
      this.register(function (t) {
        return new jj(t);
      }),
      this.register(function (t) {
        return new zj(t);
      }),
      this.register(function (t) {
        return new Yj(t);
      }),
      this.register(function (t) {
        return new Vj(t);
      }),
      this.register(function (t) {
        return new Qj(t);
      }),
      this.register(function (t) {
        return new Kj(t);
      }),
      this.register(function (t) {
        return new Uj(t);
      }),
      this.register(function (t) {
        return new eY(t);
      }),
      this.register(function (t) {
        return new tY(t);
      });
  }
  load(e, t, i, r) {
    const s = this;
    let o;
    if (this.resourcePath !== "") o = this.resourcePath;
    else if (this.path !== "") {
      const u = Il.extractUrlBase(e);
      o = Il.resolveURL(u, this.path);
    } else o = Il.extractUrlBase(e);
    this.manager.itemStart(e);
    const a = function (u) {
        r ? r(u) : console.error(u),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      l = new _s(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (u) {
          try {
            s.parse(
              u,
              o,
              function (c) {
                t(c), s.manager.itemEnd(e);
              },
              a
            );
          } catch (c) {
            a(c);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, r) {
    let s;
    const o = {},
      a = {};
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (c_(new Uint8Array(e.slice(0, 4))) === PO) {
        try {
          o[jt.KHR_BINARY_GLTF] = new nY(e);
        } catch (c) {
          r && r(c);
          return;
        }
        s = JSON.parse(o[jt.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(c_(new Uint8Array(e)));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      r &&
        r(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const l = new mY(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const c = this.pluginCallbacks[u](l);
      c.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (a[c.name] = c),
        (o[c.name] = !0);
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const c = s.extensionsUsed[u],
          d = s.extensionsRequired || [];
        switch (c) {
          case jt.KHR_MATERIALS_UNLIT:
            o[c] = new kj();
            break;
          case jt.KHR_DRACO_MESH_COMPRESSION:
            o[c] = new iY(s, this.dracoLoader);
            break;
          case jt.KHR_TEXTURE_TRANSFORM:
            o[c] = new rY();
            break;
          case jt.KHR_MESH_QUANTIZATION:
            o[c] = new sY();
            break;
          default:
            d.indexOf(c) >= 0 &&
              a[c] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + c + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(a), l.parse(i, r);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.parse(e, t, r, s);
    });
  }
}
function Oj() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const jt = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class Uj {
  constructor(e) {
    (this.parser = e),
      (this.name = jt.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let r = t.cache.get(i);
    if (r) return r;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let u;
    const c = new Ze(16777215);
    l.color !== void 0 && c.setRGB(l.color[0], l.color[1], l.color[2], Ra);
    const d = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (u = new kT(c)), u.target.position.set(0, 0, -1), u.add(u.target);
        break;
      case "point":
        (u = new UT(c)), (u.distance = d);
        break;
      case "spot":
        (u = new OT(c)),
          (u.distance = d),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (u.angle = l.spot.outerConeAngle),
          (u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          u.target.position.set(0, 0, -1),
          u.add(u.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      u.position.set(0, 0, 0),
      (u.decay = 2),
      ha(u, l),
      l.intensity !== void 0 && (u.intensity = l.intensity),
      (u.name = t.createUniqueName(l.name || "light_" + e)),
      (r = Promise.resolve(u)),
      t.cache.add(i, r),
      r
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      s = i.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return i._getNodeRef(t.cache, a, l);
        });
  }
}
class kj {
  constructor() {
    this.name = jt.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return hs;
  }
  extendParams(e, t, i) {
    const r = [];
    (e.color = new Ze(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], Ra), (e.opacity = o[3]);
      }
      s.baseColorTexture !== void 0 &&
        r.push(i.assignTexture(e, "map", s.baseColorTexture, Qu));
    }
    return Promise.all(r);
  }
}
class zj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class Hj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Ae(a, a);
    }
    return Promise.all(s);
  }
}
class Gj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return (
      (t.dispersion = s.dispersion !== void 0 ? s.dispersion : 0),
      Promise.resolve()
    );
  }
}
class Vj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class Wj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Ze(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const o = r.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], Ra);
    }
    return (
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Qu)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class Xj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class Jj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new Ze().setRGB(a[0], a[1], a[2], Ra)),
      Promise.all(s)
    );
  }
}
class jj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class Yj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Ze().setRGB(a[0], a[1], a[2], Ra)),
      o.specularColorTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "specularColorMap", o.specularColorTexture, Qu)
        ),
      Promise.all(s)
    );
  }
}
class Kj {
  constructor(e) {
    (this.parser = e), (this.name = jt.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      (t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1),
      o.bumpTexture !== void 0 &&
        s.push(i.assignTexture(t, "bumpMap", o.bumpTexture)),
      Promise.all(s)
    );
  }
}
class Qj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : eo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        s.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class Zj {
  constructor(e) {
    (this.parser = e), (this.name = jt.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name]) return null;
    const s = r.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class qj {
  constructor(e) {
    (this.parser = e),
      (this.name = jt.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const u = i.options.manager.getHandler(a.uri);
      u !== null && (l = u);
    }
    return this.detectSupport().then(function (u) {
      if (u) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class $j {
  constructor(e) {
    (this.parser = e),
      (this.name = jt.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const u = i.options.manager.getHandler(a.uri);
      u !== null && (l = u);
    }
    return this.detectSupport().then(function (u) {
      if (u) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class eY {
  constructor(e) {
    (this.name = jt.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        s = this.parser.getDependency("buffer", r.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (a) {
        const l = r.byteOffset || 0,
          u = r.byteLength || 0,
          c = r.count,
          d = r.byteStride,
          p = new Uint8Array(a, l, u);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(c, d, p, r.mode, r.filter)
              .then(function (m) {
                return m.buffer;
              })
          : o.ready.then(function () {
              const m = new ArrayBuffer(c * d);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(m),
                  c,
                  d,
                  p,
                  r.mode,
                  r.filter
                ),
                m
              );
            });
      });
    } else return null;
  }
}
class tY {
  constructor(e) {
    (this.name = jt.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const r = t.meshes[i.mesh];
    for (const u of r.primitives)
      if (
        u.mode !== Os.TRIANGLES &&
        u.mode !== Os.TRIANGLE_STRIP &&
        u.mode !== Os.TRIANGLE_FAN &&
        u.mode !== void 0
      )
        return null;
    const o = i.extensions[this.name].attributes,
      a = [],
      l = {};
    for (const u in o)
      a.push(
        this.parser
          .getDependency("accessor", o[u])
          .then((c) => ((l[u] = c), l[u]))
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((u) => {
          const c = u.pop(),
            d = c.isGroup ? c.children : [c],
            p = u[0].count,
            m = [];
          for (const v of d) {
            const _ = new _t(),
              x = new z(),
              g = new Ri(),
              A = new z(1, 1, 1),
              S = new xT(v.geometry, v.material, p);
            for (let w = 0; w < p; w++)
              l.TRANSLATION && x.fromBufferAttribute(l.TRANSLATION, w),
                l.ROTATION && g.fromBufferAttribute(l.ROTATION, w),
                l.SCALE && A.fromBufferAttribute(l.SCALE, w),
                S.setMatrixAt(w, _.compose(x, g, A));
            for (const w in l)
              if (w === "_COLOR_0") {
                const C = l[w];
                S.instanceColor = new wc(C.array, C.itemSize, C.normalized);
              } else
                w !== "TRANSLATION" &&
                  w !== "ROTATION" &&
                  w !== "SCALE" &&
                  v.geometry.setAttribute(w, l[w]);
            qt.prototype.copy.call(S, v),
              this.parser.assignFinalMaterial(S),
              m.push(S);
          }
          return c.isGroup ? (c.clear(), c.add(...m), c) : m[0];
        }));
  }
}
const PO = "glTF",
  kd = 12,
  zB = { JSON: 1313821514, BIN: 5130562 };
class nY {
  constructor(e) {
    (this.name = jt.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, kd);
    if (
      ((this.header = {
        magic: c_(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== PO)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - kd,
      r = new DataView(e, kd);
    let s = 0;
    for (; s < i; ) {
      const o = r.getUint32(s, !0);
      s += 4;
      const a = r.getUint32(s, !0);
      if (((s += 4), a === zB.JSON)) {
        const l = new Uint8Array(e, kd + s, o);
        this.content = c_(l);
      } else if (a === zB.BIN) {
        const l = kd + s;
        this.body = e.slice(l, l + o);
      }
      s += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class iY {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = jt.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json,
      r = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      u = {};
    for (const c in o) {
      const d = fw[c] || c.toLowerCase();
      a[d] = o[c];
    }
    for (const c in e.attributes) {
      const d = fw[c] || c.toLowerCase();
      if (o[c] !== void 0) {
        const p = i.accessors[e.attributes[c]],
          m = uh[p.componentType];
        (u[d] = m.name), (l[d] = p.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (c) {
      return new Promise(function (d, p) {
        r.decodeDracoFile(
          c,
          function (m) {
            for (const v in m.attributes) {
              const _ = m.attributes[v],
                x = l[v];
              x !== void 0 && (_.normalized = x);
            }
            d(m);
          },
          a,
          u,
          Ra,
          p
        );
      });
    });
  }
}
class rY {
  constructor() {
    this.name = jt.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class sY {
  constructor() {
    this.name = jt.KHR_MESH_QUANTIZATION;
  }
}
class BO extends Qh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r * 3 + r;
    for (let o = 0; o !== r; o++) t[o] = i[s + o];
    return t;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      u = a * 3,
      c = r - t,
      d = (i - t) / c,
      p = d * d,
      m = p * d,
      v = e * u,
      _ = v - u,
      x = -2 * m + 3 * p,
      g = m - p,
      A = 1 - x,
      S = g - p + d;
    for (let w = 0; w !== a; w++) {
      const C = o[_ + w + a],
        b = o[_ + w + l] * c,
        P = o[v + w + a],
        I = o[v + w] * c;
      s[w] = A * C + S * b + x * P + g * I;
    }
    return s;
  }
}
const oY = new Ri();
class aY extends BO {
  interpolate_(e, t, i, r) {
    const s = super.interpolate_(e, t, i, r);
    return oY.fromArray(s).normalize().toArray(s), s;
  }
}
const Os = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  uh = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  HB = { 9728: bi, 9729: Zn, 9984: tx, 9985: ah, 9986: Wu, 9987: Xs },
  GB = { 33071: fs, 33648: wh, 10497: zl },
  vS = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  fw = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(Cj >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  ll = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  lY = { CUBICSPLINE: void 0, LINEAR: Ch, STEP: Th },
  yS = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function uY(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new Qm({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Yo,
      })),
    n.DefaultMaterial
  );
}
function Mu(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function ha(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function cY(n, e, t) {
  let i = !1,
    r = !1,
    s = !1;
  for (let u = 0, c = e.length; u < c; u++) {
    const d = e[u];
    if (
      (d.POSITION !== void 0 && (i = !0),
      d.NORMAL !== void 0 && (r = !0),
      d.COLOR_0 !== void 0 && (s = !0),
      i && r && s)
    )
      break;
  }
  if (!i && !r && !s) return Promise.resolve(n);
  const o = [],
    a = [],
    l = [];
  for (let u = 0, c = e.length; u < c; u++) {
    const d = e[u];
    if (i) {
      const p =
        d.POSITION !== void 0
          ? t.getDependency("accessor", d.POSITION)
          : n.attributes.position;
      o.push(p);
    }
    if (r) {
      const p =
        d.NORMAL !== void 0
          ? t.getDependency("accessor", d.NORMAL)
          : n.attributes.normal;
      a.push(p);
    }
    if (s) {
      const p =
        d.COLOR_0 !== void 0
          ? t.getDependency("accessor", d.COLOR_0)
          : n.attributes.color;
      l.push(p);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (u) {
      const c = u[0],
        d = u[1],
        p = u[2];
      return (
        i && (n.morphAttributes.position = c),
        r && (n.morphAttributes.normal = d),
        s && (n.morphAttributes.color = p),
        (n.morphTargetsRelative = !0),
        n
      );
    }
  );
}
function fY(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let i = 0, r = t.length; i < r; i++)
        n.morphTargetDictionary[t[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function hY(n) {
  let e;
  const t = n.extensions && n.extensions[jt.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + _S(t.attributes))
      : (e = n.indices + ":" + _S(n.attributes) + ":" + n.mode),
    n.targets !== void 0)
  )
    for (let i = 0, r = n.targets.length; i < r; i++)
      e += ":" + _S(n.targets[i]);
  return e;
}
function _S(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
  return e;
}
function hw(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function dY(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const pY = new _t();
class mY {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new Oj()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      r = !1,
      s = -1;
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (r = navigator.userAgent.indexOf("Firefox") > -1),
      (s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || i || (r && s < 98)
        ? (this.textureLoader = new ON(this.options.manager))
        : (this.textureLoader = new XN(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new _s(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      r = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][r.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: r.asset,
            parser: i,
            userData: {},
          };
          return (
            Mu(s, a, r),
            ha(a, r),
            Promise.all(
              i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              for (const l of a.scenes) l.updateMatrixWorld();
              e(a);
            })
          );
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const r = i.clone(),
      s = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [u, c] of o.children.entries()) s(c, a.children[u]);
      };
    return s(i, r), (r.name += "_instance_" + e.uses[t]++), r;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      if (r) return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          r = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          if (
            ((r = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !r)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        r.map(function (s, o) {
          return i.getDependency(e, o);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[jt.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function (s, o) {
      i.load(Il.resolveURL(t.uri, r.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (i) {
      const r = t.byteLength || 0,
        s = t.byteOffset || 0;
      return i.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const o = vS[r.type],
        a = uh[r.componentType],
        l = r.normalized === !0,
        u = new a(r.count * o);
      return Promise.resolve(new rn(u, o, l));
    }
    const s = [];
    return (
      r.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", r.bufferView))
        : s.push(null),
      r.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = vS[r.type],
          u = uh[r.componentType],
          c = u.BYTES_PER_ELEMENT,
          d = c * l,
          p = r.byteOffset || 0,
          m =
            r.bufferView !== void 0
              ? i.bufferViews[r.bufferView].byteStride
              : void 0,
          v = r.normalized === !0;
        let _, x;
        if (m && m !== d) {
          const g = Math.floor(p / m),
            A =
              "InterleavedBuffer:" +
              r.bufferView +
              ":" +
              r.componentType +
              ":" +
              g +
              ":" +
              r.count;
          let S = t.cache.get(A);
          S ||
            ((_ = new u(a, g * m, (r.count * m) / c)),
            (S = new Vm(_, m / c)),
            t.cache.add(A, S)),
            (x = new Hl(S, l, (p % m) / c, v));
        } else a === null ? (_ = new u(r.count * l)) : (_ = new u(a, p, r.count * l)), (x = new rn(_, l, v));
        if (r.sparse !== void 0) {
          const g = vS.SCALAR,
            A = uh[r.sparse.indices.componentType],
            S = r.sparse.indices.byteOffset || 0,
            w = r.sparse.values.byteOffset || 0,
            C = new A(o[1], S, r.sparse.count * g),
            b = new u(o[2], w, r.sparse.count * l);
          a !== null && (x = new rn(x.array.slice(), x.itemSize, x.normalized));
          for (let P = 0, I = C.length; P < I; P++) {
            const R = C[P];
            if (
              (x.setX(R, b[P * l]),
              l >= 2 && x.setY(R, b[P * l + 1]),
              l >= 3 && x.setZ(R, b[P * l + 2]),
              l >= 4 && x.setW(R, b[P * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return x;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      s = t.textures[e].source,
      o = t.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const l = i.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, i) {
    const r = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const u = this.loadImageSource(t, i)
      .then(function (c) {
        (c.flipY = !1),
          (c.name = o.name || a.name || ""),
          c.name === "" &&
            typeof a.uri == "string" &&
            a.uri.startsWith("data:image/") === !1 &&
            (c.name = a.uri);
        const p = (s.samplers || {})[o.sampler] || {};
        return (
          (c.magFilter = HB[p.magFilter] || Zn),
          (c.minFilter = HB[p.minFilter] || Xs),
          (c.wrapS = GB[p.wrapS] || zl),
          (c.wrapT = GB[p.wrapT] || zl),
          r.associations.set(c, { textures: e }),
          c
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = u), u;
  }
  loadImageSource(e, t) {
    const i = this,
      r = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((d) => d.clone());
    const o = r.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      u = !1;
    if (o.bufferView !== void 0)
      l = i.getDependency("bufferView", o.bufferView).then(function (d) {
        u = !0;
        const p = new Blob([d], { type: o.mimeType });
        return (l = a.createObjectURL(p)), l;
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const c = Promise.resolve(l)
      .then(function (d) {
        return new Promise(function (p, m) {
          let v = p;
          t.isImageBitmapLoader === !0 &&
            (v = function (_) {
              const x = new Pn(_);
              (x.needsUpdate = !0), p(x);
            }),
            t.load(Il.resolveURL(d, s.path), v, void 0, m);
        });
      })
      .then(function (d) {
        return (
          u === !0 && a.revokeObjectURL(l),
          ha(d, o),
          (d.userData.mimeType = o.mimeType || dY(o.uri)),
          d
        );
      })
      .catch(function (d) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), d);
      });
    return (this.sourceCache[e] = c), c;
  }
  assignTexture(e, t, i, r) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (o) {
      if (!o) return null;
      if (
        (i.texCoord !== void 0 &&
          i.texCoord > 0 &&
          ((o = o.clone()), (o.channel = i.texCoord)),
        s.extensions[jt.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          i.extensions !== void 0
            ? i.extensions[jt.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = s.associations.get(o);
          (o = s.extensions[jt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l);
        }
      }
      return (
        r !== void 0 &&
          (typeof r == "number" && (r = r === kB ? Qu : Ra),
          "colorSpace" in o
            ? (o.colorSpace = r)
            : (o.encoding = r === Qu ? kB : Nj)),
        (e[t] = o),
        o
      );
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const r = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new Jm()),
        mi.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (i = l);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new ir()),
        mi.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        this.cache.add(a, l)),
        (i = l);
    }
    if (r || s || o) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      r && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l ||
        ((l = i.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        r &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(i))),
        (i = l);
    }
    e.material = i;
  }
  getMaterialType() {
    return Qm;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.materials[e];
    let o;
    const a = {},
      l = s.extensions || {},
      u = [];
    if (l[jt.KHR_MATERIALS_UNLIT]) {
      const d = r[jt.KHR_MATERIALS_UNLIT];
      (o = d.getMaterialType()), u.push(d.extendParams(a, s, t));
    } else {
      const d = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Ze(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(d.baseColorFactor))
      ) {
        const p = d.baseColorFactor;
        a.color.setRGB(p[0], p[1], p[2], Ra), (a.opacity = p[3]);
      }
      d.baseColorTexture !== void 0 &&
        u.push(t.assignTexture(a, "map", d.baseColorTexture, Qu)),
        (a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1),
        (a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1),
        d.metallicRoughnessTexture !== void 0 &&
          (u.push(
            t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)
          ),
          u.push(
            t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (p) {
          return p.getMaterialType && p.getMaterialType(e);
        })),
        u.push(
          Promise.all(
            this._invokeAll(function (p) {
              return p.extendMaterialParams && p.extendMaterialParams(e, a);
            })
          )
        );
    }
    s.doubleSided === !0 && (a.side = Vs);
    const c = s.alphaMode || yS.OPAQUE;
    if (
      (c === yS.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          c === yS.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== hs &&
        (u.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new Ae(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const d = s.normalTexture.scale;
      a.normalScale.set(d, d);
    }
    if (
      (s.occlusionTexture !== void 0 &&
        o !== hs &&
        (u.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 && o !== hs)
    ) {
      const d = s.emissiveFactor;
      a.emissive = new Ze().setRGB(d[0], d[1], d[2], Ra);
    }
    return (
      s.emissiveTexture !== void 0 &&
        o !== hs &&
        u.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Qu)),
      Promise.all(u).then(function () {
        const d = new o(a);
        return (
          s.name && (d.name = s.name),
          ha(d, s),
          t.associations.set(d, { materials: e }),
          s.extensions && Mu(r, d, s),
          d
        );
      })
    );
  }
  createUniqueName(e) {
    const t = $t.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      r = this.primitiveCache;
    function s(a) {
      return i[jt.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return VB(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a],
        c = hY(u),
        d = r[c];
      if (d) o.push(d.promise);
      else {
        let p;
        u.extensions && u.extensions[jt.KHR_DRACO_MESH_COMPRESSION]
          ? (p = s(u))
          : (p = VB(new Lt(), u, t)),
          (r[c] = { primitive: u, promise: p }),
          o.push(p);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.meshes[e],
      o = s.primitives,
      a = [];
    for (let l = 0, u = o.length; l < u; l++) {
      const c =
        o[l].material === void 0
          ? uY(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(c);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const u = l.slice(0, l.length - 1),
          c = l[l.length - 1],
          d = [];
        for (let m = 0, v = c.length; m < v; m++) {
          const _ = c[m],
            x = o[m];
          let g;
          const A = u[m];
          if (
            x.mode === Os.TRIANGLES ||
            x.mode === Os.TRIANGLE_STRIP ||
            x.mode === Os.TRIANGLE_FAN ||
            x.mode === void 0
          )
            (g = s.isSkinnedMesh === !0 ? new _T(_, A) : new qn(_, A)),
              g.isSkinnedMesh === !0 && g.normalizeSkinWeights(),
              x.mode === Os.TRIANGLE_STRIP
                ? (g.geometry = NB(g.geometry, cT))
                : x.mode === Os.TRIANGLE_FAN &&
                  (g.geometry = NB(g.geometry, s_));
          else if (x.mode === Os.LINES) g = new So(_, A);
          else if (x.mode === Os.LINE_STRIP) g = new ka(_, A);
          else if (x.mode === Os.LINE_LOOP) g = new AT(_, A);
          else if (x.mode === Os.POINTS) g = new ST(_, A);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + x.mode
            );
          Object.keys(g.geometry.morphAttributes).length > 0 && fY(g, s),
            (g.name = t.createUniqueName(s.name || "mesh_" + e)),
            ha(g, s),
            x.extensions && Mu(r, g, x),
            t.assignFinalMaterial(g),
            d.push(g);
        }
        for (let m = 0, v = d.length; m < v; m++)
          t.associations.set(d[m], { meshes: e, primitives: m });
        if (d.length === 1) return s.extensions && Mu(r, d[0], s), d[0];
        const p = new Sa();
        s.extensions && Mu(r, p, s), t.associations.set(p, { meshes: e });
        for (let m = 0, v = d.length; m < v; m++) p.add(d[m]);
        return p;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      r = i[i.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (t = new bn(
            iN.radToDeg(r.yfov),
            r.aspectRatio || 1,
            r.znear || 1,
            r.zfar || 2e6
          ))
        : i.type === "orthographic" &&
          (t = new yo(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      ha(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = [];
    for (let r = 0, s = t.joints.length; r < s; r++)
      i.push(this._loadNodeShallow(t.joints[r]));
    return (
      t.inverseBindMatrices !== void 0
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (r) {
        const s = r.pop(),
          o = r,
          a = [],
          l = [];
        for (let u = 0, c = o.length; u < c; u++) {
          const d = o[u];
          if (d) {
            a.push(d);
            const p = new _t();
            s !== null && p.fromArray(s.array, u * 16), l.push(p);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[u]
            );
        }
        return new Wm(a, l);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      i = this,
      r = t.animations[e],
      s = r.name ? r.name : "animation_" + e,
      o = [],
      a = [],
      l = [],
      u = [],
      c = [];
    for (let d = 0, p = r.channels.length; d < p; d++) {
      const m = r.channels[d],
        v = r.samplers[m.sampler],
        _ = m.target,
        x = _.node,
        g = r.parameters !== void 0 ? r.parameters[v.input] : v.input,
        A = r.parameters !== void 0 ? r.parameters[v.output] : v.output;
      _.node !== void 0 &&
        (o.push(this.getDependency("node", x)),
        a.push(this.getDependency("accessor", g)),
        l.push(this.getDependency("accessor", A)),
        u.push(v),
        c.push(_));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(u),
      Promise.all(c),
    ]).then(function (d) {
      const p = d[0],
        m = d[1],
        v = d[2],
        _ = d[3],
        x = d[4],
        g = [];
      for (let A = 0, S = p.length; A < S; A++) {
        const w = p[A],
          C = m[A],
          b = v[A],
          P = _[A],
          I = x[A];
        if (w === void 0) continue;
        w.updateMatrix && w.updateMatrix();
        const R = i._createAnimationTracks(w, C, b, P, I);
        if (R) for (let T = 0; T < R.length; T++) g.push(R[T]);
      }
      return new Ph(s, void 0, g);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e];
    return r.mesh === void 0
      ? null
      : i.getDependency("mesh", r.mesh).then(function (s) {
          const o = i._getNodeRef(i.meshCache, r.mesh, s);
          return (
            r.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, u = r.weights.length; l < u; l++)
                    a.morphTargetInfluences[l] = r.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e],
      s = i._loadNodeShallow(e),
      o = [],
      a = r.children || [];
    for (let u = 0, c = a.length; u < c; u++)
      o.push(i.getDependency("node", a[u]));
    const l =
      r.skin === void 0
        ? Promise.resolve(null)
        : i.getDependency("skin", r.skin);
    return Promise.all([s, Promise.all(o), l]).then(function (u) {
      const c = u[0],
        d = u[1],
        p = u[2];
      p !== null &&
        c.traverse(function (m) {
          m.isSkinnedMesh && m.bind(p, pY);
        });
      for (let m = 0, v = d.length; m < v; m++) c.add(d[m]);
      return c;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      i = this.extensions,
      r = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      o = s.name ? r.createUniqueName(s.name) : "",
      a = [],
      l = r._invokeOne(function (u) {
        return u.createNodeMesh && u.createNodeMesh(e);
      });
    return (
      l && a.push(l),
      s.camera !== void 0 &&
        a.push(
          r.getDependency("camera", s.camera).then(function (u) {
            return r._getNodeRef(r.cameraCache, s.camera, u);
          })
        ),
      r
        ._invokeAll(function (u) {
          return u.createNodeAttachment && u.createNodeAttachment(e);
        })
        .forEach(function (u) {
          a.push(u);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (u) {
        let c;
        if (
          (s.isBone === !0
            ? (c = new dx())
            : u.length > 1
            ? (c = new Sa())
            : u.length === 1
            ? (c = u[0])
            : (c = new qt()),
          c !== u[0])
        )
          for (let d = 0, p = u.length; d < p; d++) c.add(u[d]);
        if (
          (s.name && ((c.userData.name = s.name), (c.name = o)),
          ha(c, s),
          s.extensions && Mu(i, c, s),
          s.matrix !== void 0)
        ) {
          const d = new _t();
          d.fromArray(s.matrix), c.applyMatrix4(d);
        } else s.translation !== void 0 && c.position.fromArray(s.translation), s.rotation !== void 0 && c.quaternion.fromArray(s.rotation), s.scale !== void 0 && c.scale.fromArray(s.scale);
        return (
          r.associations.has(c) || r.associations.set(c, {}),
          (r.associations.get(c).nodes = e),
          c
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      r = this,
      s = new Sa();
    i.name && (s.name = r.createUniqueName(i.name)),
      ha(s, i),
      i.extensions && Mu(t, s, i);
    const o = i.nodes || [],
      a = [];
    for (let l = 0, u = o.length; l < u; l++)
      a.push(r.getDependency("node", o[l]));
    return Promise.all(a).then(function (l) {
      for (let c = 0, d = l.length; c < d; c++) s.add(l[c]);
      const u = (c) => {
        const d = new Map();
        for (const [p, m] of r.associations)
          (p instanceof mi || p instanceof Pn) && d.set(p, m);
        return (
          c.traverse((p) => {
            const m = r.associations.get(p);
            m != null && d.set(p, m);
          }),
          d
        );
      };
      return (r.associations = u(s)), s;
    });
  }
  _createAnimationTracks(e, t, i, r, s) {
    const o = [],
      a = e.name ? e.name : e.uuid,
      l = [];
    ll[s.path] === ll.weights
      ? e.traverse(function (p) {
          p.morphTargetInfluences && l.push(p.name ? p.name : p.uuid);
        })
      : l.push(a);
    let u;
    switch (ll[s.path]) {
      case ll.weights:
        u = Tc;
        break;
      case ll.rotation:
        u = Cc;
        break;
      case ll.position:
      case ll.scale:
        u = bc;
        break;
      default:
        switch (i.itemSize) {
          case 1:
            u = Tc;
            break;
          case 2:
          case 3:
          default:
            u = bc;
            break;
        }
        break;
    }
    const c = r.interpolation !== void 0 ? lY[r.interpolation] : Ch,
      d = this._getArrayFromAccessor(i);
    for (let p = 0, m = l.length; p < m; p++) {
      const v = new u(l[p] + "." + ll[s.path], t.array, d, c);
      r.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(v),
        o.push(v);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const i = hw(t.constructor),
        r = new Float32Array(t.length);
      for (let s = 0, o = t.length; s < o; s++) r[s] = t[s] * i;
      t = r;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (i) {
      const r = this instanceof Cc ? aY : BO;
      return new r(this.times, this.values, this.getValueSize() / 3, i);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function gY(n, e, t) {
  const i = e.attributes,
    r = new er();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION],
      l = a.min,
      u = a.max;
    if (l !== void 0 && u !== void 0) {
      if (
        (r.set(new z(l[0], l[1], l[2]), new z(u[0], u[1], u[2])), a.normalized)
      ) {
        const c = hw(uh[a.componentType]);
        r.min.multiplyScalar(c), r.max.multiplyScalar(c);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new z(),
      l = new z();
    for (let u = 0, c = s.length; u < c; u++) {
      const d = s[u];
      if (d.POSITION !== void 0) {
        const p = t.json.accessors[d.POSITION],
          m = p.min,
          v = p.max;
        if (m !== void 0 && v !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(m[0]), Math.abs(v[0]))),
            l.setY(Math.max(Math.abs(m[1]), Math.abs(v[1]))),
            l.setZ(Math.max(Math.abs(m[2]), Math.abs(v[2]))),
            p.normalized)
          ) {
            const _ = hw(uh[p.componentType]);
            l.multiplyScalar(_);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    r.expandByVector(a);
  }
  n.boundingBox = r;
  const o = new Ni();
  r.getCenter(o.center),
    (o.radius = r.min.distanceTo(r.max) / 2),
    (n.boundingSphere = o);
}
function VB(n, e, t) {
  const i = e.attributes,
    r = [];
  function s(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      n.setAttribute(a, l);
    });
  }
  for (const o in i) {
    const a = fw[o] || o.toLowerCase();
    a in n.attributes || r.push(s(i[o], a));
  }
  if (e.indices !== void 0 && !n.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    r.push(o);
  }
  return (
    ha(n, e),
    gY(n, e, t),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? cY(n, e.targets, t) : n;
    })
  );
}
const xS = new WeakMap();
class vY extends rr {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, i, r) {
    const s = new _s(this.manager);
    s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (o) => {
          const a = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(o, a).then(t).catch(r);
        },
        i,
        r
      );
  }
  decodeDracoFile(e, t, i, r) {
    const s = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: r || this.defaultAttributeTypes,
      useUniqueIDs: !!i,
    };
    this.decodeGeometry(e, s).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const u = t.attributeTypes[l];
      u.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = u.name);
    }
    const i = JSON.stringify(t);
    if (xS.has(e)) {
      const l = xS.get(e);
      if (l.key === i) return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let r;
    const s = this.workerNextTaskID++,
      o = e.byteLength,
      a = this._getWorker(s, o)
        .then(
          (l) => (
            (r = l),
            new Promise((u, c) => {
              (r._callbacks[s] = { resolve: u, reject: c }),
                r.postMessage(
                  { type: "decode", id: s, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((l) => this._createGeometry(l.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          r && s && this._releaseTask(r, s);
        }),
      xS.set(e, { key: i, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new Lt();
    e.index && t.setIndex(new rn(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const r = e.attributes[i],
        s = r.name,
        o = r.array,
        a = r.itemSize;
      t.setAttribute(s, new rn(o, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const i = new _s(this.manager);
    return (
      i.setPath(this.decoderPath),
      i.setResponseType(t),
      i.setWithCredentials(this.withCredentials),
      new Promise((r, s) => {
        i.load(e, r, void 0, s);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((i) => {
        const r = i[0];
        e || (this.decoderConfig.wasmBinary = i[1]);
        const s = yY.toString(),
          o = [
            "/* draco decoder */",
            r,
            "",
            "/* worker */",
            s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([o]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        (r._callbacks = {}),
          (r._taskCosts = {}),
          (r._taskLoad = 0),
          r.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (r.onmessage = function (s) {
            const o = s.data;
            switch (o.type) {
              case "decode":
                r._callbacks[o.id].resolve(o);
                break;
              case "error":
                r._callbacks[o.id].reject(o);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + o.type + '"'
                );
            }
          }),
          this.workerPool.push(r);
      } else
        this.workerPool.sort(function (r, s) {
          return r._taskLoad > s._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return (i._taskCosts[e] = t), (i._taskLoad += t), i;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function yY() {
  let n, e;
  onmessage = function (o) {
    const a = o.data;
    switch (a.type) {
      case "init":
        (n = a.decoderConfig),
          (e = new Promise(function (c) {
            (n.onModuleLoaded = function (d) {
              c({ draco: d });
            }),
              DracoDecoderModule(n);
          }));
        break;
      case "decode":
        const l = a.buffer,
          u = a.taskConfig;
        e.then((c) => {
          const d = c.draco,
            p = new d.Decoder(),
            m = new d.DecoderBuffer();
          m.Init(new Int8Array(l), l.byteLength);
          try {
            const v = t(d, p, m, u),
              _ = v.attributes.map((x) => x.array.buffer);
            v.index && _.push(v.index.array.buffer),
              self.postMessage({ type: "decode", id: a.id, geometry: v }, _);
          } catch (v) {
            console.error(v),
              self.postMessage({ type: "error", id: a.id, error: v.message });
          } finally {
            d.destroy(m), d.destroy(p);
          }
        });
        break;
    }
  };
  function t(o, a, l, u) {
    const c = u.attributeIDs,
      d = u.attributeTypes;
    let p, m;
    const v = a.GetEncodedGeometryType(l);
    if (v === o.TRIANGULAR_MESH)
      (p = new o.Mesh()), (m = a.DecodeBufferToMesh(l, p));
    else if (v === o.POINT_CLOUD)
      (p = new o.PointCloud()), (m = a.DecodeBufferToPointCloud(l, p));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!m.ok() || p.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
    const _ = { index: null, attributes: [] };
    for (const x in c) {
      const g = self[d[x]];
      let A, S;
      if (u.useUniqueIDs) (S = c[x]), (A = a.GetAttributeByUniqueId(p, S));
      else {
        if (((S = a.GetAttributeId(p, o[c[x]])), S === -1)) continue;
        A = a.GetAttribute(p, S);
      }
      _.attributes.push(r(o, a, p, x, g, A));
    }
    return v === o.TRIANGULAR_MESH && (_.index = i(o, a, p)), o.destroy(p), _;
  }
  function i(o, a, l) {
    const c = l.num_faces() * 3,
      d = c * 4,
      p = o._malloc(d);
    a.GetTrianglesUInt32Array(l, d, p);
    const m = new Uint32Array(o.HEAPF32.buffer, p, c).slice();
    return o._free(p), { array: m, itemSize: 1 };
  }
  function r(o, a, l, u, c, d) {
    const p = d.num_components(),
      v = l.num_points() * p,
      _ = v * c.BYTES_PER_ELEMENT,
      x = s(o, c),
      g = o._malloc(_);
    a.GetAttributeDataArrayForAllPoints(l, d, x, _, g);
    const A = new c(o.HEAPF32.buffer, g, v).slice();
    return o._free(g), { name: u, array: A, itemSize: p };
  }
  function s(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
let lv;
const AS = () => {
    if (lv) return lv;
    const n =
        "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
      e =
        "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
      t = new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1,
        0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0,
        11, 7, 0, 65, 0, 253, 15, 26, 11,
      ]),
      i = new Uint8Array([
        32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
        128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
        107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
        44, 45, 74, 156, 154, 70, 167,
      ]);
    if (typeof WebAssembly != "object") return { supported: !1 };
    let r = n;
    WebAssembly.validate(t) && (r = e);
    let s;
    const o = WebAssembly.instantiate(a(r), {}).then((d) => {
      (s = d.instance), s.exports.__wasm_call_ctors();
    });
    function a(d) {
      const p = new Uint8Array(d.length);
      for (let v = 0; v < d.length; ++v) {
        const _ = d.charCodeAt(v);
        p[v] =
          _ > 96 ? _ - 71 : _ > 64 ? _ - 65 : _ > 47 ? _ + 4 : _ > 46 ? 63 : 62;
      }
      let m = 0;
      for (let v = 0; v < d.length; ++v)
        p[m++] = p[v] < 60 ? i[p[v]] : (p[v] - 60) * 64 + p[++v];
      return p.buffer.slice(0, m);
    }
    function l(d, p, m, v, _, x) {
      const g = s.exports.sbrk,
        A = (m + 3) & -4,
        S = g(A * v),
        w = g(_.length),
        C = new Uint8Array(s.exports.memory.buffer);
      C.set(_, w);
      const b = d(S, m, v, w, _.length);
      if (
        (b === 0 && x && x(S, A, v),
        p.set(C.subarray(S, S + m * v)),
        g(S - g(0)),
        b !== 0)
      )
        throw new Error(`Malformed buffer data: ${b}`);
    }
    const u = {
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp",
      },
      c = {
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence",
      };
    return (
      (lv = {
        ready: o,
        supported: !0,
        decodeVertexBuffer(d, p, m, v, _) {
          l(s.exports.meshopt_decodeVertexBuffer, d, p, m, v, s.exports[u[_]]);
        },
        decodeIndexBuffer(d, p, m, v) {
          l(s.exports.meshopt_decodeIndexBuffer, d, p, m, v);
        },
        decodeIndexSequence(d, p, m, v) {
          l(s.exports.meshopt_decodeIndexSequence, d, p, m, v);
        },
        decodeGltfBuffer(d, p, m, v, _, x) {
          l(s.exports[c[_]], d, p, m, v, s.exports[u[x]]);
        },
      }),
      lv
    );
  },
  _Y = () => parseInt(Xh.replace(/\D+/g, "")),
  IO = _Y();
let uv = null,
  DO = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function LO(n = !0, e = !0, t) {
  return (i) => {
    t && t(i),
      n &&
        (uv || (uv = new vY()),
        uv.setDecoderPath(typeof n == "string" ? n : DO),
        i.setDRACOLoader(uv)),
      e && i.setMeshoptDecoder(typeof AS == "function" ? AS() : AS);
  };
}
const Bx = (n, e, t, i) => $m(QT, n, LO(e, t, i));
Bx.preload = (n, e, t, i) => $m.preload(QT, n, LO(e, t, i));
Bx.clear = (n) => $m.clear(QT, n);
Bx.setDecoderPath = (n) => {
  DO = n;
};
const xY = j.forwardRef(
    (
      {
        makeDefault: n,
        camera: e,
        regress: t,
        domElement: i,
        enableDamping: r = !0,
        keyEvents: s = !1,
        onChange: o,
        onStart: a,
        onEnd: l,
        ...u
      },
      c
    ) => {
      const d = Us((b) => b.invalidate),
        p = Us((b) => b.camera),
        m = Us((b) => b.gl),
        v = Us((b) => b.events),
        _ = Us((b) => b.setEvents),
        x = Us((b) => b.set),
        g = Us((b) => b.get),
        A = Us((b) => b.performance),
        S = e || p,
        w = i || v.connected || m.domElement,
        C = j.useMemo(() => new Fj(S), [S]);
      return (
        qm(() => {
          C.enabled && C.update();
        }, -1),
        j.useEffect(
          () => (
            s && C.connect(s === !0 ? w : s),
            C.connect(w),
            () => void C.dispose()
          ),
          [s, w, t, C, d]
        ),
        j.useEffect(() => {
          const b = (R) => {
              d(), t && A.regress(), o && o(R);
            },
            P = (R) => {
              a && a(R);
            },
            I = (R) => {
              l && l(R);
            };
          return (
            C.addEventListener("change", b),
            C.addEventListener("start", P),
            C.addEventListener("end", I),
            () => {
              C.removeEventListener("start", P),
                C.removeEventListener("end", I),
                C.removeEventListener("change", b);
            }
          );
        }, [o, a, l, C, d, _]),
        j.useEffect(() => {
          if (n) {
            const b = g().controls;
            return x({ controls: C }), () => x({ controls: b });
          }
        }, [n, C]),
        j.createElement(
          "primitive",
          za({ ref: c, object: C, enableDamping: r }, u)
        )
      );
    }
  ),
  SS = IO >= 154 ? "opaque_fragment" : "output_fragment";
class AY extends Jm {
  constructor(e) {
    super(e),
      (this.onBeforeCompile = (t, i) => {
        const { isWebGL2: r } = i.capabilities;
        t.fragmentShader = t.fragmentShader.replace(
          `#include <${SS}>`,
          `
        ${
          r
            ? `#include <${SS}>`
            : `#extension GL_OES_standard_derivatives : enable
#include <${SS}>`
        }
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <${IO >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
      `
        );
      });
  }
}
const SY = j.forwardRef((n, e) => {
  const [t] = j.useState(() => new AY(null));
  return j.createElement(
    "primitive",
    za({}, n, { object: t, ref: e, attach: "material" })
  );
});
let wu, zd;
const MY = j.createContext(null),
  WB = new _t(),
  XB = new z(),
  wY = j.forwardRef(({ children: n, range: e, limit: t = 1e3, ...i }, r) => {
    const s = j.useRef(null);
    j.useImperativeHandle(r, () => s.current, []);
    const [o, a] = j.useState([]),
      [[l, u, c]] = j.useState(() => [
        new Float32Array(t * 3),
        Float32Array.from({ length: t * 3 }, () => 1),
        Float32Array.from({ length: t }, () => 1),
      ]);
    j.useEffect(() => {
      s.current.geometry.attributes.position.needsUpdate = !0;
    }),
      qm(() => {
        for (
          s.current.updateMatrix(),
            s.current.updateMatrixWorld(),
            WB.copy(s.current.matrixWorld).invert(),
            s.current.geometry.drawRange.count = Math.min(
              t,
              e !== void 0 ? e : t,
              o.length
            ),
            wu = 0;
          wu < o.length;
          wu++
        )
          (zd = o[wu].current),
            zd.getWorldPosition(XB).applyMatrix4(WB),
            XB.toArray(l, wu * 3),
            (s.current.geometry.attributes.position.needsUpdate = !0),
            (zd.matrixWorldNeedsUpdate = !0),
            zd.color.toArray(u, wu * 3),
            (s.current.geometry.attributes.color.needsUpdate = !0),
            c.set([zd.size], wu),
            (s.current.geometry.attributes.size.needsUpdate = !0);
      });
    const d = j.useMemo(
      () => ({
        getParent: () => s,
        subscribe: (p) => (
          a((m) => [...m, p]),
          () => a((m) => m.filter((v) => v.current !== p.current))
        ),
      }),
      []
    );
    return j.createElement(
      "points",
      za(
        {
          userData: { instances: o },
          matrixAutoUpdate: !1,
          ref: s,
          raycast: () => null,
        },
        i
      ),
      j.createElement(
        "bufferGeometry",
        null,
        j.createElement("bufferAttribute", {
          attach: "attributes-position",
          count: l.length / 3,
          array: l,
          itemSize: 3,
          usage: rc,
        }),
        j.createElement("bufferAttribute", {
          attach: "attributes-color",
          count: u.length / 3,
          array: u,
          itemSize: 3,
          usage: rc,
        }),
        j.createElement("bufferAttribute", {
          attach: "attributes-size",
          count: c.length,
          array: c,
          itemSize: 1,
          usage: rc,
        })
      ),
      j.createElement(MY.Provider, { value: d }, n)
    );
  }),
  EY = j.forwardRef(
    (
      { children: n, positions: e, colors: t, sizes: i, stride: r = 3, ...s },
      o
    ) => {
      const a = j.useRef(null);
      return (
        j.useImperativeHandle(o, () => a.current, []),
        qm(() => {
          const l = a.current.geometry.attributes;
          (l.position.needsUpdate = !0),
            t && (l.color.needsUpdate = !0),
            i && (l.size.needsUpdate = !0);
        }),
        j.createElement(
          "points",
          za({ ref: a }, s),
          j.createElement(
            "bufferGeometry",
            null,
            j.createElement("bufferAttribute", {
              attach: "attributes-position",
              count: e.length / r,
              array: e,
              itemSize: r,
              usage: rc,
            }),
            t &&
              j.createElement("bufferAttribute", {
                attach: "attributes-color",
                count: t.length / r,
                array: t,
                itemSize: 3,
                usage: rc,
              }),
            i &&
              j.createElement("bufferAttribute", {
                attach: "attributes-size",
                count: i.length / r,
                array: i,
                itemSize: 1,
                usage: rc,
              })
          ),
          n
        )
      );
    }
  ),
  TY = j.forwardRef((n, e) =>
    n.positions instanceof Float32Array
      ? j.createElement(EY, za({}, n, { ref: e }))
      : j.createElement(wY, za({}, n, { ref: e }))
  );
function FO({ all: n, scene: e, camera: t }) {
  const i = Us(({ gl: o }) => o),
    r = Us(({ camera: o }) => o),
    s = Us(({ scene: o }) => o);
  return (
    j.useLayoutEffect(() => {
      const o = [];
      n &&
        (e || s).traverse((u) => {
          u.visible === !1 && (o.push(u), (u.visible = !0));
        }),
        i.compile(e || s, t || r);
      const a = new gT(128);
      new mT(0.01, 1e5, a).update(i, e || s),
        a.dispose(),
        o.forEach((u) => (u.visible = !1));
    }, []),
    null
  );
}
const CY = () => {
    const { progress: n } = Tj();
    return Dt(Aj, {
      as: "div",
      center: !0,
      style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        flexDirection: "column",
      },
      children: [
        _e("span", { className: "canvas-loader" }),
        Dt("p", {
          style: {
            fontSize: 14,
            color: "#F1F1F1",
            fontWeight: 800,
            marginTop: 40,
          },
          children: [n.toFixed(2), "%"],
        }),
      ],
    });
  },
  bY = () => {
    const n = Bx("./planet/scene.gltf");
    return _e("primitive", {
      object: n.scene,
      scale: 2.5,
      "position-y": 0,
      "rotation-y": 0,
    });
  },
  RY = () =>
    _e(bO, {
      shadows: !0,
      frameloop: "demand",
      dpr: [1, 2],
      gl: { preserveDrawingBuffer: !0 },
      camera: { fov: 45, near: 0.1, far: 200, position: [-4, 3, 6] },
      children: Dt(j.Suspense, {
        fallback: _e(CY, {}),
        children: [
          _e(xY, {
            autoRotate: !0,
            enableZoom: !1,
            maxPolarAngle: Math.PI / 2,
            minPolarAngle: Math.PI / 2,
          }),
          _e(bY, {}),
          _e(FO, { all: !0 }),
        ],
      }),
    });
function ch(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function JB(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, i);
  }
  return t;
}
function jB(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? JB(Object(t), !0).forEach(function (i) {
          ch(n, i, t[i]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : JB(Object(t)).forEach(function (i) {
          Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
        });
  }
  return n;
}
function NO(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
new Ae();
new Ae();
var Ls = function n(e, t, i) {
    var r = this;
    NO(this, n),
      ch(this, "dot2", function (s, o) {
        return r.x * s + r.y * o;
      }),
      ch(this, "dot3", function (s, o, a) {
        return r.x * s + r.y * o + r.z * a;
      }),
      (this.x = e),
      (this.y = t),
      (this.z = i);
  },
  PY = [
    new Ls(1, 1, 0),
    new Ls(-1, 1, 0),
    new Ls(1, -1, 0),
    new Ls(-1, -1, 0),
    new Ls(1, 0, 1),
    new Ls(-1, 0, 1),
    new Ls(1, 0, -1),
    new Ls(-1, 0, -1),
    new Ls(0, 1, 1),
    new Ls(0, -1, 1),
    new Ls(0, 1, -1),
    new Ls(0, -1, -1),
  ],
  YB = [
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,
    36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
    234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
    134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
    230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
    1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,
    116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,
    124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,
    47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
    154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
    108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
    242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
    239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
    50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
    141, 128, 195, 78, 66, 215, 61, 156, 180,
  ],
  KB = new Array(512),
  QB = new Array(512),
  BY = function (e) {
    e > 0 && e < 1 && (e *= 65536),
      (e = Math.floor(e)),
      e < 256 && (e |= e << 8);
    for (var t = 0; t < 256; t++) {
      var i;
      t & 1 ? (i = YB[t] ^ (e & 255)) : (i = YB[t] ^ ((e >> 8) & 255)),
        (KB[t] = KB[t + 256] = i),
        (QB[t] = QB[t + 256] = PY[i % 12]);
    }
  };
BY(0);
function IY(n) {
  if (typeof n == "number") n = Math.abs(n);
  else if (typeof n == "string") {
    var e = n;
    n = 0;
    for (var t = 0; t < e.length; t++)
      n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647;
  }
  return n === 0 && (n = 311), n;
}
function ZB(n) {
  var e = IY(n);
  return function () {
    var t = (e * 48271) % 2147483647;
    return (e = t), t / 2147483647;
  };
}
var DY = function n(e) {
    var t = this;
    NO(this, n),
      ch(this, "seed", 0),
      ch(this, "init", function (i) {
        (t.seed = i), (t.value = ZB(i));
      }),
      ch(this, "value", ZB(this.seed)),
      this.init(e);
  },
  LY = new DY(Math.random()),
  FY = { radius: 1, center: [0, 0, 0] };
function NY(n, e) {
  for (
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : LY,
      i = jB(jB({}, FY), e),
      r = i.radius,
      s = i.center,
      o = 0;
    o < n.length;
    o += 3
  ) {
    var a = Math.pow(t.value(), 0.3333333333333333),
      l = t.value() * 2 - 1,
      u = t.value() * 2 - 1,
      c = t.value() * 2 - 1,
      d = Math.sqrt(l * l + u * u + c * c);
    (l = (a * l) / d),
      (u = (a * u) / d),
      (c = (a * c) / d),
      (n[o] = l * r + s[0]),
      (n[o + 1] = u * r + s[1]),
      (n[o + 2] = c * r + s[2]);
  }
  return n;
}
const OY = (n) => {
    const e = j.useRef(),
      [t] = j.useState(() => NY(new Float32Array(5e3), { radius: 1.2 }));
    return (
      qm((i, r) => {
        (e.current.rotation.x -= r / 10), (e.current.rotation.y -= r / 15);
      }),
      _e("group", {
        rotation: [0, 0, Math.PI / 4],
        children: _e(TY, {
          ref: e,
          positions: t,
          stride: 3,
          frustumCulled: !0,
          ...n,
          children: _e(SY, {
            transparent: !0,
            color: "#f272c8",
            size: 0.002,
            sizeAttenuation: !0,
            depthWrite: !1,
          }),
        }),
      })
    );
  },
  UY = () =>
    _e("div", {
      className: "w-full h-auto absolute inset-0 z-[-1]",
      children: Dt(bO, {
        camera: { position: [0, 0, 1] },
        children: [
          _e(j.Suspense, { fallback: null, children: _e(OY, {}) }),
          _e(FO, { all: !0 }),
        ],
      }),
    }),
  pi = {
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-16 py-10",
    heroHeadText:
      "font-black text-white lg:text-[80px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2",
    heroSubText:
      "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]",
    sectionHeadText:
      "text-white font-black md:text-[60px] sm:text-[50px] xs:text-[40px] text-[30px]",
    sectionSubText:
      "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider",
  },
  kY = "/assets/pfp.png",
  zY = "/assets/pfp.png",
  HY = () =>
    Dt("section", {
      id: "home",
      className:
        "relative w-full bg-hero-pattern bg-cover bg-no-repeat bg-center pt-28 pb-8 overflow-hidden",
      children: [
        Dt("div", {
          className: `max-w-7xl mx-auto ${pi.paddingX} w-full flex flex-col md:flex-row items-center justify-between gap-10`,
          children: [
            Dt("div", {
              className: "flex-1 text-center md:text-left order-2 md:order-1",
              children: [
                _e("h2", {
                  className:
                    "text-white text-[16px] tracking-wider uppercase mb-2 glow-text",
                  children: "Hello there...",
                }),
                Dt("h1", {
                  className: `${pi.heroHeadText} text-white leading-tight`,
                  children: [
                    "I'm ",
                    _e("span", {
                      className: "text-[#915EFF]",
                      children: "Amra",
                    }),
                  ],
                }),
                _e("p", {
                  className: `${pi.heroSubText} mt-3 text-white-100`,
                  children: "Video Editor & Graphic Designer",
                }),
                _e("a", {
                  href: "https://calendly.com/hireamra/30min",
                  children: _e("button", {
                    className:
                      "mt-6 px-7 py-3 bg-[#915EFF] text-white font-semibold rounded-full text-sm hover:bg-white hover:text-[#915EFF] transition-all duration-300 shadow-xl",
                    children: "Book a Call",
                  }),
                }),
              ],
            }),
            _e("div", {
              className: "flex justify-center items-center order-1 md:order-2",
              children: Dt("div", {
                className:
                  "relative w-[260px] h-[260px] md:w-[300px] md:h-[300px] rounded-full shadow-[0_0_60px_#915EFF80] border-[5px] border-[#915EFF] overflow-hidden",
                children: [
                  _e("img", {
                    src: zY,
                    alt: "Amra Mobile",
                    className:
                      "block md:hidden w-full h-full object-cover rounded-full",
                  }),
                  _e("img", {
                    src: kY,
                    alt: "Amra Desktop",
                    className:
                      "hidden md:block w-full h-full object-cover rounded-full",
                  }),
                ],
              }),
            }),
          ],
        }),
      ],
    });
var OO = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0,
  },
  qB = zr.createContext && zr.createContext(OO),
  GY = ["attr", "size", "title"];
function VY(n, e) {
  if (n == null) return {};
  var t = WY(n, e),
    i,
    r;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (r = 0; r < s.length; r++)
      (i = s[r]),
        !(e.indexOf(i) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(n, i) &&
          (t[i] = n[i]);
  }
  return t;
}
function WY(n, e) {
  if (n == null) return {};
  var t = {};
  for (var i in n)
    if (Object.prototype.hasOwnProperty.call(n, i)) {
      if (e.indexOf(i) >= 0) continue;
      t[i] = n[i];
    }
  return t;
}
function f_() {
  return (
    (f_ = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    f_.apply(this, arguments)
  );
}
function $B(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, i);
  }
  return t;
}
function h_(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? $B(Object(t), !0).forEach(function (i) {
          XY(n, i, t[i]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : $B(Object(t)).forEach(function (i) {
          Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
        });
  }
  return n;
}
function XY(n, e, t) {
  return (
    (e = JY(e)),
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function JY(n) {
  var e = jY(n, "string");
  return typeof e == "symbol" ? e : e + "";
}
function jY(n, e) {
  if (typeof n != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || "default");
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function UO(n) {
  return (
    n &&
    n.map((e, t) =>
      zr.createElement(e.tag, h_({ key: t }, e.attr), UO(e.child))
    )
  );
}
function tg(n) {
  return (e) =>
    zr.createElement(YY, f_({ attr: h_({}, n.attr) }, e), UO(n.child));
}
function YY(n) {
  var e = (t) => {
    var { attr: i, size: r, title: s } = n,
      o = VY(n, GY),
      a = r || t.size || "1em",
      l;
    return (
      t.className && (l = t.className),
      n.className && (l = (l ? l + " " : "") + n.className),
      zr.createElement(
        "svg",
        f_(
          { stroke: "currentColor", fill: "currentColor", strokeWidth: "0" },
          t.attr,
          i,
          o,
          {
            className: l,
            style: h_(h_({ color: n.color || t.color }, t.style), n.style),
            height: a,
            width: a,
            xmlns: "http://www.w3.org/2000/svg",
          }
        ),
        s && zr.createElement("title", null, s),
        n.children
      )
    );
  };
  return qB !== void 0
    ? zr.createElement(qB.Consumer, null, (t) => e(t))
    : e(OO);
}
function KY(n) {
  return tg({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z",
        },
        child: [],
      },
    ],
  })(n);
}
function QY(n) {
  return tg({
    tag: "svg",
    attr: { viewBox: "0 0 352 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z",
        },
        child: [],
      },
    ],
  })(n);
}
const ZY = "/assets/SNK.jpg",
  qY = "/assets/2swag.jpg",
  $Y = "/assets/Justin.jpg",
  eK = "/assets/2swag.jpg",
  eI = [
    { id: "home", title: "Home" },
    { id: "about", title: "About" },
    { id: "projects", title: "Projects" },
    { id: "testimonials", title: "Testimonials" },
    { id: "contact", title: "Contact" },
  ],
  tK = [
    {
      title: "Video Editor",
      company_name: "",
      icon: eK,
      iconBg: "#383E56",
      date: "May 2025 - Present",
      points: [
        "Creating and editing short-form, long-form, and motion graphics content for various platforms.",
        "Collaborating closely with clients to understand their brand voice and visual goals.",
        "Utilizing Premiere Pro, After Effects, and AI tools to enhance storytelling and speed up workflow.",
        "Delivering platform-optimized content tailored for Instagram, YouTube, and Reels.",
      ],
    },
  ],
  nK = [
    {
      testimonial:
        "Amras edits made my videos look better. Super easy to work with!",
      name: "SwitchandClickOfficial",
      designation: "Creator",
      company: "@SwitchandClickOfficial",
      image: ZY,
    },
    {
      testimonial:
        "Loved how fast and clean the edits were. Exactly what I wanted.",
      name: "2swag",
      designation: "Creator",
      company: "@2swag",
      image: qY,
    },
    {
      testimonial: "Really happy with the work. Highly recommended.",
      name: "Justin Lalonde",
      designation: "Creator",
      company: "@Justin Lalonde",
      image: $Y,
    },
  ],
  iK = () => {
    const [n, e] = j.useState(""),
      [t, i] = j.useState(!1);
    return _e("nav", {
      className: `${pi.paddingX} w-full flex items-center py-5 fixed top-0 z-20 bg-primary`,
      children: Dt("div", {
        className: "w-full flex justify-between items-center max-w-7xl mx-auto",
        children: [
          _e(mV, {
            to: "/",
            className: "flex items-center gap-2",
            onClick: () => {
              e(""), window.scrollTo(0, 0);
            },
            children: _e("p", {
              className: "text-white text-[18px] font-bold cursor-pointer flex",
              children: _e("span", {
                className: "sm:block hidden",
                children: "Portfolio:",
              }),
            }),
          }),
          _e("ul", {
            className: "list-none hidden sm:flex flex-row gap-10",
            children: eI.map((r) =>
              _e(
                "li",
                {
                  className: `${
                    n === r.title ? "text-white" : "text-secondary"
                  } hover:text-white text-[18px] font-medium cursor-pointer`,
                  onClick: () => e(r.title),
                  children: _e("a", { href: `#${r.id}`, children: r.title }),
                },
                r.id
              )
            ),
          }),
          Dt("div", {
            className: "sm:hidden flex flex-1 justify-end items-center",
            children: [
              _e("div", {
                className: "cursor-pointer text-white text-[24px]",
                onClick: () => i(!t),
                children: t ? _e(QY, {}) : _e(KY, {}),
              }),
              _e("div", {
                className: `${
                  t ? "flex" : "hidden"
                } absolute top-20 right-0 z-10 flex-col bg-black-100 px-6 py-4 rounded-xl`,
                children: _e("ul", {
                  className:
                    "list-none flex justify-end items-start flex-col gap-4",
                  children: eI.map((r) =>
                    _e(
                      "li",
                      {
                        className: `${
                          n === r.title ? "text-white" : "text-secondary"
                        } font-medium cursor-pointer text-[16px]`,
                        onClick: () => {
                          i(!1), e(r.title);
                        },
                        children: _e("a", {
                          href: `#${r.id}`,
                          children: r.title,
                        }),
                      },
                      r.id
                    )
                  ),
                }),
              }),
            ],
          }),
        ],
      }),
    });
  };
function da(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function kO(n, e) {
  (n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    (n.__proto__ = e);
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var gs = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  Ih = { duration: 0.5, overwrite: !1, delay: 0 },
  ZT,
  Oi,
  Rn,
  Js = 1e8,
  xn = 1 / Js,
  dw = Math.PI * 2,
  rK = dw / 4,
  sK = 0,
  zO = Math.sqrt,
  oK = Math.cos,
  aK = Math.sin,
  Pi = function (e) {
    return typeof e == "string";
  },
  Vn = function (e) {
    return typeof e == "function";
  },
  Ha = function (e) {
    return typeof e == "number";
  },
  qT = function (e) {
    return typeof e > "u";
  },
  Qo = function (e) {
    return typeof e == "object";
  },
  Wr = function (e) {
    return e !== !1;
  },
  $T = function () {
    return typeof window < "u";
  },
  cv = function (e) {
    return Vn(e) || Pi(e);
  },
  HO =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  tr = Array.isArray,
  pw = /(?:-?\.?\d|\.)+/gi,
  GO = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  Kf = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  MS = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  VO = /[+-]=-?[.\d]+/,
  WO = /[^,'"\[\]\s]+/gi,
  lK = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  Ln,
  Fo,
  mw,
  eC,
  xs = {},
  d_ = {},
  XO,
  JO = function (e) {
    return (d_ = Dh(e, xs)) && Yr;
  },
  tC = function (e, t) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      t,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  ym = function (e, t) {
    return !t && console.warn(e);
  },
  jO = function (e, t) {
    return (e && (xs[e] = t) && d_ && (d_[e] = t)) || xs;
  },
  _m = function () {
    return 0;
  },
  uK = { suppressEvents: !0, isStart: !0, kill: !1 },
  Hv = { suppressEvents: !0, kill: !1 },
  cK = { suppressEvents: !0 },
  nC = {},
  Dl = [],
  gw = {},
  YO,
  os = {},
  wS = {},
  tI = 30,
  Gv = [],
  iC = "",
  rC = function (e) {
    var t = e[0],
      i,
      r;
    if ((Qo(t) || Vn(t) || (e = [e]), !(i = (t._gsap || {}).harness))) {
      for (r = Gv.length; r-- && !Gv[r].targetTest(t); );
      i = Gv[r];
    }
    for (r = e.length; r--; )
      (e[r] && (e[r]._gsap || (e[r]._gsap = new yU(e[r], i)))) ||
        e.splice(r, 1);
    return e;
  },
  lc = function (e) {
    return e._gsap || rC(js(e))[0]._gsap;
  },
  KO = function (e, t, i) {
    return (i = e[t]) && Vn(i)
      ? e[t]()
      : (qT(i) && e.getAttribute && e.getAttribute(t)) || i;
  },
  Xr = function (e, t) {
    return (e = e.split(",")).forEach(t) || e;
  },
  Kn = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  oi = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  fh = function (e, t) {
    var i = t.charAt(0),
      r = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r
    );
  },
  fK = function (e, t) {
    for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i; );
    return r < i;
  },
  p_ = function () {
    var e = Dl.length,
      t = Dl.slice(0),
      i,
      r;
    for (gw = {}, Dl.length = 0, i = 0; i < e; i++)
      (r = t[i]),
        r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0);
  },
  sC = function (e) {
    return !!(e._initted || e._startAt || e.add);
  },
  QO = function (e, t, i, r) {
    Dl.length && !Oi && p_(),
      e.render(t, i, r || !!(Oi && t < 0 && sC(e))),
      Dl.length && !Oi && p_();
  },
  ZO = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(WO).length < 2
      ? t
      : Pi(e)
      ? e.trim()
      : e;
  },
  qO = function (e) {
    return e;
  },
  As = function (e, t) {
    for (var i in t) i in e || (e[i] = t[i]);
    return e;
  },
  hK = function (e) {
    return function (t, i) {
      for (var r in i)
        r in t || (r === "duration" && e) || r === "ease" || (t[r] = i[r]);
    };
  },
  Dh = function (e, t) {
    for (var i in t) e[i] = t[i];
    return e;
  },
  nI = function n(e, t) {
    for (var i in t)
      i !== "__proto__" &&
        i !== "constructor" &&
        i !== "prototype" &&
        (e[i] = Qo(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
    return e;
  },
  m_ = function (e, t) {
    var i = {},
      r;
    for (r in e) r in t || (i[r] = e[r]);
    return i;
  },
  wp = function (e) {
    var t = e.parent || Ln,
      i = e.keyframes ? hK(tr(e.keyframes)) : As;
    if (Wr(e.inherit))
      for (; t; ) i(e, t.vars.defaults), (t = t.parent || t._dp);
    return e;
  },
  dK = function (e, t) {
    for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i]; );
    return i < 0;
  },
  $O = function (e, t, i, r, s) {
    i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
    var o = e[r],
      a;
    if (s) for (a = t[s]; o && o[s] > a; ) o = o._prev;
    return (
      o ? ((t._next = o._next), (o._next = t)) : ((t._next = e[i]), (e[i] = t)),
      t._next ? (t._next._prev = t) : (e[r] = t),
      (t._prev = o),
      (t.parent = t._dp = e),
      t
    );
  },
  Ix = function (e, t, i, r) {
    i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
    var s = t._prev,
      o = t._next;
    s ? (s._next = o) : e[i] === t && (e[i] = o),
      o ? (o._prev = s) : e[r] === t && (e[r] = s),
      (t._next = t._prev = t.parent = null);
  },
  Gl = function (e, t) {
    e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0);
  },
  uc = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var i = e; i; ) (i._dirty = 1), (i = i.parent);
    return e;
  },
  pK = function (e) {
    for (var t = e.parent; t && t.parent; )
      (t._dirty = 1), t.totalDuration(), (t = t.parent);
    return e;
  },
  vw = function (e, t, i, r) {
    return (
      e._startAt &&
      (Oi
        ? e._startAt.revert(Hv)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, r))
    );
  },
  mK = function n(e) {
    return !e || (e._ts && n(e.parent));
  },
  iI = function (e) {
    return e._repeat ? Lh(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  Lh = function (e, t) {
    var i = Math.floor((e = oi(e / t)));
    return e && i === e ? i - 1 : i;
  },
  g_ = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  Dx = function (e) {
    return (e._end = oi(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || xn) || 0)
    ));
  },
  Lx = function (e, t) {
    var i = e._dp;
    return (
      i &&
        i.smoothChildTiming &&
        e._ts &&
        ((e._start = oi(
          i._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        Dx(e),
        i._dirty || uc(i, e)),
      e
    );
  },
  eU = function (e, t) {
    var i;
    if (
      ((t._time ||
        (!t._dur && t._initted) ||
        (t._start < e._time && (t._dur || !t.add))) &&
        ((i = g_(e.rawTime(), t)),
        (!t._dur || ng(0, t.totalDuration(), i) - t._tTime > xn) &&
          t.render(i, !0)),
      uc(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (i = e; i._dp; )
          i.rawTime() >= 0 && i.totalTime(i._tTime), (i = i._dp);
      e._zTime = -xn;
    }
  },
  Uo = function (e, t, i, r) {
    return (
      t.parent && Gl(t),
      (t._start = oi(
        (Ha(i) ? i : i || e !== Ln ? Ns(e, i, t) : e._time) + t._delay
      )),
      (t._end = oi(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      $O(e, t, "_first", "_last", e._sort ? "_start" : 0),
      yw(t) || (e._recent = t),
      r || eU(e, t),
      e._ts < 0 && Lx(e, e._tTime),
      e
    );
  },
  tU = function (e, t) {
    return (
      (xs.ScrollTrigger || tC("scrollTrigger", t)) &&
      xs.ScrollTrigger.create(t, e)
    );
  },
  nU = function (e, t, i, r, s) {
    if ((aC(e, t, s), !e._initted)) return 1;
    if (
      !i &&
      e._pt &&
      !Oi &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      YO !== ls.frame
    )
      return Dl.push(e), (e._lazy = [s, r]), 1;
  },
  gK = function n(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t));
  },
  yw = function (e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  },
  vK = function (e, t, i, r) {
    var s = e.ratio,
      o =
        t < 0 ||
        (!t &&
          ((!e._start && gK(e) && !(!e._initted && yw(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !yw(e))))
          ? 0
          : 1,
      a = e._rDelay,
      l = 0,
      u,
      c,
      d;
    if (
      (a &&
        e._repeat &&
        ((l = ng(0, e._tDur, t)),
        (c = Lh(l, a)),
        e._yoyo && c & 1 && (o = 1 - o),
        c !== Lh(e._tTime, a) &&
          ((s = 1 - o), e.vars.repeatRefresh && e._initted && e.invalidate())),
      o !== s || Oi || r || e._zTime === xn || (!t && e._zTime))
    ) {
      if (!e._initted && nU(e, t, r, i, l)) return;
      for (
        d = e._zTime,
          e._zTime = t || (i ? xn : 0),
          i || (i = t && !d),
          e.ratio = o,
          e._from && (o = 1 - o),
          e._time = 0,
          e._tTime = l,
          u = e._pt;
        u;

      )
        u.r(o, u.d), (u = u._next);
      t < 0 && vw(e, t, i, !0),
        e._onUpdate && !i && ds(e, "onUpdate"),
        l && e._repeat && !i && e.parent && ds(e, "onRepeat"),
        (t >= e._tDur || t < 0) &&
          e.ratio === o &&
          (o && Gl(e, 1),
          !i &&
            !Oi &&
            (ds(e, o ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  },
  yK = function (e, t, i) {
    var r;
    if (i > t)
      for (r = e._first; r && r._start <= i; ) {
        if (r.data === "isPause" && r._start > t) return r;
        r = r._next;
      }
    else
      for (r = e._last; r && r._start >= i; ) {
        if (r.data === "isPause" && r._start < t) return r;
        r = r._prev;
      }
  },
  Fh = function (e, t, i, r) {
    var s = e._repeat,
      o = oi(t) || 0,
      a = e._tTime / e._tDur;
    return (
      a && !r && (e._time *= o / e._dur),
      (e._dur = o),
      (e._tDur = s ? (s < 0 ? 1e10 : oi(o * (s + 1) + e._rDelay * s)) : o),
      a > 0 && !r && Lx(e, (e._tTime = e._tDur * a)),
      e.parent && Dx(e),
      i || uc(e.parent, e),
      e
    );
  },
  rI = function (e) {
    return e instanceof yr ? uc(e) : Fh(e, e._dur);
  },
  _K = { _start: 0, endTime: _m, totalDuration: _m },
  Ns = function n(e, t, i) {
    var r = e.labels,
      s = e._recent || _K,
      o = e.duration() >= Js ? s.endTime(!1) : e._dur,
      a,
      l,
      u;
    return Pi(t) && (isNaN(t) || t in r)
      ? ((l = t.charAt(0)),
        (u = t.substr(-1) === "%"),
        (a = t.indexOf("=")),
        l === "<" || l === ">"
          ? (a >= 0 && (t = t.replace(/=/, "")),
            (l === "<" ? s._start : s.endTime(s._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (u ? (a < 0 ? s : i).totalDuration() / 100 : 1))
          : a < 0
          ? (t in r || (r[t] = o), r[t])
          : ((l = parseFloat(t.charAt(a - 1) + t.substr(a + 1))),
            u && i && (l = (l / 100) * (tr(i) ? i[0] : i).totalDuration()),
            a > 1 ? n(e, t.substr(0, a - 1), i) + l : o + l))
      : t == null
      ? o
      : +t;
  },
  Ep = function (e, t, i) {
    var r = Ha(t[1]),
      s = (r ? 2 : 1) + (e < 2 ? 0 : 1),
      o = t[s],
      a,
      l;
    if ((r && (o.duration = t[1]), (o.parent = i), e)) {
      for (a = o, l = i; l && !("immediateRender" in a); )
        (a = l.vars.defaults || {}), (l = Wr(l.vars.inherit) && l.parent);
      (o.immediateRender = Wr(a.immediateRender)),
        e < 2 ? (o.runBackwards = 1) : (o.startAt = t[s - 1]);
    }
    return new si(t[0], o, t[s + 1]);
  },
  $l = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  ng = function (e, t, i) {
    return i < e ? e : i > t ? t : i;
  },
  Zi = function (e, t) {
    return !Pi(e) || !(t = lK.exec(e)) ? "" : t[1];
  },
  xK = function (e, t, i) {
    return $l(i, function (r) {
      return ng(e, t, r);
    });
  },
  _w = [].slice,
  iU = function (e, t) {
    return (
      e &&
      Qo(e) &&
      "length" in e &&
      ((!t && !e.length) || (e.length - 1 in e && Qo(e[0]))) &&
      !e.nodeType &&
      e !== Fo
    );
  },
  AK = function (e, t, i) {
    return (
      i === void 0 && (i = []),
      e.forEach(function (r) {
        var s;
        return (Pi(r) && !t) || iU(r, 1)
          ? (s = i).push.apply(s, js(r))
          : i.push(r);
      }) || i
    );
  },
  js = function (e, t, i) {
    return Rn && !t && Rn.selector
      ? Rn.selector(e)
      : Pi(e) && !i && (mw || !Nh())
      ? _w.call((t || eC).querySelectorAll(e), 0)
      : tr(e)
      ? AK(e, i)
      : iU(e)
      ? _w.call(e, 0)
      : e
      ? [e]
      : [];
  },
  xw = function (e) {
    return (
      (e = js(e)[0] || ym("Invalid scope") || {}),
      function (t) {
        var i = e.current || e.nativeElement || e;
        return js(
          t,
          i.querySelectorAll
            ? i
            : i === e
            ? ym("Invalid scope") || eC.createElement("div")
            : e
        );
      }
    );
  },
  rU = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  sU = function (e) {
    if (Vn(e)) return e;
    var t = Qo(e) ? e : { each: e },
      i = cc(t.ease),
      r = t.from || 0,
      s = parseFloat(t.base) || 0,
      o = {},
      a = r > 0 && r < 1,
      l = isNaN(r) || a,
      u = t.axis,
      c = r,
      d = r;
    return (
      Pi(r)
        ? (c = d = { center: 0.5, edges: 0.5, end: 1 }[r] || 0)
        : !a && l && ((c = r[0]), (d = r[1])),
      function (p, m, v) {
        var _ = (v || t).length,
          x = o[_],
          g,
          A,
          S,
          w,
          C,
          b,
          P,
          I,
          R;
        if (!x) {
          if (((R = t.grid === "auto" ? 0 : (t.grid || [1, Js])[1]), !R)) {
            for (
              P = -Js;
              P < (P = v[R++].getBoundingClientRect().left) && R < _;

            );
            R < _ && R--;
          }
          for (
            x = o[_] = [],
              g = l ? Math.min(R, _) * c - 0.5 : r % R,
              A = R === Js ? 0 : l ? (_ * d) / R - 0.5 : (r / R) | 0,
              P = 0,
              I = Js,
              b = 0;
            b < _;
            b++
          )
            (S = (b % R) - g),
              (w = A - ((b / R) | 0)),
              (x[b] = C = u ? Math.abs(u === "y" ? w : S) : zO(S * S + w * w)),
              C > P && (P = C),
              C < I && (I = C);
          r === "random" && rU(x),
            (x.max = P - I),
            (x.min = I),
            (x.v = _ =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (R > _
                    ? _ - 1
                    : u
                    ? u === "y"
                      ? _ / R
                      : R
                    : Math.max(R, _ / R)) ||
                0) * (r === "edges" ? -1 : 1)),
            (x.b = _ < 0 ? s - _ : s),
            (x.u = Zi(t.amount || t.each) || 0),
            (i = i && _ < 0 ? mU(i) : i);
        }
        return (
          (_ = (x[p] - x.min) / x.max || 0),
          oi(x.b + (i ? i(_) : _) * x.v) + x.u
        );
      }
    );
  },
  Aw = function (e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function (i) {
      var r = oi(Math.round(parseFloat(i) / e) * e * t);
      return (r - (r % 1)) / t + (Ha(i) ? 0 : Zi(i));
    };
  },
  oU = function (e, t) {
    var i = tr(e),
      r,
      s;
    return (
      !i &&
        Qo(e) &&
        ((r = i = e.radius || Js),
        e.values
          ? ((e = js(e.values)), (s = !Ha(e[0])) && (r *= r))
          : (e = Aw(e.increment))),
      $l(
        t,
        i
          ? Vn(e)
            ? function (o) {
                return (s = e(o)), Math.abs(s - o) <= r ? s : o;
              }
            : function (o) {
                for (
                  var a = parseFloat(s ? o.x : o),
                    l = parseFloat(s ? o.y : 0),
                    u = Js,
                    c = 0,
                    d = e.length,
                    p,
                    m;
                  d--;

                )
                  s
                    ? ((p = e[d].x - a), (m = e[d].y - l), (p = p * p + m * m))
                    : (p = Math.abs(e[d] - a)),
                    p < u && ((u = p), (c = d));
                return (
                  (c = !r || u <= r ? e[c] : o),
                  s || c === o || Ha(o) ? c : c + Zi(o)
                );
              }
          : Aw(e)
      )
    );
  },
  aU = function (e, t, i, r) {
    return $l(tr(e) ? !t : i === !0 ? !!(i = 0) : !r, function () {
      return tr(e)
        ? e[~~(Math.random() * e.length)]
        : (i = i || 1e-5) &&
            (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) &&
            Math.floor(
              Math.round((e - i / 2 + Math.random() * (t - e + i * 0.99)) / i) *
                i *
                r
            ) / r;
    });
  },
  SK = function () {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return function (r) {
      return t.reduce(function (s, o) {
        return o(s);
      }, r);
    };
  },
  MK = function (e, t) {
    return function (i) {
      return e(parseFloat(i)) + (t || Zi(i));
    };
  },
  wK = function (e, t, i) {
    return uU(e, t, 0, 1, i);
  },
  lU = function (e, t, i) {
    return $l(i, function (r) {
      return e[~~t(r)];
    });
  },
  EK = function n(e, t, i) {
    var r = t - e;
    return tr(e)
      ? lU(e, n(0, e.length), t)
      : $l(i, function (s) {
          return ((r + ((s - e) % r)) % r) + e;
        });
  },
  TK = function n(e, t, i) {
    var r = t - e,
      s = r * 2;
    return tr(e)
      ? lU(e, n(0, e.length - 1), t)
      : $l(i, function (o) {
          return (o = (s + ((o - e) % s)) % s || 0), e + (o > r ? s - o : o);
        });
  },
  xm = function (e) {
    for (var t = 0, i = "", r, s, o, a; ~(r = e.indexOf("random(", t)); )
      (o = e.indexOf(")", r)),
        (a = e.charAt(r + 7) === "["),
        (s = e.substr(r + 7, o - r - 7).match(a ? WO : pw)),
        (i +=
          e.substr(t, r - t) + aU(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5)),
        (t = o + 1);
    return i + e.substr(t, e.length - t);
  },
  uU = function (e, t, i, r, s) {
    var o = t - e,
      a = r - i;
    return $l(s, function (l) {
      return i + (((l - e) / o) * a || 0);
    });
  },
  CK = function n(e, t, i, r) {
    var s = isNaN(e + t)
      ? 0
      : function (m) {
          return (1 - m) * e + m * t;
        };
    if (!s) {
      var o = Pi(e),
        a = {},
        l,
        u,
        c,
        d,
        p;
      if ((i === !0 && (r = 1) && (i = null), o))
        (e = { p: e }), (t = { p: t });
      else if (tr(e) && !tr(t)) {
        for (c = [], d = e.length, p = d - 2, u = 1; u < d; u++)
          c.push(n(e[u - 1], e[u]));
        d--,
          (s = function (v) {
            v *= d;
            var _ = Math.min(p, ~~v);
            return c[_](v - _);
          }),
          (i = t);
      } else r || (e = Dh(tr(e) ? [] : {}, e));
      if (!c) {
        for (l in t) oC.call(a, e, l, "get", t[l]);
        s = function (v) {
          return cC(v, a) || (o ? e.p : e);
        };
      }
    }
    return $l(i, s);
  },
  sI = function (e, t, i) {
    var r = e.labels,
      s = Js,
      o,
      a,
      l;
    for (o in r)
      (a = r[o] - t),
        a < 0 == !!i && a && s > (a = Math.abs(a)) && ((l = o), (s = a));
    return l;
  },
  ds = function (e, t, i) {
    var r = e.vars,
      s = r[t],
      o = Rn,
      a = e._ctx,
      l,
      u,
      c;
    if (s)
      return (
        (l = r[t + "Params"]),
        (u = r.callbackScope || e),
        i && Dl.length && p_(),
        a && (Rn = a),
        (c = l ? s.apply(u, l) : s.call(u)),
        (Rn = o),
        c
      );
  },
  qd = function (e) {
    return (
      Gl(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!Oi),
      e.progress() < 1 && ds(e, "onInterrupt"),
      e
    );
  },
  Qf,
  cU = [],
  fU = function (e) {
    if (e)
      if (((e = (!e.name && e.default) || e), $T() || e.headless)) {
        var t = e.name,
          i = Vn(e),
          r =
            t && !i && e.init
              ? function () {
                  this._props = [];
                }
              : e,
          s = {
            init: _m,
            render: cC,
            add: oC,
            kill: VK,
            modifier: GK,
            rawVars: 0,
          },
          o = {
            targetTest: 0,
            get: 0,
            getSetter: uC,
            aliases: {},
            register: 0,
          };
        if ((Nh(), e !== r)) {
          if (os[t]) return;
          As(r, As(m_(e, s), o)),
            Dh(r.prototype, Dh(s, m_(e, o))),
            (os[(r.prop = t)] = r),
            e.targetTest && (Gv.push(r), (nC[t] = 1)),
            (t =
              (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
              "Plugin");
        }
        jO(t, r), e.register && e.register(Yr, r, Jr);
      } else cU.push(e);
  },
  _n = 255,
  $d = {
    aqua: [0, _n, _n],
    lime: [0, _n, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _n],
    navy: [0, 0, 128],
    white: [_n, _n, _n],
    olive: [128, 128, 0],
    yellow: [_n, _n, 0],
    orange: [_n, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_n, 0, 0],
    pink: [_n, 192, 203],
    cyan: [0, _n, _n],
    transparent: [_n, _n, _n, 0],
  },
  ES = function (e, t, i) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (i - t) * e * 6
        : e < 0.5
        ? i
        : e * 3 < 2
        ? t + (i - t) * (2 / 3 - e) * 6
        : t) *
        _n +
        0.5) |
        0
    );
  },
  hU = function (e, t, i) {
    var r = e ? (Ha(e) ? [e >> 16, (e >> 8) & _n, e & _n] : 0) : $d.black,
      s,
      o,
      a,
      l,
      u,
      c,
      d,
      p,
      m,
      v;
    if (!r) {
      if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), $d[e]))
        r = $d[e];
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((s = e.charAt(1)),
            (o = e.charAt(2)),
            (a = e.charAt(3)),
            (e =
              "#" +
              s +
              s +
              o +
              o +
              a +
              a +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (r = parseInt(e.substr(1, 6), 16)),
            [r >> 16, (r >> 8) & _n, r & _n, parseInt(e.substr(7), 16) / 255]
          );
        (e = parseInt(e.substr(1), 16)), (r = [e >> 16, (e >> 8) & _n, e & _n]);
      } else if (e.substr(0, 3) === "hsl") {
        if (((r = v = e.match(pw)), !t))
          (l = (+r[0] % 360) / 360),
            (u = +r[1] / 100),
            (c = +r[2] / 100),
            (o = c <= 0.5 ? c * (u + 1) : c + u - c * u),
            (s = c * 2 - o),
            r.length > 3 && (r[3] *= 1),
            (r[0] = ES(l + 1 / 3, s, o)),
            (r[1] = ES(l, s, o)),
            (r[2] = ES(l - 1 / 3, s, o));
        else if (~e.indexOf("="))
          return (r = e.match(GO)), i && r.length < 4 && (r[3] = 1), r;
      } else r = e.match(pw) || $d.transparent;
      r = r.map(Number);
    }
    return (
      t &&
        !v &&
        ((s = r[0] / _n),
        (o = r[1] / _n),
        (a = r[2] / _n),
        (d = Math.max(s, o, a)),
        (p = Math.min(s, o, a)),
        (c = (d + p) / 2),
        d === p
          ? (l = u = 0)
          : ((m = d - p),
            (u = c > 0.5 ? m / (2 - d - p) : m / (d + p)),
            (l =
              d === s
                ? (o - a) / m + (o < a ? 6 : 0)
                : d === o
                ? (a - s) / m + 2
                : (s - o) / m + 4),
            (l *= 60)),
        (r[0] = ~~(l + 0.5)),
        (r[1] = ~~(u * 100 + 0.5)),
        (r[2] = ~~(c * 100 + 0.5))),
      i && r.length < 4 && (r[3] = 1),
      r
    );
  },
  dU = function (e) {
    var t = [],
      i = [],
      r = -1;
    return (
      e.split(Ll).forEach(function (s) {
        var o = s.match(Kf) || [];
        t.push.apply(t, o), i.push((r += o.length + 1));
      }),
      (t.c = i),
      t
    );
  },
  oI = function (e, t, i) {
    var r = "",
      s = (e + r).match(Ll),
      o = t ? "hsla(" : "rgba(",
      a = 0,
      l,
      u,
      c,
      d;
    if (!s) return e;
    if (
      ((s = s.map(function (p) {
        return (
          (p = hU(p, t, 1)) &&
          o +
            (t ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) +
            ")"
        );
      })),
      i && ((c = dU(e)), (l = i.c), l.join(r) !== c.c.join(r)))
    )
      for (u = e.replace(Ll, "1").split(Kf), d = u.length - 1; a < d; a++)
        r +=
          u[a] +
          (~l.indexOf(a)
            ? s.shift() || o + "0,0,0,0)"
            : (c.length ? c : s.length ? s : i).shift());
    if (!u)
      for (u = e.split(Ll), d = u.length - 1; a < d; a++) r += u[a] + s[a];
    return r + u[d];
  },
  Ll = (function () {
    var n =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e;
    for (e in $d) n += "|" + e + "\\b";
    return new RegExp(n + ")", "gi");
  })(),
  bK = /hsl[a]?\(/,
  pU = function (e) {
    var t = e.join(" "),
      i;
    if (((Ll.lastIndex = 0), Ll.test(t)))
      return (
        (i = bK.test(t)),
        (e[1] = oI(e[1], i)),
        (e[0] = oI(e[0], i, dU(e[1]))),
        !0
      );
  },
  Am,
  ls = (function () {
    var n = Date.now,
      e = 500,
      t = 33,
      i = n(),
      r = i,
      s = 1e3 / 240,
      o = s,
      a = [],
      l,
      u,
      c,
      d,
      p,
      m,
      v = function _(x) {
        var g = n() - r,
          A = x === !0,
          S,
          w,
          C,
          b;
        if (
          ((g > e || g < 0) && (i += g - t),
          (r += g),
          (C = r - i),
          (S = C - o),
          (S > 0 || A) &&
            ((b = ++d.frame),
            (p = C - d.time * 1e3),
            (d.time = C = C / 1e3),
            (o += S + (S >= s ? 4 : s - S)),
            (w = 1)),
          A || (l = u(_)),
          w)
        )
          for (m = 0; m < a.length; m++) a[m](C, p, b, x);
      };
    return (
      (d = {
        time: 0,
        frame: 0,
        tick: function () {
          v(!0);
        },
        deltaRatio: function (x) {
          return p / (1e3 / (x || 60));
        },
        wake: function () {
          XO &&
            (!mw &&
              $T() &&
              ((Fo = mw = window),
              (eC = Fo.document || {}),
              (xs.gsap = Yr),
              (Fo.gsapVersions || (Fo.gsapVersions = [])).push(Yr.version),
              JO(d_ || Fo.GreenSockGlobals || (!Fo.gsap && Fo) || {}),
              cU.forEach(fU)),
            (c = typeof requestAnimationFrame < "u" && requestAnimationFrame),
            l && d.sleep(),
            (u =
              c ||
              function (x) {
                return setTimeout(x, (o - d.time * 1e3 + 1) | 0);
              }),
            (Am = 1),
            v(2));
        },
        sleep: function () {
          (c ? cancelAnimationFrame : clearTimeout)(l), (Am = 0), (u = _m);
        },
        lagSmoothing: function (x, g) {
          (e = x || 1 / 0), (t = Math.min(g || 33, e));
        },
        fps: function (x) {
          (s = 1e3 / (x || 240)), (o = d.time * 1e3 + s);
        },
        add: function (x, g, A) {
          var S = g
            ? function (w, C, b, P) {
                x(w, C, b, P), d.remove(S);
              }
            : x;
          return d.remove(x), a[A ? "unshift" : "push"](S), Nh(), S;
        },
        remove: function (x, g) {
          ~(g = a.indexOf(x)) && a.splice(g, 1) && m >= g && m--;
        },
        _listeners: a,
      }),
      d
    );
  })(),
  Nh = function () {
    return !Am && ls.wake();
  },
  Zt = {},
  RK = /^[\d.\-M][\d.\-,\s]/,
  PK = /["']/g,
  BK = function (e) {
    for (
      var t = {},
        i = e.substr(1, e.length - 3).split(":"),
        r = i[0],
        s = 1,
        o = i.length,
        a,
        l,
        u;
      s < o;
      s++
    )
      (l = i[s]),
        (a = s !== o - 1 ? l.lastIndexOf(",") : l.length),
        (u = l.substr(0, a)),
        (t[r] = isNaN(u) ? u.replace(PK, "").trim() : +u),
        (r = l.substr(a + 1).trim());
    return t;
  },
  IK = function (e) {
    var t = e.indexOf("(") + 1,
      i = e.indexOf(")"),
      r = e.indexOf("(", t);
    return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i);
  },
  DK = function (e) {
    var t = (e + "").split("("),
      i = Zt[t[0]];
    return i && t.length > 1 && i.config
      ? i.config.apply(
          null,
          ~e.indexOf("{") ? [BK(t[1])] : IK(e).split(",").map(ZO)
        )
      : Zt._CE && RK.test(e)
      ? Zt._CE("", e)
      : i;
  },
  mU = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  gU = function n(e, t) {
    for (var i = e._first, r; i; )
      i instanceof yr
        ? n(i, t)
        : i.vars.yoyoEase &&
          (!i._yoyo || !i._repeat) &&
          i._yoyo !== t &&
          (i.timeline
            ? n(i.timeline, t)
            : ((r = i._ease),
              (i._ease = i._yEase),
              (i._yEase = r),
              (i._yoyo = t))),
        (i = i._next);
  },
  cc = function (e, t) {
    return (e && (Vn(e) ? e : Zt[e] || DK(e))) || t;
  },
  zc = function (e, t, i, r) {
    i === void 0 &&
      (i = function (l) {
        return 1 - t(1 - l);
      }),
      r === void 0 &&
        (r = function (l) {
          return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
        });
    var s = { easeIn: t, easeOut: i, easeInOut: r },
      o;
    return (
      Xr(e, function (a) {
        (Zt[a] = xs[a] = s), (Zt[(o = a.toLowerCase())] = i);
        for (var l in s)
          Zt[
            o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")
          ] = Zt[a + "." + l] = s[l];
      }),
      s
    );
  },
  vU = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  TS = function n(e, t, i) {
    var r = t >= 1 ? t : 1,
      s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      o = (s / dw) * (Math.asin(1 / r) || 0),
      a = function (c) {
        return c === 1 ? 1 : r * Math.pow(2, -10 * c) * aK((c - o) * s) + 1;
      },
      l =
        e === "out"
          ? a
          : e === "in"
          ? function (u) {
              return 1 - a(1 - u);
            }
          : vU(a);
    return (
      (s = dw / s),
      (l.config = function (u, c) {
        return n(e, u, c);
      }),
      l
    );
  },
  CS = function n(e, t) {
    t === void 0 && (t = 1.70158);
    var i = function (o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
      },
      r =
        e === "out"
          ? i
          : e === "in"
          ? function (s) {
              return 1 - i(1 - s);
            }
          : vU(i);
    return (
      (r.config = function (s) {
        return n(e, s);
      }),
      r
    );
  };
Xr("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) {
  var t = e < 5 ? e + 1 : e;
  zc(
    n + ",Power" + (t - 1),
    e
      ? function (i) {
          return Math.pow(i, t);
        }
      : function (i) {
          return i;
        },
    function (i) {
      return 1 - Math.pow(1 - i, t);
    },
    function (i) {
      return i < 0.5
        ? Math.pow(i * 2, t) / 2
        : 1 - Math.pow((1 - i) * 2, t) / 2;
    }
  );
});
Zt.Linear.easeNone = Zt.none = Zt.Linear.easeIn;
zc("Elastic", TS("in"), TS("out"), TS());
(function (n, e) {
  var t = 1 / e,
    i = 2 * t,
    r = 2.5 * t,
    s = function (a) {
      return a < t
        ? n * a * a
        : a < i
        ? n * Math.pow(a - 1.5 / e, 2) + 0.75
        : a < r
        ? n * (a -= 2.25 / e) * a + 0.9375
        : n * Math.pow(a - 2.625 / e, 2) + 0.984375;
    };
  zc(
    "Bounce",
    function (o) {
      return 1 - s(1 - o);
    },
    s
  );
})(7.5625, 2.75);
zc("Expo", function (n) {
  return Math.pow(2, 10 * (n - 1)) * n + n * n * n * n * n * n * (1 - n);
});
zc("Circ", function (n) {
  return -(zO(1 - n * n) - 1);
});
zc("Sine", function (n) {
  return n === 1 ? 1 : -oK(n * rK) + 1;
});
zc("Back", CS("in"), CS("out"), CS());
Zt.SteppedEase =
  Zt.steps =
  xs.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var i = 1 / e,
          r = e + (t ? 0 : 1),
          s = t ? 1 : 0,
          o = 1 - xn;
        return function (a) {
          return (((r * ng(0, o, a)) | 0) + s) * i;
        };
      },
    };
Ih.ease = Zt["quad.out"];
Xr(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (n) {
    return (iC += n + "," + n + "Params,");
  }
);
var yU = function (e, t) {
    (this.id = sK++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : KO),
      (this.set = t ? t.getSetter : uC);
  },
  Sm = (function () {
    function n(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        Fh(this, +t.duration, 1, 1),
        (this.data = t.data),
        Rn && ((this._ctx = Rn), Rn.data.push(this)),
        Am || ls.wake();
    }
    var e = n.prototype;
    return (
      (e.delay = function (i) {
        return i || i === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + i - this._delay),
            (this._delay = i),
            this)
          : this._delay;
      }),
      (e.duration = function (i) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (i) {
        return arguments.length
          ? ((this._dirty = 0),
            Fh(
              this,
              this._repeat < 0
                ? i
                : (i - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (i, r) {
        if ((Nh(), !arguments.length)) return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
          for (Lx(this, i), !s._dp || s.parent || eU(s, this); s && s.parent; )
            s.parent._time !==
              s._start +
                (s._ts >= 0
                  ? s._tTime / s._ts
                  : (s.totalDuration() - s._tTime) / -s._ts) &&
              s.totalTime(s._tTime, !0),
              (s = s.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && i < this._tDur) ||
              (this._ts < 0 && i > 0) ||
              (!this._tDur && !i)) &&
            Uo(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== i ||
            (!this._dur && !r) ||
            (this._initted && Math.abs(this._zTime) === xn) ||
            (!i && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = i), QO(this, i, r)),
          this
        );
      }),
      (e.time = function (i, r) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), i + iI(this)) %
                (this._dur + this._rDelay) || (i ? this._dur : 0),
              r
            )
          : this._time;
      }),
      (e.totalProgress = function (i, r) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * i, r)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.rawTime() >= 0 && this._initted
          ? 1
          : 0;
      }),
      (e.progress = function (i, r) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) +
                iI(this),
              r
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.rawTime() > 0
          ? 1
          : 0;
      }),
      (e.iteration = function (i, r) {
        var s = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (i - 1) * s, r)
          : this._repeat
          ? Lh(this._tTime, s) + 1
          : 1;
      }),
      (e.timeScale = function (i, r) {
        if (!arguments.length) return this._rts === -xn ? 0 : this._rts;
        if (this._rts === i) return this;
        var s =
          this.parent && this._ts ? g_(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +i || 0),
          (this._ts = this._ps || i === -xn ? 0 : this._rts),
          this.totalTime(
            ng(-Math.abs(this._delay), this.totalDuration(), s),
            r !== !1
          ),
          Dx(this),
          pK(this)
        );
      }),
      (e.paused = function (i) {
        return arguments.length
          ? (this._ps !== i &&
              ((this._ps = i),
              i
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (Nh(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== xn &&
                      (this._tTime -= xn)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (i) {
        if (arguments.length) {
          this._start = i;
          var r = this.parent || this._dp;
          return (
            r && (r._sort || !this.parent) && Uo(r, this, i - this._delay), this
          );
        }
        return this._start;
      }),
      (e.endTime = function (i) {
        return (
          this._start +
          (Wr(i) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (i) {
        var r = this.parent || this._dp;
        return r
          ? i &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? g_(r.rawTime(i), this)
            : this._tTime
          : this._tTime;
      }),
      (e.revert = function (i) {
        i === void 0 && (i = cK);
        var r = Oi;
        return (
          (Oi = i),
          sC(this) &&
            (this.timeline && this.timeline.revert(i),
            this.totalTime(-0.01, i.suppressEvents)),
          this.data !== "nested" && i.kill !== !1 && this.kill(),
          (Oi = r),
          this
        );
      }),
      (e.globalTime = function (i) {
        for (var r = this, s = arguments.length ? i : r.rawTime(); r; )
          (s = r._start + s / (Math.abs(r._ts) || 1)), (r = r._dp);
        return !this.parent && this._sat ? this._sat.globalTime(i) : s;
      }),
      (e.repeat = function (i) {
        return arguments.length
          ? ((this._repeat = i === 1 / 0 ? -2 : i), rI(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (e.repeatDelay = function (i) {
        if (arguments.length) {
          var r = this._time;
          return (this._rDelay = i), rI(this), r ? this.time(r) : this;
        }
        return this._rDelay;
      }),
      (e.yoyo = function (i) {
        return arguments.length ? ((this._yoyo = i), this) : this._yoyo;
      }),
      (e.seek = function (i, r) {
        return this.totalTime(Ns(this, i), Wr(r));
      }),
      (e.restart = function (i, r) {
        return (
          this.play().totalTime(i ? -this._delay : 0, Wr(r)),
          this._dur || (this._zTime = -xn),
          this
        );
      }),
      (e.play = function (i, r) {
        return i != null && this.seek(i, r), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (i, r) {
        return (
          i != null && this.seek(i || this.totalDuration(), r),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (i, r) {
        return i != null && this.seek(i, r), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (i) {
        return arguments.length
          ? (!!i !== this.reversed() &&
              this.timeScale(-this._rts || (i ? -xn : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -xn), this;
      }),
      (e.isActive = function () {
        var i = this.parent || this._dp,
          r = this._start,
          s;
        return !!(
          !i ||
          (this._ts &&
            this._initted &&
            i.isActive() &&
            (s = i.rawTime(!0)) >= r &&
            s < this.endTime(!0) - xn)
        );
      }),
      (e.eventCallback = function (i, r, s) {
        var o = this.vars;
        return arguments.length > 1
          ? (r
              ? ((o[i] = r),
                s && (o[i + "Params"] = s),
                i === "onUpdate" && (this._onUpdate = r))
              : delete o[i],
            this)
          : o[i];
      }),
      (e.then = function (i) {
        var r = this;
        return new Promise(function (s) {
          var o = Vn(i) ? i : qO,
            a = function () {
              var u = r.then;
              (r.then = null),
                Vn(o) && (o = o(r)) && (o.then || o === r) && (r.then = u),
                s(o),
                (r.then = u);
            };
          (r._initted && r.totalProgress() === 1 && r._ts >= 0) ||
          (!r._tTime && r._ts < 0)
            ? a()
            : (r._prom = a);
        });
      }),
      (e.kill = function () {
        qd(this);
      }),
      n
    );
  })();
As(Sm.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -xn,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var yr = (function (n) {
  kO(e, n);
  function e(i, r) {
    var s;
    return (
      i === void 0 && (i = {}),
      (s = n.call(this, i) || this),
      (s.labels = {}),
      (s.smoothChildTiming = !!i.smoothChildTiming),
      (s.autoRemoveChildren = !!i.autoRemoveChildren),
      (s._sort = Wr(i.sortChildren)),
      Ln && Uo(i.parent || Ln, da(s), r),
      i.reversed && s.reverse(),
      i.paused && s.paused(!0),
      i.scrollTrigger && tU(da(s), i.scrollTrigger),
      s
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (r, s, o) {
      return Ep(0, arguments, this), this;
    }),
    (t.from = function (r, s, o) {
      return Ep(1, arguments, this), this;
    }),
    (t.fromTo = function (r, s, o, a) {
      return Ep(2, arguments, this), this;
    }),
    (t.set = function (r, s, o) {
      return (
        (s.duration = 0),
        (s.parent = this),
        wp(s).repeatDelay || (s.repeat = 0),
        (s.immediateRender = !!s.immediateRender),
        new si(r, s, Ns(this, o), 1),
        this
      );
    }),
    (t.call = function (r, s, o) {
      return Uo(this, si.delayedCall(0, r, s), o);
    }),
    (t.staggerTo = function (r, s, o, a, l, u, c) {
      return (
        (o.duration = s),
        (o.stagger = o.stagger || a),
        (o.onComplete = u),
        (o.onCompleteParams = c),
        (o.parent = this),
        new si(r, o, Ns(this, l)),
        this
      );
    }),
    (t.staggerFrom = function (r, s, o, a, l, u, c) {
      return (
        (o.runBackwards = 1),
        (wp(o).immediateRender = Wr(o.immediateRender)),
        this.staggerTo(r, s, o, a, l, u, c)
      );
    }),
    (t.staggerFromTo = function (r, s, o, a, l, u, c, d) {
      return (
        (a.startAt = o),
        (wp(a).immediateRender = Wr(a.immediateRender)),
        this.staggerTo(r, s, a, l, u, c, d)
      );
    }),
    (t.render = function (r, s, o) {
      var a = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        u = this._dur,
        c = r <= 0 ? 0 : oi(r),
        d = this._zTime < 0 != r < 0 && (this._initted || !u),
        p,
        m,
        v,
        _,
        x,
        g,
        A,
        S,
        w,
        C,
        b,
        P;
      if (
        (this !== Ln && c > l && r >= 0 && (c = l), c !== this._tTime || o || d)
      ) {
        if (
          (a !== this._time &&
            u &&
            ((c += this._time - a), (r += this._time - a)),
          (p = c),
          (w = this._start),
          (S = this._ts),
          (g = !S),
          d && (u || (a = this._zTime), (r || !s) && (this._zTime = r)),
          this._repeat)
        ) {
          if (
            ((b = this._yoyo),
            (x = u + this._rDelay),
            this._repeat < -1 && r < 0)
          )
            return this.totalTime(x * 100 + r, s, o);
          if (
            ((p = oi(c % x)),
            c === l
              ? ((_ = this._repeat), (p = u))
              : ((C = oi(c / x)),
                (_ = ~~C),
                _ && _ === C && ((p = u), _--),
                p > u && (p = u)),
            (C = Lh(this._tTime, x)),
            !a &&
              this._tTime &&
              C !== _ &&
              this._tTime - C * x - this._dur <= 0 &&
              (C = _),
            b && _ & 1 && ((p = u - p), (P = 1)),
            _ !== C && !this._lock)
          ) {
            var I = b && C & 1,
              R = I === (b && _ & 1);
            if (
              (_ < C && (I = !I),
              (a = I ? 0 : c % u ? u : c),
              (this._lock = 1),
              (this.render(a || (P ? 0 : oi(_ * x)), s, !u)._lock = 0),
              (this._tTime = c),
              !s && this.parent && ds(this, "onRepeat"),
              this.vars.repeatRefresh && !P && (this.invalidate()._lock = 1),
              (a && a !== this._time) ||
                g !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((u = this._dur),
              (l = this._tDur),
              R &&
                ((this._lock = 2),
                (a = I ? u : -1e-4),
                this.render(a, !0),
                this.vars.repeatRefresh && !P && this.invalidate()),
              (this._lock = 0),
              !this._ts && !g)
            )
              return this;
            gU(this, P);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((A = yK(this, oi(a), oi(p))), A && (c -= p - (p = A._start))),
          (this._tTime = c),
          (this._time = p),
          (this._act = !S),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = r),
            (a = 0)),
          !a && c && !s && !C && (ds(this, "onStart"), this._tTime !== c))
        )
          return this;
        if (p >= a && r >= 0)
          for (m = this._first; m; ) {
            if (
              ((v = m._next), (m._act || p >= m._start) && m._ts && A !== m)
            ) {
              if (m.parent !== this) return this.render(r, s, o);
              if (
                (m.render(
                  m._ts > 0
                    ? (p - m._start) * m._ts
                    : (m._dirty ? m.totalDuration() : m._tDur) +
                        (p - m._start) * m._ts,
                  s,
                  o
                ),
                p !== this._time || (!this._ts && !g))
              ) {
                (A = 0), v && (c += this._zTime = -xn);
                break;
              }
            }
            m = v;
          }
        else {
          m = this._last;
          for (var T = r < 0 ? r : p; m; ) {
            if (((v = m._prev), (m._act || T <= m._end) && m._ts && A !== m)) {
              if (m.parent !== this) return this.render(r, s, o);
              if (
                (m.render(
                  m._ts > 0
                    ? (T - m._start) * m._ts
                    : (m._dirty ? m.totalDuration() : m._tDur) +
                        (T - m._start) * m._ts,
                  s,
                  o || (Oi && sC(m))
                ),
                p !== this._time || (!this._ts && !g))
              ) {
                (A = 0), v && (c += this._zTime = T ? -xn : xn);
                break;
              }
            }
            m = v;
          }
        }
        if (
          A &&
          !s &&
          (this.pause(),
          (A.render(p >= a ? 0 : -xn)._zTime = p >= a ? 1 : -1),
          this._ts)
        )
          return (this._start = w), Dx(this), this.render(r, s, o);
        this._onUpdate && !s && ds(this, "onUpdate", !0),
          ((c === l && this._tTime >= this.totalDuration()) || (!c && a)) &&
            (w === this._start || Math.abs(S) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((r || !u) &&
                ((c === l && this._ts > 0) || (!c && this._ts < 0)) &&
                Gl(this, 1),
              !s &&
                !(r < 0 && !a) &&
                (c || a || !l) &&
                (ds(
                  this,
                  c === l && r >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(c < l && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (t.add = function (r, s) {
      var o = this;
      if ((Ha(s) || (s = Ns(this, s, r)), !(r instanceof Sm))) {
        if (tr(r))
          return (
            r.forEach(function (a) {
              return o.add(a, s);
            }),
            this
          );
        if (Pi(r)) return this.addLabel(r, s);
        if (Vn(r)) r = si.delayedCall(0, r);
        else return this;
      }
      return this !== r ? Uo(this, r, s) : this;
    }),
    (t.getChildren = function (r, s, o, a) {
      r === void 0 && (r = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -Js);
      for (var l = [], u = this._first; u; )
        u._start >= a &&
          (u instanceof si
            ? s && l.push(u)
            : (o && l.push(u), r && l.push.apply(l, u.getChildren(!0, s, o)))),
          (u = u._next);
      return l;
    }),
    (t.getById = function (r) {
      for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
        if (s[o].vars.id === r) return s[o];
    }),
    (t.remove = function (r) {
      return Pi(r)
        ? this.removeLabel(r)
        : Vn(r)
        ? this.killTweensOf(r)
        : (r.parent === this && Ix(this, r),
          r === this._recent && (this._recent = this._last),
          uc(this));
    }),
    (t.totalTime = function (r, s) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = oi(
              ls.time -
                (this._ts > 0
                  ? r / this._ts
                  : (this.totalDuration() - r) / -this._ts)
            )),
          n.prototype.totalTime.call(this, r, s),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (r, s) {
      return (this.labels[r] = Ns(this, s)), this;
    }),
    (t.removeLabel = function (r) {
      return delete this.labels[r], this;
    }),
    (t.addPause = function (r, s, o) {
      var a = si.delayedCall(0, s || _m, o);
      return (
        (a.data = "isPause"), (this._hasPause = 1), Uo(this, a, Ns(this, r))
      );
    }),
    (t.removePause = function (r) {
      var s = this._first;
      for (r = Ns(this, r); s; )
        s._start === r && s.data === "isPause" && Gl(s), (s = s._next);
    }),
    (t.killTweensOf = function (r, s, o) {
      for (var a = this.getTweensOf(r, o), l = a.length; l--; )
        _l !== a[l] && a[l].kill(r, s);
      return this;
    }),
    (t.getTweensOf = function (r, s) {
      for (var o = [], a = js(r), l = this._first, u = Ha(s), c; l; )
        l instanceof si
          ? fK(l._targets, a) &&
            (u
              ? (!_l || (l._initted && l._ts)) &&
                l.globalTime(0) <= s &&
                l.globalTime(l.totalDuration()) > s
              : !s || l.isActive()) &&
            o.push(l)
          : (c = l.getTweensOf(a, s)).length && o.push.apply(o, c),
          (l = l._next);
      return o;
    }),
    (t.tweenTo = function (r, s) {
      s = s || {};
      var o = this,
        a = Ns(o, r),
        l = s,
        u = l.startAt,
        c = l.onStart,
        d = l.onStartParams,
        p = l.immediateRender,
        m,
        v = si.to(
          o,
          As(
            {
              ease: s.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: a,
              overwrite: "auto",
              duration:
                s.duration ||
                Math.abs(
                  (a - (u && "time" in u ? u.time : o._time)) / o.timeScale()
                ) ||
                xn,
              onStart: function () {
                if ((o.pause(), !m)) {
                  var x =
                    s.duration ||
                    Math.abs(
                      (a - (u && "time" in u ? u.time : o._time)) /
                        o.timeScale()
                    );
                  v._dur !== x && Fh(v, x, 0, 1).render(v._time, !0, !0),
                    (m = 1);
                }
                c && c.apply(v, d || []);
              },
            },
            s
          )
        );
      return p ? v.render(0) : v;
    }),
    (t.tweenFromTo = function (r, s, o) {
      return this.tweenTo(s, As({ startAt: { time: Ns(this, r) } }, o));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (r) {
      return r === void 0 && (r = this._time), sI(this, Ns(this, r));
    }),
    (t.previousLabel = function (r) {
      return r === void 0 && (r = this._time), sI(this, Ns(this, r), 1);
    }),
    (t.currentLabel = function (r) {
      return arguments.length
        ? this.seek(r, !0)
        : this.previousLabel(this._time + xn);
    }),
    (t.shiftChildren = function (r, s, o) {
      o === void 0 && (o = 0);
      for (var a = this._first, l = this.labels, u; a; )
        a._start >= o && ((a._start += r), (a._end += r)), (a = a._next);
      if (s) for (u in l) l[u] >= o && (l[u] += r);
      return uc(this);
    }),
    (t.invalidate = function (r) {
      var s = this._first;
      for (this._lock = 0; s; ) s.invalidate(r), (s = s._next);
      return n.prototype.invalidate.call(this, r);
    }),
    (t.clear = function (r) {
      r === void 0 && (r = !0);
      for (var s = this._first, o; s; ) (o = s._next), this.remove(s), (s = o);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        r && (this.labels = {}),
        uc(this)
      );
    }),
    (t.totalDuration = function (r) {
      var s = 0,
        o = this,
        a = o._last,
        l = Js,
        u,
        c,
        d;
      if (arguments.length)
        return o.timeScale(
          (o._repeat < 0 ? o.duration() : o.totalDuration()) /
            (o.reversed() ? -r : r)
        );
      if (o._dirty) {
        for (d = o.parent; a; )
          (u = a._prev),
            a._dirty && a.totalDuration(),
            (c = a._start),
            c > l && o._sort && a._ts && !o._lock
              ? ((o._lock = 1), (Uo(o, a, c - a._delay, 1)._lock = 0))
              : (l = c),
            c < 0 &&
              a._ts &&
              ((s -= c),
              ((!d && !o._dp) || (d && d.smoothChildTiming)) &&
                ((o._start += c / o._ts), (o._time -= c), (o._tTime -= c)),
              o.shiftChildren(-c, !1, -1 / 0),
              (l = 0)),
            a._end > s && a._ts && (s = a._end),
            (a = u);
        Fh(o, o === Ln && o._time > s ? o._time : s, 1, 1), (o._dirty = 0);
      }
      return o._tDur;
    }),
    (e.updateRoot = function (r) {
      if ((Ln._ts && (QO(Ln, g_(r, Ln)), (YO = ls.frame)), ls.frame >= tI)) {
        tI += gs.autoSleep || 120;
        var s = Ln._first;
        if ((!s || !s._ts) && gs.autoSleep && ls._listeners.length < 2) {
          for (; s && !s._ts; ) s = s._next;
          s || ls.sleep();
        }
      }
    }),
    e
  );
})(Sm);
As(yr.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var LK = function (e, t, i, r, s, o, a) {
    var l = new Jr(this._pt, e, t, 0, 1, wU, null, s),
      u = 0,
      c = 0,
      d,
      p,
      m,
      v,
      _,
      x,
      g,
      A;
    for (
      l.b = i,
        l.e = r,
        i += "",
        r += "",
        (g = ~r.indexOf("random(")) && (r = xm(r)),
        o && ((A = [i, r]), o(A, e, t), (i = A[0]), (r = A[1])),
        p = i.match(MS) || [];
      (d = MS.exec(r));

    )
      (v = d[0]),
        (_ = r.substring(u, d.index)),
        m ? (m = (m + 1) % 5) : _.substr(-5) === "rgba(" && (m = 1),
        v !== p[c++] &&
          ((x = parseFloat(p[c - 1]) || 0),
          (l._pt = {
            _next: l._pt,
            p: _ || c === 1 ? _ : ",",
            s: x,
            c: v.charAt(1) === "=" ? fh(x, v) - x : parseFloat(v) - x,
            m: m && m < 4 ? Math.round : 0,
          }),
          (u = MS.lastIndex));
    return (
      (l.c = u < r.length ? r.substring(u, r.length) : ""),
      (l.fp = a),
      (VO.test(r) || g) && (l.e = 0),
      (this._pt = l),
      l
    );
  },
  oC = function (e, t, i, r, s, o, a, l, u, c) {
    Vn(r) && (r = r(s || 0, e, o));
    var d = e[t],
      p =
        i !== "get"
          ? i
          : Vn(d)
          ? u
            ? e[
                t.indexOf("set") || !Vn(e["get" + t.substr(3)])
                  ? t
                  : "get" + t.substr(3)
              ](u)
            : e[t]()
          : d,
      m = Vn(d) ? (u ? kK : SU) : lC,
      v;
    if (
      (Pi(r) &&
        (~r.indexOf("random(") && (r = xm(r)),
        r.charAt(1) === "=" &&
          ((v = fh(p, r) + (Zi(p) || 0)), (v || v === 0) && (r = v))),
      !c || p !== r || Sw)
    )
      return !isNaN(p * r) && r !== ""
        ? ((v = new Jr(
            this._pt,
            e,
            t,
            +p || 0,
            r - (p || 0),
            typeof d == "boolean" ? HK : MU,
            0,
            m
          )),
          u && (v.fp = u),
          a && v.modifier(a, this, e),
          (this._pt = v))
        : (!d && !(t in e) && tC(t, r),
          LK.call(this, e, t, p, r, m, l || gs.stringFilter, u));
  },
  FK = function (e, t, i, r, s) {
    if (
      (Vn(e) && (e = Tp(e, s, t, i, r)),
      !Qo(e) || (e.style && e.nodeType) || tr(e) || HO(e))
    )
      return Pi(e) ? Tp(e, s, t, i, r) : e;
    var o = {},
      a;
    for (a in e) o[a] = Tp(e[a], s, t, i, r);
    return o;
  },
  _U = function (e, t, i, r, s, o) {
    var a, l, u, c;
    if (
      os[e] &&
      (a = new os[e]()).init(
        s,
        a.rawVars ? t[e] : FK(t[e], r, s, o, i),
        i,
        r,
        o
      ) !== !1 &&
      ((i._pt = l = new Jr(i._pt, s, e, 0, 1, a.render, a, 0, a.priority)),
      i !== Qf)
    )
      for (u = i._ptLookup[i._targets.indexOf(s)], c = a._props.length; c--; )
        u[a._props[c]] = l;
    return a;
  },
  _l,
  Sw,
  aC = function n(e, t, i) {
    var r = e.vars,
      s = r.ease,
      o = r.startAt,
      a = r.immediateRender,
      l = r.lazy,
      u = r.onUpdate,
      c = r.runBackwards,
      d = r.yoyoEase,
      p = r.keyframes,
      m = r.autoRevert,
      v = e._dur,
      _ = e._startAt,
      x = e._targets,
      g = e.parent,
      A = g && g.data === "nested" ? g.vars.targets : x,
      S = e._overwrite === "auto" && !ZT,
      w = e.timeline,
      C,
      b,
      P,
      I,
      R,
      T,
      D,
      G,
      W,
      q,
      Z,
      K,
      te;
    if (
      (w && (!p || !s) && (s = "none"),
      (e._ease = cc(s, Ih.ease)),
      (e._yEase = d ? mU(cc(d === !0 ? s : d, Ih.ease)) : 0),
      d &&
        e._yoyo &&
        !e._repeat &&
        ((d = e._yEase), (e._yEase = e._ease), (e._ease = d)),
      (e._from = !w && !!r.runBackwards),
      !w || (p && !r.stagger))
    ) {
      if (
        ((G = x[0] ? lc(x[0]).harness : 0),
        (K = G && r[G.prop]),
        (C = m_(r, nC)),
        _ &&
          (_._zTime < 0 && _.progress(1),
          t < 0 && c && a && !m ? _.render(-1, !0) : _.revert(c && v ? Hv : uK),
          (_._lazy = 0)),
        o)
      ) {
        if (
          (Gl(
            (e._startAt = si.set(
              x,
              As(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: g,
                  immediateRender: !0,
                  lazy: !_ && Wr(l),
                  startAt: null,
                  delay: 0,
                  onUpdate:
                    u &&
                    function () {
                      return ds(e, "onUpdate");
                    },
                  stagger: 0,
                },
                o
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (Oi || (!a && !m)) && e._startAt.revert(Hv),
          a && v && t <= 0 && i <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (c && v && !_) {
        if (
          (t && (a = !1),
          (P = As(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: a && !_ && Wr(l),
              immediateRender: a,
              stagger: 0,
              parent: g,
            },
            C
          )),
          K && (P[G.prop] = K),
          Gl((e._startAt = si.set(x, P))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (Oi ? e._startAt.revert(Hv) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !a)
        )
          n(e._startAt, xn, xn);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, l = (v && Wr(l)) || (l && !v), b = 0;
        b < x.length;
        b++
      ) {
        if (
          ((R = x[b]),
          (D = R._gsap || rC(x)[b]._gsap),
          (e._ptLookup[b] = q = {}),
          gw[D.id] && Dl.length && p_(),
          (Z = A === x ? b : A.indexOf(R)),
          G &&
            (W = new G()).init(R, K || C, e, Z, A) !== !1 &&
            ((e._pt = I =
              new Jr(e._pt, R, W.name, 0, 1, W.render, W, 0, W.priority)),
            W._props.forEach(function (O) {
              q[O] = I;
            }),
            W.priority && (T = 1)),
          !G || K)
        )
          for (P in C)
            os[P] && (W = _U(P, C, e, Z, R, A))
              ? W.priority && (T = 1)
              : (q[P] = I =
                  oC.call(e, R, P, "get", C[P], Z, A, 0, r.stringFilter));
        e._op && e._op[b] && e.kill(R, e._op[b]),
          S &&
            e._pt &&
            ((_l = e),
            Ln.killTweensOf(R, q, e.globalTime(t)),
            (te = !e.parent),
            (_l = 0)),
          e._pt && l && (gw[D.id] = 1);
      }
      T && EU(e), e._onInit && e._onInit(e);
    }
    (e._onUpdate = u),
      (e._initted = (!e._op || e._pt) && !te),
      p && t <= 0 && w.render(Js, !0, !0);
  },
  NK = function (e, t, i, r, s, o, a, l) {
    var u = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      c,
      d,
      p,
      m;
    if (!u)
      for (
        u = e._ptCache[t] = [], p = e._ptLookup, m = e._targets.length;
        m--;

      ) {
        if (((c = p[m][t]), c && c.d && c.d._pt))
          for (c = c.d._pt; c && c.p !== t && c.fp !== t; ) c = c._next;
        if (!c)
          return (
            (Sw = 1),
            (e.vars[t] = "+=0"),
            aC(e, a),
            (Sw = 0),
            l ? ym(t + " not eligible for reset") : 1
          );
        u.push(c);
      }
    for (m = u.length; m--; )
      (d = u[m]),
        (c = d._pt || d),
        (c.s = (r || r === 0) && !s ? r : c.s + (r || 0) + o * c.c),
        (c.c = i - c.s),
        d.e && (d.e = Kn(i) + Zi(d.e)),
        d.b && (d.b = c.s + Zi(d.b));
  },
  OK = function (e, t) {
    var i = e[0] ? lc(e[0]).harness : 0,
      r = i && i.aliases,
      s,
      o,
      a,
      l;
    if (!r) return t;
    s = Dh({}, t);
    for (o in r)
      if (o in s) for (l = r[o].split(","), a = l.length; a--; ) s[l[a]] = s[o];
    return s;
  },
  UK = function (e, t, i, r) {
    var s = t.ease || r || "power1.inOut",
      o,
      a;
    if (tr(t))
      (a = i[e] || (i[e] = [])),
        t.forEach(function (l, u) {
          return a.push({ t: (u / (t.length - 1)) * 100, v: l, e: s });
        });
    else
      for (o in t)
        (a = i[o] || (i[o] = [])),
          o === "ease" || a.push({ t: parseFloat(e), v: t[o], e: s });
  },
  Tp = function (e, t, i, r, s) {
    return Vn(e)
      ? e.call(t, i, r, s)
      : Pi(e) && ~e.indexOf("random(")
      ? xm(e)
      : e;
  },
  xU = iC + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  AU = {};
Xr(xU + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) {
  return (AU[n] = 1);
});
var si = (function (n) {
  kO(e, n);
  function e(i, r, s, o) {
    var a;
    typeof r == "number" && ((s.duration = r), (r = s), (s = null)),
      (a = n.call(this, o ? r : wp(r)) || this);
    var l = a.vars,
      u = l.duration,
      c = l.delay,
      d = l.immediateRender,
      p = l.stagger,
      m = l.overwrite,
      v = l.keyframes,
      _ = l.defaults,
      x = l.scrollTrigger,
      g = l.yoyoEase,
      A = r.parent || Ln,
      S = (tr(i) || HO(i) ? Ha(i[0]) : "length" in r) ? [i] : js(i),
      w,
      C,
      b,
      P,
      I,
      R,
      T,
      D;
    if (
      ((a._targets = S.length
        ? rC(S)
        : ym(
            "GSAP target " + i + " not found. https://gsap.com",
            !gs.nullTargetWarn
          ) || []),
      (a._ptLookup = []),
      (a._overwrite = m),
      v || p || cv(u) || cv(c))
    ) {
      if (
        ((r = a.vars),
        (w = a.timeline =
          new yr({
            data: "nested",
            defaults: _ || {},
            targets: A && A.data === "nested" ? A.vars.targets : S,
          })),
        w.kill(),
        (w.parent = w._dp = da(a)),
        (w._start = 0),
        p || cv(u) || cv(c))
      ) {
        if (((P = S.length), (T = p && sU(p)), Qo(p)))
          for (I in p) ~xU.indexOf(I) && (D || (D = {}), (D[I] = p[I]));
        for (C = 0; C < P; C++)
          (b = m_(r, AU)),
            (b.stagger = 0),
            g && (b.yoyoEase = g),
            D && Dh(b, D),
            (R = S[C]),
            (b.duration = +Tp(u, da(a), C, R, S)),
            (b.delay = (+Tp(c, da(a), C, R, S) || 0) - a._delay),
            !p &&
              P === 1 &&
              b.delay &&
              ((a._delay = c = b.delay), (a._start += c), (b.delay = 0)),
            w.to(R, b, T ? T(C, R, S) : 0),
            (w._ease = Zt.none);
        w.duration() ? (u = c = 0) : (a.timeline = 0);
      } else if (v) {
        wp(As(w.vars.defaults, { ease: "none" })),
          (w._ease = cc(v.ease || r.ease || "none"));
        var G = 0,
          W,
          q,
          Z;
        if (tr(v))
          v.forEach(function (K) {
            return w.to(S, K, ">");
          }),
            w.duration();
        else {
          b = {};
          for (I in v)
            I === "ease" || I === "easeEach" || UK(I, v[I], b, v.easeEach);
          for (I in b)
            for (
              W = b[I].sort(function (K, te) {
                return K.t - te.t;
              }),
                G = 0,
                C = 0;
              C < W.length;
              C++
            )
              (q = W[C]),
                (Z = {
                  ease: q.e,
                  duration: ((q.t - (C ? W[C - 1].t : 0)) / 100) * u,
                }),
                (Z[I] = q.v),
                w.to(S, Z, G),
                (G += Z.duration);
          w.duration() < u && w.to({}, { duration: u - w.duration() });
        }
      }
      u || a.duration((u = w.duration()));
    } else a.timeline = 0;
    return (
      m === !0 && !ZT && ((_l = da(a)), Ln.killTweensOf(S), (_l = 0)),
      Uo(A, da(a), s),
      r.reversed && a.reverse(),
      r.paused && a.paused(!0),
      (d ||
        (!u &&
          !v &&
          a._start === oi(A._time) &&
          Wr(d) &&
          mK(da(a)) &&
          A.data !== "nested")) &&
        ((a._tTime = -xn), a.render(Math.max(0, -c) || 0)),
      x && tU(da(a), x),
      a
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (r, s, o) {
      var a = this._time,
        l = this._tDur,
        u = this._dur,
        c = r < 0,
        d = r > l - xn && !c ? l : r < xn ? 0 : r,
        p,
        m,
        v,
        _,
        x,
        g,
        A,
        S,
        w;
      if (!u) vK(this, r, s, o);
      else if (
        d !== this._tTime ||
        !r ||
        o ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== c) ||
        this._lazy
      ) {
        if (((p = d), (S = this.timeline), this._repeat)) {
          if (((_ = u + this._rDelay), this._repeat < -1 && c))
            return this.totalTime(_ * 100 + r, s, o);
          if (
            ((p = oi(d % _)),
            d === l
              ? ((v = this._repeat), (p = u))
              : ((x = oi(d / _)),
                (v = ~~x),
                v && v === x ? ((p = u), v--) : p > u && (p = u)),
            (g = this._yoyo && v & 1),
            g && ((w = this._yEase), (p = u - p)),
            (x = Lh(this._tTime, _)),
            p === a && !o && this._initted && v === x)
          )
            return (this._tTime = d), this;
          v !== x &&
            (S && this._yEase && gU(S, g),
            this.vars.repeatRefresh &&
              !g &&
              !this._lock &&
              p !== _ &&
              this._initted &&
              ((this._lock = o = 1),
              (this.render(oi(_ * v), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (nU(this, c ? r : p, o, s, d)) return (this._tTime = 0), this;
          if (a !== this._time && !(o && this.vars.repeatRefresh && v !== x))
            return this;
          if (u !== this._dur) return this.render(r, s, o);
        }
        if (
          ((this._tTime = d),
          (this._time = p),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = A = (w || this._ease)(p / u)),
          this._from && (this.ratio = A = 1 - A),
          !a && d && !s && !x && (ds(this, "onStart"), this._tTime !== d))
        )
          return this;
        for (m = this._pt; m; ) m.r(A, m.d), (m = m._next);
        (S && S.render(r < 0 ? r : S._dur * S._ease(p / this._dur), s, o)) ||
          (this._startAt && (this._zTime = r)),
          this._onUpdate &&
            !s &&
            (c && vw(this, r, s, o), ds(this, "onUpdate")),
          this._repeat &&
            v !== x &&
            this.vars.onRepeat &&
            !s &&
            this.parent &&
            ds(this, "onRepeat"),
          (d === this._tDur || !d) &&
            this._tTime === d &&
            (c && !this._onUpdate && vw(this, r, !0, !0),
            (r || !u) &&
              ((d === this._tDur && this._ts > 0) || (!d && this._ts < 0)) &&
              Gl(this, 1),
            !s &&
              !(c && !a) &&
              (d || a || g) &&
              (ds(this, d === l ? "onComplete" : "onReverseComplete", !0),
              this._prom && !(d < l && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (r) {
      return (
        (!r || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(r),
        n.prototype.invalidate.call(this, r)
      );
    }),
    (t.resetTo = function (r, s, o, a, l) {
      Am || ls.wake(), this._ts || this.play();
      var u = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        c;
      return (
        this._initted || aC(this, u),
        (c = this._ease(u / this._dur)),
        NK(this, r, s, o, a, c, u, l)
          ? this.resetTo(r, s, o, a, 1)
          : (Lx(this, 0),
            this.parent ||
              $O(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (r, s) {
      if ((s === void 0 && (s = "all"), !r && (!s || s === "all")))
        return (
          (this._lazy = this._pt = 0),
          this.parent
            ? qd(this)
            : this.scrollTrigger && this.scrollTrigger.kill(!!Oi),
          this
        );
      if (this.timeline) {
        var o = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(r, s, _l && _l.vars.overwrite !== !0)
            ._first || qd(this),
          this.parent &&
            o !== this.timeline.totalDuration() &&
            Fh(this, (this._dur * this.timeline._tDur) / o, 0, 1),
          this
        );
      }
      var a = this._targets,
        l = r ? js(r) : a,
        u = this._ptLookup,
        c = this._pt,
        d,
        p,
        m,
        v,
        _,
        x,
        g;
      if ((!s || s === "all") && dK(a, l))
        return s === "all" && (this._pt = 0), qd(this);
      for (
        d = this._op = this._op || [],
          s !== "all" &&
            (Pi(s) &&
              ((_ = {}),
              Xr(s, function (A) {
                return (_[A] = 1);
              }),
              (s = _)),
            (s = OK(a, s))),
          g = a.length;
        g--;

      )
        if (~l.indexOf(a[g])) {
          (p = u[g]),
            s === "all"
              ? ((d[g] = s), (v = p), (m = {}))
              : ((m = d[g] = d[g] || {}), (v = s));
          for (_ in v)
            (x = p && p[_]),
              x &&
                ((!("kill" in x.d) || x.d.kill(_) === !0) && Ix(this, x, "_pt"),
                delete p[_]),
              m !== "all" && (m[_] = 1);
        }
      return this._initted && !this._pt && c && qd(this), this;
    }),
    (e.to = function (r, s) {
      return new e(r, s, arguments[2]);
    }),
    (e.from = function (r, s) {
      return Ep(1, arguments);
    }),
    (e.delayedCall = function (r, s, o, a) {
      return new e(s, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: r,
        onComplete: s,
        onReverseComplete: s,
        onCompleteParams: o,
        onReverseCompleteParams: o,
        callbackScope: a,
      });
    }),
    (e.fromTo = function (r, s, o) {
      return Ep(2, arguments);
    }),
    (e.set = function (r, s) {
      return (s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(r, s);
    }),
    (e.killTweensOf = function (r, s, o) {
      return Ln.killTweensOf(r, s, o);
    }),
    e
  );
})(Sm);
As(si.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
Xr("staggerTo,staggerFrom,staggerFromTo", function (n) {
  si[n] = function () {
    var e = new yr(),
      t = _w.call(arguments, 0);
    return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t);
  };
});
var lC = function (e, t, i) {
    return (e[t] = i);
  },
  SU = function (e, t, i) {
    return e[t](i);
  },
  kK = function (e, t, i, r) {
    return e[t](r.fp, i);
  },
  zK = function (e, t, i) {
    return e.setAttribute(t, i);
  },
  uC = function (e, t) {
    return Vn(e[t]) ? SU : qT(e[t]) && e.setAttribute ? zK : lC;
  },
  MU = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  HK = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  wU = function (e, t) {
    var i = t._pt,
      r = "";
    if (!e && t.b) r = t.b;
    else if (e === 1 && t.e) r = t.e;
    else {
      for (; i; )
        (r =
          i.p +
          (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) +
          r),
          (i = i._next);
      r += t.c;
    }
    t.set(t.t, t.p, r, t);
  },
  cC = function (e, t) {
    for (var i = t._pt; i; ) i.r(e, i.d), (i = i._next);
  },
  GK = function (e, t, i, r) {
    for (var s = this._pt, o; s; )
      (o = s._next), s.p === r && s.modifier(e, t, i), (s = o);
  },
  VK = function (e) {
    for (var t = this._pt, i, r; t; )
      (r = t._next),
        (t.p === e && !t.op) || t.op === e
          ? Ix(this, t, "_pt")
          : t.dep || (i = 1),
        (t = r);
    return !i;
  },
  WK = function (e, t, i, r) {
    r.mSet(e, t, r.m.call(r.tween, i, r.mt), r);
  },
  EU = function (e) {
    for (var t = e._pt, i, r, s, o; t; ) {
      for (i = t._next, r = s; r && r.pr > t.pr; ) r = r._next;
      (t._prev = r ? r._prev : o) ? (t._prev._next = t) : (s = t),
        (t._next = r) ? (r._prev = t) : (o = t),
        (t = i);
    }
    e._pt = s;
  },
  Jr = (function () {
    function n(t, i, r, s, o, a, l, u, c) {
      (this.t = i),
        (this.s = s),
        (this.c = o),
        (this.p = r),
        (this.r = a || MU),
        (this.d = l || this),
        (this.set = u || lC),
        (this.pr = c || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    var e = n.prototype;
    return (
      (e.modifier = function (i, r, s) {
        (this.mSet = this.mSet || this.set),
          (this.set = WK),
          (this.m = i),
          (this.mt = s),
          (this.tween = r);
      }),
      n
    );
  })();
Xr(
  iC +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (n) {
    return (nC[n] = 1);
  }
);
xs.TweenMax = xs.TweenLite = si;
xs.TimelineLite = xs.TimelineMax = yr;
Ln = new yr({
  sortChildren: !1,
  defaults: Ih,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
gs.stringFilter = pU;
var fc = [],
  Vv = {},
  XK = [],
  aI = 0,
  JK = 0,
  bS = function (e) {
    return (Vv[e] || XK).map(function (t) {
      return t();
    });
  },
  Mw = function () {
    var e = Date.now(),
      t = [];
    e - aI > 2 &&
      (bS("matchMediaInit"),
      fc.forEach(function (i) {
        var r = i.queries,
          s = i.conditions,
          o,
          a,
          l,
          u;
        for (a in r)
          (o = Fo.matchMedia(r[a]).matches),
            o && (l = 1),
            o !== s[a] && ((s[a] = o), (u = 1));
        u && (i.revert(), l && t.push(i));
      }),
      bS("matchMediaRevert"),
      t.forEach(function (i) {
        return i.onMatch(i, function (r) {
          return i.add(null, r);
        });
      }),
      (aI = e),
      bS("matchMedia"));
  },
  TU = (function () {
    function n(t, i) {
      (this.selector = i && xw(i)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = JK++),
        t && this.add(t);
    }
    var e = n.prototype;
    return (
      (e.add = function (i, r, s) {
        Vn(i) && ((s = r), (r = i), (i = Vn));
        var o = this,
          a = function () {
            var u = Rn,
              c = o.selector,
              d;
            return (
              u && u !== o && u.data.push(o),
              s && (o.selector = xw(s)),
              (Rn = o),
              (d = r.apply(o, arguments)),
              Vn(d) && o._r.push(d),
              (Rn = u),
              (o.selector = c),
              (o.isReverted = !1),
              d
            );
          };
        return (
          (o.last = a),
          i === Vn
            ? a(o, function (l) {
                return o.add(null, l);
              })
            : i
            ? (o[i] = a)
            : a
        );
      }),
      (e.ignore = function (i) {
        var r = Rn;
        (Rn = null), i(this), (Rn = r);
      }),
      (e.getTweens = function () {
        var i = [];
        return (
          this.data.forEach(function (r) {
            return r instanceof n
              ? i.push.apply(i, r.getTweens())
              : r instanceof si &&
                  !(r.parent && r.parent.data === "nested") &&
                  i.push(r);
          }),
          i
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (i, r) {
        var s = this;
        if (
          (i
            ? (function () {
                for (var a = s.getTweens(), l = s.data.length, u; l--; )
                  (u = s.data[l]),
                    u.data === "isFlip" &&
                      (u.revert(),
                      u.getChildren(!0, !0, !1).forEach(function (c) {
                        return a.splice(a.indexOf(c), 1);
                      }));
                for (
                  a
                    .map(function (c) {
                      return {
                        g:
                          c._dur ||
                          c._delay ||
                          (c._sat && !c._sat.vars.immediateRender)
                            ? c.globalTime(0)
                            : -1 / 0,
                        t: c,
                      };
                    })
                    .sort(function (c, d) {
                      return d.g - c.g || -1 / 0;
                    })
                    .forEach(function (c) {
                      return c.t.revert(i);
                    }),
                    l = s.data.length;
                  l--;

                )
                  (u = s.data[l]),
                    u instanceof yr
                      ? u.data !== "nested" &&
                        (u.scrollTrigger && u.scrollTrigger.revert(), u.kill())
                      : !(u instanceof si) && u.revert && u.revert(i);
                s._r.forEach(function (c) {
                  return c(i, s);
                }),
                  (s.isReverted = !0);
              })()
            : this.data.forEach(function (a) {
                return a.kill && a.kill();
              }),
          this.clear(),
          r)
        )
          for (var o = fc.length; o--; )
            fc[o].id === this.id && fc.splice(o, 1);
      }),
      (e.revert = function (i) {
        this.kill(i || {});
      }),
      n
    );
  })(),
  jK = (function () {
    function n(t) {
      (this.contexts = []), (this.scope = t), Rn && Rn.data.push(this);
    }
    var e = n.prototype;
    return (
      (e.add = function (i, r, s) {
        Qo(i) || (i = { matches: i });
        var o = new TU(0, s || this.scope),
          a = (o.conditions = {}),
          l,
          u,
          c;
        Rn && !o.selector && (o.selector = Rn.selector),
          this.contexts.push(o),
          (r = o.add("onMatch", r)),
          (o.queries = i);
        for (u in i)
          u === "all"
            ? (c = 1)
            : ((l = Fo.matchMedia(i[u])),
              l &&
                (fc.indexOf(o) < 0 && fc.push(o),
                (a[u] = l.matches) && (c = 1),
                l.addListener
                  ? l.addListener(Mw)
                  : l.addEventListener("change", Mw)));
        return (
          c &&
            r(o, function (d) {
              return o.add(null, d);
            }),
          this
        );
      }),
      (e.revert = function (i) {
        this.kill(i || {});
      }),
      (e.kill = function (i) {
        this.contexts.forEach(function (r) {
          return r.kill(i, !0);
        });
      }),
      n
    );
  })(),
  v_ = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      t.forEach(function (r) {
        return fU(r);
      });
    },
    timeline: function (e) {
      return new yr(e);
    },
    getTweensOf: function (e, t) {
      return Ln.getTweensOf(e, t);
    },
    getProperty: function (e, t, i, r) {
      Pi(e) && (e = js(e)[0]);
      var s = lc(e || {}).get,
        o = i ? qO : ZO;
      return (
        i === "native" && (i = ""),
        e &&
          (t
            ? o(((os[t] && os[t].get) || s)(e, t, i, r))
            : function (a, l, u) {
                return o(((os[a] && os[a].get) || s)(e, a, l, u));
              })
      );
    },
    quickSetter: function (e, t, i) {
      if (((e = js(e)), e.length > 1)) {
        var r = e.map(function (c) {
            return Yr.quickSetter(c, t, i);
          }),
          s = r.length;
        return function (c) {
          for (var d = s; d--; ) r[d](c);
        };
      }
      e = e[0] || {};
      var o = os[t],
        a = lc(e),
        l = (a.harness && (a.harness.aliases || {})[t]) || t,
        u = o
          ? function (c) {
              var d = new o();
              (Qf._pt = 0),
                d.init(e, i ? c + i : c, Qf, 0, [e]),
                d.render(1, d),
                Qf._pt && cC(1, Qf);
            }
          : a.set(e, l);
      return o
        ? u
        : function (c) {
            return u(e, l, i ? c + i : c, a, 1);
          };
    },
    quickTo: function (e, t, i) {
      var r,
        s = Yr.to(
          e,
          As(
            ((r = {}), (r[t] = "+=0.1"), (r.paused = !0), (r.stagger = 0), r),
            i || {}
          )
        ),
        o = function (l, u, c) {
          return s.resetTo(t, l, u, c);
        };
      return (o.tween = s), o;
    },
    isTweening: function (e) {
      return Ln.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return e && e.ease && (e.ease = cc(e.ease, Ih.ease)), nI(Ih, e || {});
    },
    config: function (e) {
      return nI(gs, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        i = e.effect,
        r = e.plugins,
        s = e.defaults,
        o = e.extendTimeline;
      (r || "").split(",").forEach(function (a) {
        return (
          a && !os[a] && !xs[a] && ym(t + " effect requires " + a + " plugin.")
        );
      }),
        (wS[t] = function (a, l, u) {
          return i(js(a), As(l || {}, s), u);
        }),
        o &&
          (yr.prototype[t] = function (a, l, u) {
            return this.add(wS[t](a, Qo(l) ? l : (u = l) && {}, this), u);
          });
    },
    registerEase: function (e, t) {
      Zt[e] = cc(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? cc(e, t) : Zt;
    },
    getById: function (e) {
      return Ln.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var i = new yr(e),
        r,
        s;
      for (
        i.smoothChildTiming = Wr(e.smoothChildTiming),
          Ln.remove(i),
          i._dp = 0,
          i._time = i._tTime = Ln._time,
          r = Ln._first;
        r;

      )
        (s = r._next),
          (t ||
            !(
              !r._dur &&
              r instanceof si &&
              r.vars.onComplete === r._targets[0]
            )) &&
            Uo(i, r, r._start - r._delay),
          (r = s);
      return Uo(Ln, i, 0), i;
    },
    context: function (e, t) {
      return e ? new TU(e, t) : Rn;
    },
    matchMedia: function (e) {
      return new jK(e);
    },
    matchMediaRefresh: function () {
      return (
        fc.forEach(function (e) {
          var t = e.conditions,
            i,
            r;
          for (r in t) t[r] && ((t[r] = !1), (i = 1));
          i && e.revert();
        }) || Mw()
      );
    },
    addEventListener: function (e, t) {
      var i = Vv[e] || (Vv[e] = []);
      ~i.indexOf(t) || i.push(t);
    },
    removeEventListener: function (e, t) {
      var i = Vv[e],
        r = i && i.indexOf(t);
      r >= 0 && i.splice(r, 1);
    },
    utils: {
      wrap: EK,
      wrapYoyo: TK,
      distribute: sU,
      random: aU,
      snap: oU,
      normalize: wK,
      getUnit: Zi,
      clamp: xK,
      splitColor: hU,
      toArray: js,
      selector: xw,
      mapRange: uU,
      pipe: SK,
      unitize: MK,
      interpolate: CK,
      shuffle: rU,
    },
    install: JO,
    effects: wS,
    ticker: ls,
    updateRoot: yr.updateRoot,
    plugins: os,
    globalTimeline: Ln,
    core: {
      PropTween: Jr,
      globals: jO,
      Tween: si,
      Timeline: yr,
      Animation: Sm,
      getCache: lc,
      _removeLinkedListItem: Ix,
      reverting: function () {
        return Oi;
      },
      context: function (e) {
        return e && Rn && (Rn.data.push(e), (e._ctx = Rn)), Rn;
      },
      suppressOverwrites: function (e) {
        return (ZT = e);
      },
    },
  };
Xr("to,from,fromTo,delayedCall,set,killTweensOf", function (n) {
  return (v_[n] = si[n]);
});
ls.add(yr.updateRoot);
Qf = v_.to({}, { duration: 0 });
var YK = function (e, t) {
    for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
      i = i._next;
    return i;
  },
  KK = function (e, t) {
    var i = e._targets,
      r,
      s,
      o;
    for (r in t)
      for (s = i.length; s--; )
        (o = e._ptLookup[s][r]),
          o &&
            (o = o.d) &&
            (o._pt && (o = YK(o, r)),
            o && o.modifier && o.modifier(t[r], e, i[s], r));
  },
  RS = function (e, t) {
    return {
      name: e,
      headless: 1,
      rawVars: 1,
      init: function (r, s, o) {
        o._onInit = function (a) {
          var l, u;
          if (
            (Pi(s) &&
              ((l = {}),
              Xr(s, function (c) {
                return (l[c] = 1);
              }),
              (s = l)),
            t)
          ) {
            l = {};
            for (u in s) l[u] = t(s[u]);
            s = l;
          }
          KK(a, s);
        };
      },
    };
  },
  Yr =
    v_.registerPlugin(
      {
        name: "attr",
        init: function (e, t, i, r, s) {
          var o, a, l;
          this.tween = i;
          for (o in t)
            (l = e.getAttribute(o) || ""),
              (a = this.add(
                e,
                "setAttribute",
                (l || 0) + "",
                t[o],
                r,
                s,
                0,
                0,
                o
              )),
              (a.op = o),
              (a.b = l),
              this._props.push(o);
        },
        render: function (e, t) {
          for (var i = t._pt; i; )
            Oi ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), (i = i._next);
        },
      },
      {
        name: "endArray",
        headless: 1,
        init: function (e, t) {
          for (var i = t.length; i--; )
            this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
        },
      },
      RS("roundProps", Aw),
      RS("modifiers"),
      RS("snap", oU)
    ) || v_;
si.version = yr.version = Yr.version = "3.13.0";
XO = 1;
$T() && Nh();
Zt.Power0;
Zt.Power1;
Zt.Power2;
Zt.Power3;
Zt.Power4;
Zt.Linear;
Zt.Quad;
Zt.Cubic;
Zt.Quart;
Zt.Quint;
Zt.Strong;
Zt.Elastic;
Zt.Back;
Zt.SteppedEase;
Zt.Bounce;
Zt.Sine;
Zt.Expo;
Zt.Circ;
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var lI,
  xl,
  hh,
  fC,
  Zu,
  uI,
  hC,
  QK = function () {
    return typeof window < "u";
  },
  Ga = {},
  Lu = 180 / Math.PI,
  dh = Math.PI / 180,
  wf = Math.atan2,
  cI = 1e8,
  dC = /([A-Z])/g,
  ZK = /(left|right|width|margin|padding|x)/i,
  qK = /[\s,\(]\S/,
  ko = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  ww = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  $K = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  eQ = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  tQ = function (e, t) {
    var i = t.s + t.c * e;
    t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  CU = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  bU = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  nQ = function (e, t, i) {
    return (e.style[t] = i);
  },
  iQ = function (e, t, i) {
    return e.style.setProperty(t, i);
  },
  rQ = function (e, t, i) {
    return (e._gsap[t] = i);
  },
  sQ = function (e, t, i) {
    return (e._gsap.scaleX = e._gsap.scaleY = i);
  },
  oQ = function (e, t, i, r, s) {
    var o = e._gsap;
    (o.scaleX = o.scaleY = i), o.renderTransform(s, o);
  },
  aQ = function (e, t, i, r, s) {
    var o = e._gsap;
    (o[t] = i), o.renderTransform(s, o);
  },
  Nn = "transform",
  jr = Nn + "Origin",
  lQ = function n(e, t) {
    var i = this,
      r = this.target,
      s = r.style,
      o = r._gsap;
    if (e in Ga && s) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        (e = ko[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (a) {
                return (i.tfm[a] = ga(r, a));
              })
            : (this.tfm[e] = o.x ? o[e] : ga(r, e)),
          e === jr && (this.tfm.zOrigin = o.zOrigin);
      else
        return ko.transform.split(",").forEach(function (a) {
          return n.call(i, a, t);
        });
      if (this.props.indexOf(Nn) >= 0) return;
      o.svg &&
        ((this.svgo = r.getAttribute("data-svg-origin")),
        this.props.push(jr, t, "")),
        (e = Nn);
    }
    (s || t) && this.props.push(e, t, s[e]);
  },
  RU = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"));
  },
  uQ = function () {
    var e = this.props,
      t = this.target,
      i = t.style,
      r = t._gsap,
      s,
      o;
    for (s = 0; s < e.length; s += 3)
      e[s + 1]
        ? e[s + 1] === 2
          ? t[e[s]](e[s + 2])
          : (t[e[s]] = e[s + 2])
        : e[s + 2]
        ? (i[e[s]] = e[s + 2])
        : i.removeProperty(
            e[s].substr(0, 2) === "--"
              ? e[s]
              : e[s].replace(dC, "-$1").toLowerCase()
          );
    if (this.tfm) {
      for (o in this.tfm) r[o] = this.tfm[o];
      r.svg &&
        (r.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        (s = hC()),
        (!s || !s.isStart) &&
          !i[Nn] &&
          (RU(i),
          r.zOrigin &&
            i[jr] &&
            ((i[jr] += " " + r.zOrigin + "px"),
            (r.zOrigin = 0),
            r.renderTransform()),
          (r.uncache = 1));
    }
  },
  PU = function (e, t) {
    var i = { target: e, props: [], revert: uQ, save: lQ };
    return (
      e._gsap || Yr.core.getCache(e),
      t &&
        e.style &&
        e.nodeType &&
        t.split(",").forEach(function (r) {
          return i.save(r);
        }),
      i
    );
  },
  BU,
  Ew = function (e, t) {
    var i = xl.createElementNS
      ? xl.createElementNS(
          (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : xl.createElement(e);
    return i && i.style ? i : xl.createElement(e);
  },
  Ys = function n(e, t, i) {
    var r = getComputedStyle(e);
    return (
      r[t] ||
      r.getPropertyValue(t.replace(dC, "-$1").toLowerCase()) ||
      r.getPropertyValue(t) ||
      (!i && n(e, Oh(t) || t, 1)) ||
      ""
    );
  },
  fI = "O,Moz,ms,Ms,Webkit".split(","),
  Oh = function (e, t, i) {
    var r = t || Zu,
      s = r.style,
      o = 5;
    if (e in s && !i) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      o-- && !(fI[o] + e in s);

    );
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? fI[o] : "") + e;
  },
  Tw = function () {
    QK() &&
      window.document &&
      ((lI = window),
      (xl = lI.document),
      (hh = xl.documentElement),
      (Zu = Ew("div") || { style: {} }),
      Ew("div"),
      (Nn = Oh(Nn)),
      (jr = Nn + "Origin"),
      (Zu.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (BU = !!Oh("perspective")),
      (hC = Yr.core.reverting),
      (fC = 1));
  },
  hI = function (e) {
    var t = e.ownerSVGElement,
      i = Ew(
        "svg",
        (t && t.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"
      ),
      r = e.cloneNode(!0),
      s;
    (r.style.display = "block"), i.appendChild(r), hh.appendChild(i);
    try {
      s = r.getBBox();
    } catch {}
    return i.removeChild(r), hh.removeChild(i), s;
  },
  dI = function (e, t) {
    for (var i = t.length; i--; )
      if (e.hasAttribute(t[i])) return e.getAttribute(t[i]);
  },
  IU = function (e) {
    var t, i;
    try {
      t = e.getBBox();
    } catch {
      (t = hI(e)), (i = 1);
    }
    return (
      (t && (t.width || t.height)) || i || (t = hI(e)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +dI(e, ["x", "cx", "x1"]) || 0,
            y: +dI(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  DU = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && IU(e));
  },
  Rc = function (e, t) {
    if (t) {
      var i = e.style,
        r;
      t in Ga && t !== jr && (t = Nn),
        i.removeProperty
          ? ((r = t.substr(0, 2)),
            (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
            i.removeProperty(
              r === "--" ? t : t.replace(dC, "-$1").toLowerCase()
            ))
          : i.removeAttribute(t);
    }
  },
  Al = function (e, t, i, r, s, o) {
    var a = new Jr(e._pt, t, i, 0, 1, o ? bU : CU);
    return (e._pt = a), (a.b = r), (a.e = s), e._props.push(i), a;
  },
  pI = { deg: 1, rad: 1, turn: 1 },
  cQ = { grid: 1, flex: 1 },
  Vl = function n(e, t, i, r) {
    var s = parseFloat(i) || 0,
      o = (i + "").trim().substr((s + "").length) || "px",
      a = Zu.style,
      l = ZK.test(t),
      u = e.tagName.toLowerCase() === "svg",
      c = (u ? "client" : "offset") + (l ? "Width" : "Height"),
      d = 100,
      p = r === "px",
      m = r === "%",
      v,
      _,
      x,
      g;
    if (r === o || !s || pI[r] || pI[o]) return s;
    if (
      (o !== "px" && !p && (s = n(e, t, i, "px")),
      (g = e.getCTM && DU(e)),
      (m || o === "%") && (Ga[t] || ~t.indexOf("adius")))
    )
      return (
        (v = g ? e.getBBox()[l ? "width" : "height"] : e[c]),
        Kn(m ? (s / v) * d : (s / 100) * v)
      );
    if (
      ((a[l ? "width" : "height"] = d + (p ? o : r)),
      (_ =
        (r !== "rem" && ~t.indexOf("adius")) ||
        (r === "em" && e.appendChild && !u)
          ? e
          : e.parentNode),
      g && (_ = (e.ownerSVGElement || {}).parentNode),
      (!_ || _ === xl || !_.appendChild) && (_ = xl.body),
      (x = _._gsap),
      x && m && x.width && l && x.time === ls.time && !x.uncache)
    )
      return Kn((s / x.width) * d);
    if (m && (t === "height" || t === "width")) {
      var A = e.style[t];
      (e.style[t] = d + r), (v = e[c]), A ? (e.style[t] = A) : Rc(e, t);
    } else
      (m || o === "%") &&
        !cQ[Ys(_, "display")] &&
        (a.position = Ys(e, "position")),
        _ === e && (a.position = "static"),
        _.appendChild(Zu),
        (v = Zu[c]),
        _.removeChild(Zu),
        (a.position = "absolute");
    return (
      l && m && ((x = lc(_)), (x.time = ls.time), (x.width = _[c])),
      Kn(p ? (v * s) / d : v && s ? (d / v) * s : 0)
    );
  },
  ga = function (e, t, i, r) {
    var s;
    return (
      fC || Tw(),
      t in ko &&
        t !== "transform" &&
        ((t = ko[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
      Ga[t] && t !== "transform"
        ? ((s = wm(e, r)),
          (s =
            t !== "transformOrigin"
              ? s[t]
              : s.svg
              ? s.origin
              : __(Ys(e, jr)) + " " + s.zOrigin + "px"))
        : ((s = e.style[t]),
          (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) &&
            (s =
              (y_[t] && y_[t](e, t, i)) ||
              Ys(e, t) ||
              KO(e, t) ||
              (t === "opacity" ? 1 : 0))),
      i && !~(s + "").trim().indexOf(" ") ? Vl(e, t, s, i) + i : s
    );
  },
  fQ = function (e, t, i, r) {
    if (!i || i === "none") {
      var s = Oh(t, e, 1),
        o = s && Ys(e, s, 1);
      o && o !== i
        ? ((t = s), (i = o))
        : t === "borderColor" && (i = Ys(e, "borderTopColor"));
    }
    var a = new Jr(this._pt, e.style, t, 0, 1, wU),
      l = 0,
      u = 0,
      c,
      d,
      p,
      m,
      v,
      _,
      x,
      g,
      A,
      S,
      w,
      C;
    if (
      ((a.b = i),
      (a.e = r),
      (i += ""),
      (r += ""),
      r.substring(0, 6) === "var(--" &&
        (r = Ys(e, r.substring(4, r.indexOf(")")))),
      r === "auto" &&
        ((_ = e.style[t]),
        (e.style[t] = r),
        (r = Ys(e, t) || r),
        _ ? (e.style[t] = _) : Rc(e, t)),
      (c = [i, r]),
      pU(c),
      (i = c[0]),
      (r = c[1]),
      (p = i.match(Kf) || []),
      (C = r.match(Kf) || []),
      C.length)
    ) {
      for (; (d = Kf.exec(r)); )
        (x = d[0]),
          (A = r.substring(l, d.index)),
          v
            ? (v = (v + 1) % 5)
            : (A.substr(-5) === "rgba(" || A.substr(-5) === "hsla(") && (v = 1),
          x !== (_ = p[u++] || "") &&
            ((m = parseFloat(_) || 0),
            (w = _.substr((m + "").length)),
            x.charAt(1) === "=" && (x = fh(m, x) + w),
            (g = parseFloat(x)),
            (S = x.substr((g + "").length)),
            (l = Kf.lastIndex - S.length),
            S ||
              ((S = S || gs.units[t] || w),
              l === r.length && ((r += S), (a.e += S))),
            w !== S && (m = Vl(e, t, _, S) || 0),
            (a._pt = {
              _next: a._pt,
              p: A || u === 1 ? A : ",",
              s: m,
              c: g - m,
              m: (v && v < 4) || t === "zIndex" ? Math.round : 0,
            }));
      a.c = l < r.length ? r.substring(l, r.length) : "";
    } else a.r = t === "display" && r === "none" ? bU : CU;
    return VO.test(r) && (a.e = 0), (this._pt = a), a;
  },
  mI = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  hQ = function (e) {
    var t = e.split(" "),
      i = t[0],
      r = t[1] || "50%";
    return (
      (i === "top" || i === "bottom" || r === "left" || r === "right") &&
        ((e = i), (i = r), (r = e)),
      (t[0] = mI[i] || i),
      (t[1] = mI[r] || r),
      t.join(" ")
    );
  },
  dQ = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var i = t.t,
        r = i.style,
        s = t.u,
        o = i._gsap,
        a,
        l,
        u;
      if (s === "all" || s === !0) (r.cssText = ""), (l = 1);
      else
        for (s = s.split(","), u = s.length; --u > -1; )
          (a = s[u]),
            Ga[a] && ((l = 1), (a = a === "transformOrigin" ? jr : Nn)),
            Rc(i, a);
      l &&
        (Rc(i, Nn),
        o &&
          (o.svg && i.removeAttribute("transform"),
          (r.scale = r.rotate = r.translate = "none"),
          wm(i, 1),
          (o.uncache = 1),
          RU(r)));
    }
  },
  y_ = {
    clearProps: function (e, t, i, r, s) {
      if (s.data !== "isFromStart") {
        var o = (e._pt = new Jr(e._pt, t, i, 0, 0, dQ));
        return (o.u = r), (o.pr = -10), (o.tween = s), e._props.push(i), 1;
      }
    },
  },
  Mm = [1, 0, 0, 1, 0, 0],
  LU = {},
  FU = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  gI = function (e) {
    var t = Ys(e, Nn);
    return FU(t) ? Mm : t.substr(7).match(GO).map(Kn);
  },
  pC = function (e, t) {
    var i = e._gsap || lc(e),
      r = e.style,
      s = gI(e),
      o,
      a,
      l,
      u;
    return i.svg && e.getAttribute("transform")
      ? ((l = e.transform.baseVal.consolidate().matrix),
        (s = [l.a, l.b, l.c, l.d, l.e, l.f]),
        s.join(",") === "1,0,0,1,0,0" ? Mm : s)
      : (s === Mm &&
          !e.offsetParent &&
          e !== hh &&
          !i.svg &&
          ((l = r.display),
          (r.display = "block"),
          (o = e.parentNode),
          (!o || (!e.offsetParent && !e.getBoundingClientRect().width)) &&
            ((u = 1), (a = e.nextElementSibling), hh.appendChild(e)),
          (s = gI(e)),
          l ? (r.display = l) : Rc(e, "display"),
          u &&
            (a
              ? o.insertBefore(e, a)
              : o
              ? o.appendChild(e)
              : hh.removeChild(e))),
        t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
  },
  Cw = function (e, t, i, r, s, o) {
    var a = e._gsap,
      l = s || pC(e, !0),
      u = a.xOrigin || 0,
      c = a.yOrigin || 0,
      d = a.xOffset || 0,
      p = a.yOffset || 0,
      m = l[0],
      v = l[1],
      _ = l[2],
      x = l[3],
      g = l[4],
      A = l[5],
      S = t.split(" "),
      w = parseFloat(S[0]) || 0,
      C = parseFloat(S[1]) || 0,
      b,
      P,
      I,
      R;
    i
      ? l !== Mm &&
        (P = m * x - v * _) &&
        ((I = w * (x / P) + C * (-_ / P) + (_ * A - x * g) / P),
        (R = w * (-v / P) + C * (m / P) - (m * A - v * g) / P),
        (w = I),
        (C = R))
      : ((b = IU(e)),
        (w = b.x + (~S[0].indexOf("%") ? (w / 100) * b.width : w)),
        (C = b.y + (~(S[1] || S[0]).indexOf("%") ? (C / 100) * b.height : C))),
      r || (r !== !1 && a.smooth)
        ? ((g = w - u),
          (A = C - c),
          (a.xOffset = d + (g * m + A * _) - g),
          (a.yOffset = p + (g * v + A * x) - A))
        : (a.xOffset = a.yOffset = 0),
      (a.xOrigin = w),
      (a.yOrigin = C),
      (a.smooth = !!r),
      (a.origin = t),
      (a.originIsAbsolute = !!i),
      (e.style[jr] = "0px 0px"),
      o &&
        (Al(o, a, "xOrigin", u, w),
        Al(o, a, "yOrigin", c, C),
        Al(o, a, "xOffset", d, a.xOffset),
        Al(o, a, "yOffset", p, a.yOffset)),
      e.setAttribute("data-svg-origin", w + " " + C);
  },
  wm = function (e, t) {
    var i = e._gsap || new yU(e);
    if ("x" in i && !t && !i.uncache) return i;
    var r = e.style,
      s = i.scaleX < 0,
      o = "px",
      a = "deg",
      l = getComputedStyle(e),
      u = Ys(e, jr) || "0",
      c,
      d,
      p,
      m,
      v,
      _,
      x,
      g,
      A,
      S,
      w,
      C,
      b,
      P,
      I,
      R,
      T,
      D,
      G,
      W,
      q,
      Z,
      K,
      te,
      O,
      Y,
      F,
      se,
      Me,
      De,
      re,
      xe;
    return (
      (c = d = p = _ = x = g = A = S = w = 0),
      (m = v = 1),
      (i.svg = !!(e.getCTM && DU(e))),
      l.translate &&
        ((l.translate !== "none" ||
          l.scale !== "none" ||
          l.rotate !== "none") &&
          (r[Nn] =
            (l.translate !== "none"
              ? "translate3d(" +
                (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") +
            (l.scale !== "none"
              ? "scale(" + l.scale.split(" ").join(",") + ") "
              : "") +
            (l[Nn] !== "none" ? l[Nn] : "")),
        (r.scale = r.rotate = r.translate = "none")),
      (P = pC(e, i.svg)),
      i.svg &&
        (i.uncache
          ? ((O = e.getBBox()),
            (u = i.xOrigin - O.x + "px " + (i.yOrigin - O.y) + "px"),
            (te = ""))
          : (te = !t && e.getAttribute("data-svg-origin")),
        Cw(e, te || u, !!te || i.originIsAbsolute, i.smooth !== !1, P)),
      (C = i.xOrigin || 0),
      (b = i.yOrigin || 0),
      P !== Mm &&
        ((D = P[0]),
        (G = P[1]),
        (W = P[2]),
        (q = P[3]),
        (c = Z = P[4]),
        (d = K = P[5]),
        P.length === 6
          ? ((m = Math.sqrt(D * D + G * G)),
            (v = Math.sqrt(q * q + W * W)),
            (_ = D || G ? wf(G, D) * Lu : 0),
            (A = W || q ? wf(W, q) * Lu + _ : 0),
            A && (v *= Math.abs(Math.cos(A * dh))),
            i.svg && ((c -= C - (C * D + b * W)), (d -= b - (C * G + b * q))))
          : ((xe = P[6]),
            (De = P[7]),
            (F = P[8]),
            (se = P[9]),
            (Me = P[10]),
            (re = P[11]),
            (c = P[12]),
            (d = P[13]),
            (p = P[14]),
            (I = wf(xe, Me)),
            (x = I * Lu),
            I &&
              ((R = Math.cos(-I)),
              (T = Math.sin(-I)),
              (te = Z * R + F * T),
              (O = K * R + se * T),
              (Y = xe * R + Me * T),
              (F = Z * -T + F * R),
              (se = K * -T + se * R),
              (Me = xe * -T + Me * R),
              (re = De * -T + re * R),
              (Z = te),
              (K = O),
              (xe = Y)),
            (I = wf(-W, Me)),
            (g = I * Lu),
            I &&
              ((R = Math.cos(-I)),
              (T = Math.sin(-I)),
              (te = D * R - F * T),
              (O = G * R - se * T),
              (Y = W * R - Me * T),
              (re = q * T + re * R),
              (D = te),
              (G = O),
              (W = Y)),
            (I = wf(G, D)),
            (_ = I * Lu),
            I &&
              ((R = Math.cos(I)),
              (T = Math.sin(I)),
              (te = D * R + G * T),
              (O = Z * R + K * T),
              (G = G * R - D * T),
              (K = K * R - Z * T),
              (D = te),
              (Z = O)),
            x &&
              Math.abs(x) + Math.abs(_) > 359.9 &&
              ((x = _ = 0), (g = 180 - g)),
            (m = Kn(Math.sqrt(D * D + G * G + W * W))),
            (v = Kn(Math.sqrt(K * K + xe * xe))),
            (I = wf(Z, K)),
            (A = Math.abs(I) > 2e-4 ? I * Lu : 0),
            (w = re ? 1 / (re < 0 ? -re : re) : 0)),
        i.svg &&
          ((te = e.getAttribute("transform")),
          (i.forceCSS = e.setAttribute("transform", "") || !FU(Ys(e, Nn))),
          te && e.setAttribute("transform", te))),
      Math.abs(A) > 90 &&
        Math.abs(A) < 270 &&
        (s
          ? ((m *= -1), (A += _ <= 0 ? 180 : -180), (_ += _ <= 0 ? 180 : -180))
          : ((v *= -1), (A += A <= 0 ? 180 : -180))),
      (t = t || i.uncache),
      (i.x =
        c -
        ((i.xPercent =
          c &&
          ((!t && i.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-c) ? -50 : 0)))
          ? (e.offsetWidth * i.xPercent) / 100
          : 0) +
        o),
      (i.y =
        d -
        ((i.yPercent =
          d &&
          ((!t && i.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0)))
          ? (e.offsetHeight * i.yPercent) / 100
          : 0) +
        o),
      (i.z = p + o),
      (i.scaleX = Kn(m)),
      (i.scaleY = Kn(v)),
      (i.rotation = Kn(_) + a),
      (i.rotationX = Kn(x) + a),
      (i.rotationY = Kn(g) + a),
      (i.skewX = A + a),
      (i.skewY = S + a),
      (i.transformPerspective = w + o),
      (i.zOrigin = parseFloat(u.split(" ")[2]) || (!t && i.zOrigin) || 0) &&
        (r[jr] = __(u)),
      (i.xOffset = i.yOffset = 0),
      (i.force3D = gs.force3D),
      (i.renderTransform = i.svg ? mQ : BU ? NU : pQ),
      (i.uncache = 0),
      i
    );
  },
  __ = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  PS = function (e, t, i) {
    var r = Zi(t);
    return Kn(parseFloat(t) + parseFloat(Vl(e, "x", i + "px", r))) + r;
  },
  pQ = function (e, t) {
    (t.z = "0px"),
      (t.rotationY = t.rotationX = "0deg"),
      (t.force3D = 0),
      NU(e, t);
  },
  Eu = "0deg",
  Hd = "0px",
  Tu = ") ",
  NU = function (e, t) {
    var i = t || this,
      r = i.xPercent,
      s = i.yPercent,
      o = i.x,
      a = i.y,
      l = i.z,
      u = i.rotation,
      c = i.rotationY,
      d = i.rotationX,
      p = i.skewX,
      m = i.skewY,
      v = i.scaleX,
      _ = i.scaleY,
      x = i.transformPerspective,
      g = i.force3D,
      A = i.target,
      S = i.zOrigin,
      w = "",
      C = (g === "auto" && e && e !== 1) || g === !0;
    if (S && (d !== Eu || c !== Eu)) {
      var b = parseFloat(c) * dh,
        P = Math.sin(b),
        I = Math.cos(b),
        R;
      (b = parseFloat(d) * dh),
        (R = Math.cos(b)),
        (o = PS(A, o, P * R * -S)),
        (a = PS(A, a, -Math.sin(b) * -S)),
        (l = PS(A, l, I * R * -S + S));
    }
    x !== Hd && (w += "perspective(" + x + Tu),
      (r || s) && (w += "translate(" + r + "%, " + s + "%) "),
      (C || o !== Hd || a !== Hd || l !== Hd) &&
        (w +=
          l !== Hd || C
            ? "translate3d(" + o + ", " + a + ", " + l + ") "
            : "translate(" + o + ", " + a + Tu),
      u !== Eu && (w += "rotate(" + u + Tu),
      c !== Eu && (w += "rotateY(" + c + Tu),
      d !== Eu && (w += "rotateX(" + d + Tu),
      (p !== Eu || m !== Eu) && (w += "skew(" + p + ", " + m + Tu),
      (v !== 1 || _ !== 1) && (w += "scale(" + v + ", " + _ + Tu),
      (A.style[Nn] = w || "translate(0, 0)");
  },
  mQ = function (e, t) {
    var i = t || this,
      r = i.xPercent,
      s = i.yPercent,
      o = i.x,
      a = i.y,
      l = i.rotation,
      u = i.skewX,
      c = i.skewY,
      d = i.scaleX,
      p = i.scaleY,
      m = i.target,
      v = i.xOrigin,
      _ = i.yOrigin,
      x = i.xOffset,
      g = i.yOffset,
      A = i.forceCSS,
      S = parseFloat(o),
      w = parseFloat(a),
      C,
      b,
      P,
      I,
      R;
    (l = parseFloat(l)),
      (u = parseFloat(u)),
      (c = parseFloat(c)),
      c && ((c = parseFloat(c)), (u += c), (l += c)),
      l || u
        ? ((l *= dh),
          (u *= dh),
          (C = Math.cos(l) * d),
          (b = Math.sin(l) * d),
          (P = Math.sin(l - u) * -p),
          (I = Math.cos(l - u) * p),
          u &&
            ((c *= dh),
            (R = Math.tan(u - c)),
            (R = Math.sqrt(1 + R * R)),
            (P *= R),
            (I *= R),
            c &&
              ((R = Math.tan(c)),
              (R = Math.sqrt(1 + R * R)),
              (C *= R),
              (b *= R))),
          (C = Kn(C)),
          (b = Kn(b)),
          (P = Kn(P)),
          (I = Kn(I)))
        : ((C = d), (I = p), (b = P = 0)),
      ((S && !~(o + "").indexOf("px")) || (w && !~(a + "").indexOf("px"))) &&
        ((S = Vl(m, "x", o, "px")), (w = Vl(m, "y", a, "px"))),
      (v || _ || x || g) &&
        ((S = Kn(S + v - (v * C + _ * P) + x)),
        (w = Kn(w + _ - (v * b + _ * I) + g))),
      (r || s) &&
        ((R = m.getBBox()),
        (S = Kn(S + (r / 100) * R.width)),
        (w = Kn(w + (s / 100) * R.height))),
      (R =
        "matrix(" + C + "," + b + "," + P + "," + I + "," + S + "," + w + ")"),
      m.setAttribute("transform", R),
      A && (m.style[Nn] = R);
  },
  gQ = function (e, t, i, r, s) {
    var o = 360,
      a = Pi(s),
      l = parseFloat(s) * (a && ~s.indexOf("rad") ? Lu : 1),
      u = l - r,
      c = r + u + "deg",
      d,
      p;
    return (
      a &&
        ((d = s.split("_")[1]),
        d === "short" && ((u %= o), u !== u % (o / 2) && (u += u < 0 ? o : -o)),
        d === "cw" && u < 0
          ? (u = ((u + o * cI) % o) - ~~(u / o) * o)
          : d === "ccw" && u > 0 && (u = ((u - o * cI) % o) - ~~(u / o) * o)),
      (e._pt = p = new Jr(e._pt, t, i, r, u, $K)),
      (p.e = c),
      (p.u = "deg"),
      e._props.push(i),
      p
    );
  },
  vI = function (e, t) {
    for (var i in t) e[i] = t[i];
    return e;
  },
  vQ = function (e, t, i) {
    var r = vI({}, i._gsap),
      s = "perspective,force3D,transformOrigin,svgOrigin",
      o = i.style,
      a,
      l,
      u,
      c,
      d,
      p,
      m,
      v;
    r.svg
      ? ((u = i.getAttribute("transform")),
        i.setAttribute("transform", ""),
        (o[Nn] = t),
        (a = wm(i, 1)),
        Rc(i, Nn),
        i.setAttribute("transform", u))
      : ((u = getComputedStyle(i)[Nn]),
        (o[Nn] = t),
        (a = wm(i, 1)),
        (o[Nn] = u));
    for (l in Ga)
      (u = r[l]),
        (c = a[l]),
        u !== c &&
          s.indexOf(l) < 0 &&
          ((m = Zi(u)),
          (v = Zi(c)),
          (d = m !== v ? Vl(i, l, u, v) : parseFloat(u)),
          (p = parseFloat(c)),
          (e._pt = new Jr(e._pt, a, l, d, p - d, ww)),
          (e._pt.u = v || 0),
          e._props.push(l));
    vI(a, r);
  };
Xr("padding,margin,Width,Radius", function (n, e) {
  var t = "Top",
    i = "Right",
    r = "Bottom",
    s = "Left",
    o = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function (a) {
      return e < 2 ? n + a : "border" + a + n;
    });
  y_[e > 1 ? "border" + n : n] = function (a, l, u, c, d) {
    var p, m;
    if (arguments.length < 4)
      return (
        (p = o.map(function (v) {
          return ga(a, v, u);
        })),
        (m = p.join(" ")),
        m.split(p[0]).length === 5 ? p[0] : m
      );
    (p = (c + "").split(" ")),
      (m = {}),
      o.forEach(function (v, _) {
        return (m[v] = p[_] = p[_] || p[((_ - 1) / 2) | 0]);
      }),
      a.init(l, m, d);
  };
});
var OU = {
  name: "css",
  register: Tw,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, i, r, s) {
    var o = this._props,
      a = e.style,
      l = i.vars.startAt,
      u,
      c,
      d,
      p,
      m,
      v,
      _,
      x,
      g,
      A,
      S,
      w,
      C,
      b,
      P,
      I;
    fC || Tw(),
      (this.styles = this.styles || PU(e)),
      (I = this.styles.props),
      (this.tween = i);
    for (_ in t)
      if (_ !== "autoRound" && ((c = t[_]), !(os[_] && _U(_, t, i, r, e, s)))) {
        if (
          ((m = typeof c),
          (v = y_[_]),
          m === "function" && ((c = c.call(i, r, e, s)), (m = typeof c)),
          m === "string" && ~c.indexOf("random(") && (c = xm(c)),
          v)
        )
          v(this, e, _, c, i) && (P = 1);
        else if (_.substr(0, 2) === "--")
          (u = (getComputedStyle(e).getPropertyValue(_) + "").trim()),
            (c += ""),
            (Ll.lastIndex = 0),
            Ll.test(u) || ((x = Zi(u)), (g = Zi(c))),
            g ? x !== g && (u = Vl(e, _, u, g) + g) : x && (c += x),
            this.add(a, "setProperty", u, c, r, s, 0, 0, _),
            o.push(_),
            I.push(_, 0, a[_]);
        else if (m !== "undefined") {
          if (
            (l && _ in l
              ? ((u = typeof l[_] == "function" ? l[_].call(i, r, e, s) : l[_]),
                Pi(u) && ~u.indexOf("random(") && (u = xm(u)),
                Zi(u + "") ||
                  u === "auto" ||
                  (u += gs.units[_] || Zi(ga(e, _)) || ""),
                (u + "").charAt(1) === "=" && (u = ga(e, _)))
              : (u = ga(e, _)),
            (p = parseFloat(u)),
            (A = m === "string" && c.charAt(1) === "=" && c.substr(0, 2)),
            A && (c = c.substr(2)),
            (d = parseFloat(c)),
            _ in ko &&
              (_ === "autoAlpha" &&
                (p === 1 && ga(e, "visibility") === "hidden" && d && (p = 0),
                I.push("visibility", 0, a.visibility),
                Al(
                  this,
                  a,
                  "visibility",
                  p ? "inherit" : "hidden",
                  d ? "inherit" : "hidden",
                  !d
                )),
              _ !== "scale" &&
                _ !== "transform" &&
                ((_ = ko[_]), ~_.indexOf(",") && (_ = _.split(",")[0]))),
            (S = _ in Ga),
            S)
          ) {
            if (
              (this.styles.save(_),
              m === "string" &&
                c.substring(0, 6) === "var(--" &&
                ((c = Ys(e, c.substring(4, c.indexOf(")")))),
                (d = parseFloat(c))),
              w ||
                ((C = e._gsap),
                (C.renderTransform && !t.parseTransform) ||
                  wm(e, t.parseTransform),
                (b = t.smoothOrigin !== !1 && C.smooth),
                (w = this._pt =
                  new Jr(this._pt, a, Nn, 0, 1, C.renderTransform, C, 0, -1)),
                (w.dep = 1)),
              _ === "scale")
            )
              (this._pt = new Jr(
                this._pt,
                C,
                "scaleY",
                C.scaleY,
                (A ? fh(C.scaleY, A + d) : d) - C.scaleY || 0,
                ww
              )),
                (this._pt.u = 0),
                o.push("scaleY", _),
                (_ += "X");
            else if (_ === "transformOrigin") {
              I.push(jr, 0, a[jr]),
                (c = hQ(c)),
                C.svg
                  ? Cw(e, c, 0, b, 0, this)
                  : ((g = parseFloat(c.split(" ")[2]) || 0),
                    g !== C.zOrigin && Al(this, C, "zOrigin", C.zOrigin, g),
                    Al(this, a, _, __(u), __(c)));
              continue;
            } else if (_ === "svgOrigin") {
              Cw(e, c, 1, b, 0, this);
              continue;
            } else if (_ in LU) {
              gQ(this, C, _, p, A ? fh(p, A + c) : c);
              continue;
            } else if (_ === "smoothOrigin") {
              Al(this, C, "smooth", C.smooth, c);
              continue;
            } else if (_ === "force3D") {
              C[_] = c;
              continue;
            } else if (_ === "transform") {
              vQ(this, c, e);
              continue;
            }
          } else _ in a || (_ = Oh(_) || _);
          if (S || ((d || d === 0) && (p || p === 0) && !qK.test(c) && _ in a))
            (x = (u + "").substr((p + "").length)),
              d || (d = 0),
              (g = Zi(c) || (_ in gs.units ? gs.units[_] : x)),
              x !== g && (p = Vl(e, _, u, g)),
              (this._pt = new Jr(
                this._pt,
                S ? C : a,
                _,
                p,
                (A ? fh(p, A + d) : d) - p,
                !S && (g === "px" || _ === "zIndex") && t.autoRound !== !1
                  ? tQ
                  : ww
              )),
              (this._pt.u = g || 0),
              x !== g && g !== "%" && ((this._pt.b = u), (this._pt.r = eQ));
          else if (_ in a) fQ.call(this, e, _, u, A ? A + c : c);
          else if (_ in e) this.add(e, _, u || e[_], A ? A + c : c, r, s);
          else if (_ !== "parseTransform") {
            tC(_, c);
            continue;
          }
          S ||
            (_ in a
              ? I.push(_, 0, a[_])
              : typeof e[_] == "function"
              ? I.push(_, 2, e[_]())
              : I.push(_, 1, u || e[_])),
            o.push(_);
        }
      }
    P && EU(this);
  },
  render: function (e, t) {
    if (t.tween._time || !hC())
      for (var i = t._pt; i; ) i.r(e, i.d), (i = i._next);
    else t.styles.revert();
  },
  get: ga,
  aliases: ko,
  getSetter: function (e, t, i) {
    var r = ko[t];
    return (
      r && r.indexOf(",") < 0 && (t = r),
      t in Ga && t !== jr && (e._gsap.x || ga(e, "x"))
        ? i && uI === i
          ? t === "scale"
            ? sQ
            : rQ
          : (uI = i || {}) && (t === "scale" ? oQ : aQ)
        : e.style && !qT(e.style[t])
        ? nQ
        : ~t.indexOf("-")
        ? iQ
        : uC(e, t)
    );
  },
  core: { _removeProperty: Rc, _getMatrix: pC },
};
Yr.utils.checkPrefix = Oh;
Yr.core.getStyleSaver = PU;
(function (n, e, t, i) {
  var r = Xr(n + "," + e + "," + t, function (s) {
    Ga[s] = 1;
  });
  Xr(e, function (s) {
    (gs.units[s] = "deg"), (LU[s] = 1);
  }),
    (ko[r[13]] = n + "," + e),
    Xr(i, function (s) {
      var o = s.split(":");
      ko[o[1]] = r[o[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
Xr(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (n) {
    gs.units[n] = "px";
  }
);
Yr.registerPlugin(OU);
var Hc = Yr.registerPlugin(OU) || Yr;
Hc.core.Tween;
function yI(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    (i.enumerable = i.enumerable || !1),
      (i.configurable = !0),
      "value" in i && (i.writable = !0),
      Object.defineProperty(n, i.key, i);
  }
}
function yQ(n, e, t) {
  return e && yI(n.prototype, e), t && yI(n, t), n;
}
/*!
 * Observer 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var Li,
  Wv,
  us,
  Sl,
  Ml,
  ph,
  UU,
  Fu,
  Cp,
  kU,
  wa,
  ao,
  zU,
  HU = function () {
    return (
      Li ||
      (typeof window < "u" && (Li = window.gsap) && Li.registerPlugin && Li)
    );
  },
  GU = 1,
  Zf = [],
  Wt = [],
  Jo = [],
  bp = Date.now,
  bw = function (e, t) {
    return t;
  },
  _Q = function () {
    var e = Cp.core,
      t = e.bridge || {},
      i = e._scrollers,
      r = e._proxies;
    i.push.apply(i, Wt),
      r.push.apply(r, Jo),
      (Wt = i),
      (Jo = r),
      (bw = function (o, a) {
        return t[o](a);
      });
  },
  Fl = function (e, t) {
    return ~Jo.indexOf(e) && Jo[Jo.indexOf(e) + 1][t];
  },
  Rp = function (e) {
    return !!~kU.indexOf(e);
  },
  cr = function (e, t, i, r, s) {
    return e.addEventListener(t, i, { passive: r !== !1, capture: !!s });
  },
  ur = function (e, t, i, r) {
    return e.removeEventListener(t, i, !!r);
  },
  fv = "scrollLeft",
  hv = "scrollTop",
  Rw = function () {
    return (wa && wa.isPressed) || Wt.cache++;
  },
  x_ = function (e, t) {
    var i = function r(s) {
      if (s || s === 0) {
        GU && (us.history.scrollRestoration = "manual");
        var o = wa && wa.isPressed;
        (s = r.v = Math.round(s) || (wa && wa.iOS ? 1 : 0)),
          e(s),
          (r.cacheID = Wt.cache),
          o && bw("ss", s);
      } else
        (t || Wt.cache !== r.cacheID || bw("ref")) &&
          ((r.cacheID = Wt.cache), (r.v = e()));
      return r.v + r.offset;
    };
    return (i.offset = 0), e && i;
  },
  _r = {
    s: fv,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: x_(function (n) {
      return arguments.length
        ? us.scrollTo(n, hi.sc())
        : us.pageXOffset || Sl[fv] || Ml[fv] || ph[fv] || 0;
    }),
  },
  hi = {
    s: hv,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _r,
    sc: x_(function (n) {
      return arguments.length
        ? us.scrollTo(_r.sc(), n)
        : us.pageYOffset || Sl[hv] || Ml[hv] || ph[hv] || 0;
    }),
  },
  Lr = function (e, t) {
    return (
      ((t && t._ctx && t._ctx.selector) || Li.utils.toArray)(e)[0] ||
      (typeof e == "string" && Li.config().nullTargetWarn !== !1
        ? console.warn("Element not found:", e)
        : null)
    );
  },
  xQ = function (e, t) {
    for (var i = t.length; i--; ) if (t[i] === e || t[i].contains(e)) return !0;
    return !1;
  },
  Wl = function (e, t) {
    var i = t.s,
      r = t.sc;
    Rp(e) && (e = Sl.scrollingElement || Ml);
    var s = Wt.indexOf(e),
      o = r === hi.sc ? 1 : 2;
    !~s && (s = Wt.push(e) - 1), Wt[s + o] || cr(e, "scroll", Rw);
    var a = Wt[s + o],
      l =
        a ||
        (Wt[s + o] =
          x_(Fl(e, i), !0) ||
          (Rp(e)
            ? r
            : x_(function (u) {
                return arguments.length ? (e[i] = u) : e[i];
              })));
    return (
      (l.target = e),
      a || (l.smooth = Li.getProperty(e, "scrollBehavior") === "smooth"),
      l
    );
  },
  Pw = function (e, t, i) {
    var r = e,
      s = e,
      o = bp(),
      a = o,
      l = t || 50,
      u = Math.max(500, l * 3),
      c = function (v, _) {
        var x = bp();
        _ || x - o > l
          ? ((s = r), (r = v), (a = o), (o = x))
          : i
          ? (r += v)
          : (r = s + ((v - s) / (x - a)) * (o - a));
      },
      d = function () {
        (s = r = i ? 0 : r), (a = o = 0);
      },
      p = function (v) {
        var _ = a,
          x = s,
          g = bp();
        return (
          (v || v === 0) && v !== r && c(v),
          o === a || g - a > u
            ? 0
            : ((r + (i ? x : -x)) / ((i ? g : o) - _)) * 1e3
        );
      };
    return { update: c, reset: d, getVelocity: p };
  },
  Gd = function (e, t) {
    return (
      t && !e._gsapAllow && e.preventDefault(),
      e.changedTouches ? e.changedTouches[0] : e
    );
  },
  _I = function (e) {
    var t = Math.max.apply(Math, e),
      i = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(i) ? t : i;
  },
  VU = function () {
    (Cp = Li.core.globals().ScrollTrigger), Cp && Cp.core && _Q();
  },
  WU = function (e) {
    return (
      (Li = e || HU()),
      !Wv &&
        Li &&
        typeof document < "u" &&
        document.body &&
        ((us = window),
        (Sl = document),
        (Ml = Sl.documentElement),
        (ph = Sl.body),
        (kU = [us, Sl, Ml, ph]),
        Li.utils.clamp,
        (zU = Li.core.context || function () {}),
        (Fu = "onpointerenter" in ph ? "pointer" : "mouse"),
        (UU = $n.isTouch =
          us.matchMedia &&
          us.matchMedia("(hover: none), (pointer: coarse)").matches
            ? 1
            : "ontouchstart" in us ||
              navigator.maxTouchPoints > 0 ||
              navigator.msMaxTouchPoints > 0
            ? 2
            : 0),
        (ao = $n.eventTypes =
          (
            "ontouchstart" in Ml
              ? "touchstart,touchmove,touchcancel,touchend"
              : "onpointerdown" in Ml
              ? "pointerdown,pointermove,pointercancel,pointerup"
              : "mousedown,mousemove,mouseup,mouseup"
          ).split(",")),
        setTimeout(function () {
          return (GU = 0);
        }, 500),
        VU(),
        (Wv = 1)),
      Wv
    );
  };
_r.op = hi;
Wt.cache = 0;
var $n = (function () {
  function n(t) {
    this.init(t);
  }
  var e = n.prototype;
  return (
    (e.init = function (i) {
      Wv || WU(Li) || console.warn("Please gsap.registerPlugin(Observer)"),
        Cp || VU();
      var r = i.tolerance,
        s = i.dragMinimum,
        o = i.type,
        a = i.target,
        l = i.lineHeight,
        u = i.debounce,
        c = i.preventDefault,
        d = i.onStop,
        p = i.onStopDelay,
        m = i.ignore,
        v = i.wheelSpeed,
        _ = i.event,
        x = i.onDragStart,
        g = i.onDragEnd,
        A = i.onDrag,
        S = i.onPress,
        w = i.onRelease,
        C = i.onRight,
        b = i.onLeft,
        P = i.onUp,
        I = i.onDown,
        R = i.onChangeX,
        T = i.onChangeY,
        D = i.onChange,
        G = i.onToggleX,
        W = i.onToggleY,
        q = i.onHover,
        Z = i.onHoverEnd,
        K = i.onMove,
        te = i.ignoreCheck,
        O = i.isNormalizer,
        Y = i.onGestureStart,
        F = i.onGestureEnd,
        se = i.onWheel,
        Me = i.onEnable,
        De = i.onDisable,
        re = i.onClick,
        xe = i.scrollSpeed,
        Ce = i.capture,
        Se = i.allowClicks,
        Xe = i.lockAxis,
        et = i.onLockAxis;
      (this.target = a = Lr(a) || Ml),
        (this.vars = i),
        m && (m = Li.utils.toArray(m)),
        (r = r || 1e-9),
        (s = s || 0),
        (v = v || 1),
        (xe = xe || 1),
        (o = o || "wheel,touch,pointer"),
        (u = u !== !1),
        l || (l = parseFloat(us.getComputedStyle(ph).lineHeight) || 22);
      var Ye,
        Fe,
        de,
        ce,
        k,
        Ve,
        we,
        J = this,
        Te = 0,
        st = 0,
        Le = i.passive || (!c && i.passive !== !1),
        U = Wl(a, _r),
        L = Wl(a, hi),
        ie = U(),
        fe = L(),
        ye =
          ~o.indexOf("touch") &&
          !~o.indexOf("pointer") &&
          ao[0] === "pointerdown",
        me = Rp(a),
        Pe = a.ownerDocument || Sl,
        Ie = [0, 0, 0],
        ze = [0, 0, 0],
        Mt = 0,
        Re = function () {
          return (Mt = bp());
        },
        Ne = function (nt, Et) {
          return (
            ((J.event = nt) && m && xQ(nt.target, m)) ||
            (Et && ye && nt.pointerType !== "touch") ||
            (te && te(nt, Et))
          );
        },
        mt = function () {
          J._vx.reset(), J._vy.reset(), Fe.pause(), d && d(J);
        },
        dt = function () {
          var nt = (J.deltaX = _I(Ie)),
            Et = (J.deltaY = _I(ze)),
            je = Math.abs(nt) >= r,
            Tt = Math.abs(Et) >= r;
          D && (je || Tt) && D(J, nt, Et, Ie, ze),
            je &&
              (C && J.deltaX > 0 && C(J),
              b && J.deltaX < 0 && b(J),
              R && R(J),
              G && J.deltaX < 0 != Te < 0 && G(J),
              (Te = J.deltaX),
              (Ie[0] = Ie[1] = Ie[2] = 0)),
            Tt &&
              (I && J.deltaY > 0 && I(J),
              P && J.deltaY < 0 && P(J),
              T && T(J),
              W && J.deltaY < 0 != st < 0 && W(J),
              (st = J.deltaY),
              (ze[0] = ze[1] = ze[2] = 0)),
            (ce || de) &&
              (K && K(J),
              de && (x && de === 1 && x(J), A && A(J), (de = 0)),
              (ce = !1)),
            Ve && !(Ve = !1) && et && et(J),
            k && (se(J), (k = !1)),
            (Ye = 0);
        },
        Ke = function (nt, Et, je) {
          (Ie[je] += nt),
            (ze[je] += Et),
            J._vx.update(nt),
            J._vy.update(Et),
            u ? Ye || (Ye = requestAnimationFrame(dt)) : dt();
        },
        X = function (nt, Et) {
          Xe &&
            !we &&
            ((J.axis = we = Math.abs(nt) > Math.abs(Et) ? "x" : "y"),
            (Ve = !0)),
            we !== "y" && ((Ie[2] += nt), J._vx.update(nt, !0)),
            we !== "x" && ((ze[2] += Et), J._vy.update(Et, !0)),
            u ? Ye || (Ye = requestAnimationFrame(dt)) : dt();
        },
        pe = function (nt) {
          if (!Ne(nt, 1)) {
            nt = Gd(nt, c);
            var Et = nt.clientX,
              je = nt.clientY,
              Tt = Et - J.x,
              ut = je - J.y,
              St = J.isDragging;
            (J.x = Et),
              (J.y = je),
              (St ||
                ((Tt || ut) &&
                  (Math.abs(J.startX - Et) >= s ||
                    Math.abs(J.startY - je) >= s))) &&
                ((de = St ? 2 : 1), St || (J.isDragging = !0), X(Tt, ut));
          }
        },
        He = (J.onPress = function (We) {
          Ne(We, 1) ||
            (We && We.button) ||
            ((J.axis = we = null),
            Fe.pause(),
            (J.isPressed = !0),
            (We = Gd(We)),
            (Te = st = 0),
            (J.startX = J.x = We.clientX),
            (J.startY = J.y = We.clientY),
            J._vx.reset(),
            J._vy.reset(),
            cr(O ? a : Pe, ao[1], pe, Le, !0),
            (J.deltaX = J.deltaY = 0),
            S && S(J));
        }),
        V = (J.onRelease = function (We) {
          if (!Ne(We, 1)) {
            ur(O ? a : Pe, ao[1], pe, !0);
            var nt = !isNaN(J.y - J.startY),
              Et = J.isDragging,
              je =
                Et &&
                (Math.abs(J.x - J.startX) > 3 || Math.abs(J.y - J.startY) > 3),
              Tt = Gd(We);
            !je &&
              nt &&
              (J._vx.reset(),
              J._vy.reset(),
              c &&
                Se &&
                Li.delayedCall(0.08, function () {
                  if (bp() - Mt > 300 && !We.defaultPrevented) {
                    if (We.target.click) We.target.click();
                    else if (Pe.createEvent) {
                      var ut = Pe.createEvent("MouseEvents");
                      ut.initMouseEvent(
                        "click",
                        !0,
                        !0,
                        us,
                        1,
                        Tt.screenX,
                        Tt.screenY,
                        Tt.clientX,
                        Tt.clientY,
                        !1,
                        !1,
                        !1,
                        !1,
                        0,
                        null
                      ),
                        We.target.dispatchEvent(ut);
                    }
                  }
                })),
              (J.isDragging = J.isGesturing = J.isPressed = !1),
              d && Et && !O && Fe.restart(!0),
              de && dt(),
              g && Et && g(J),
              w && w(J, je);
          }
        }),
        be = function (nt) {
          return (
            nt.touches &&
            nt.touches.length > 1 &&
            (J.isGesturing = !0) &&
            Y(nt, J.isDragging)
          );
        },
        ue = function () {
          return (J.isGesturing = !1) || F(J);
        },
        ge = function (nt) {
          if (!Ne(nt)) {
            var Et = U(),
              je = L();
            Ke((Et - ie) * xe, (je - fe) * xe, 1),
              (ie = Et),
              (fe = je),
              d && Fe.restart(!0);
          }
        },
        Ue = function (nt) {
          if (!Ne(nt)) {
            (nt = Gd(nt, c)), se && (k = !0);
            var Et =
              (nt.deltaMode === 1
                ? l
                : nt.deltaMode === 2
                ? us.innerHeight
                : 1) * v;
            Ke(nt.deltaX * Et, nt.deltaY * Et, 0), d && !O && Fe.restart(!0);
          }
        },
        ke = function (nt) {
          if (!Ne(nt)) {
            var Et = nt.clientX,
              je = nt.clientY,
              Tt = Et - J.x,
              ut = je - J.y;
            (J.x = Et),
              (J.y = je),
              (ce = !0),
              d && Fe.restart(!0),
              (Tt || ut) && X(Tt, ut);
          }
        },
        ft = function (nt) {
          (J.event = nt), q(J);
        },
        Ct = function (nt) {
          (J.event = nt), Z(J);
        },
        cn = function (nt) {
          return Ne(nt) || (Gd(nt, c) && re(J));
        };
      (Fe = J._dc = Li.delayedCall(p || 0.25, mt).pause()),
        (J.deltaX = J.deltaY = 0),
        (J._vx = Pw(0, 50, !0)),
        (J._vy = Pw(0, 50, !0)),
        (J.scrollX = U),
        (J.scrollY = L),
        (J.isDragging = J.isGesturing = J.isPressed = !1),
        zU(this),
        (J.enable = function (We) {
          return (
            J.isEnabled ||
              (cr(me ? Pe : a, "scroll", Rw),
              o.indexOf("scroll") >= 0 && cr(me ? Pe : a, "scroll", ge, Le, Ce),
              o.indexOf("wheel") >= 0 && cr(a, "wheel", Ue, Le, Ce),
              ((o.indexOf("touch") >= 0 && UU) || o.indexOf("pointer") >= 0) &&
                (cr(a, ao[0], He, Le, Ce),
                cr(Pe, ao[2], V),
                cr(Pe, ao[3], V),
                Se && cr(a, "click", Re, !0, !0),
                re && cr(a, "click", cn),
                Y && cr(Pe, "gesturestart", be),
                F && cr(Pe, "gestureend", ue),
                q && cr(a, Fu + "enter", ft),
                Z && cr(a, Fu + "leave", Ct),
                K && cr(a, Fu + "move", ke)),
              (J.isEnabled = !0),
              (J.isDragging = J.isGesturing = J.isPressed = ce = de = !1),
              J._vx.reset(),
              J._vy.reset(),
              (ie = U()),
              (fe = L()),
              We && We.type && He(We),
              Me && Me(J)),
            J
          );
        }),
        (J.disable = function () {
          J.isEnabled &&
            (Zf.filter(function (We) {
              return We !== J && Rp(We.target);
            }).length || ur(me ? Pe : a, "scroll", Rw),
            J.isPressed &&
              (J._vx.reset(), J._vy.reset(), ur(O ? a : Pe, ao[1], pe, !0)),
            ur(me ? Pe : a, "scroll", ge, Ce),
            ur(a, "wheel", Ue, Ce),
            ur(a, ao[0], He, Ce),
            ur(Pe, ao[2], V),
            ur(Pe, ao[3], V),
            ur(a, "click", Re, !0),
            ur(a, "click", cn),
            ur(Pe, "gesturestart", be),
            ur(Pe, "gestureend", ue),
            ur(a, Fu + "enter", ft),
            ur(a, Fu + "leave", Ct),
            ur(a, Fu + "move", ke),
            (J.isEnabled = J.isPressed = J.isDragging = !1),
            De && De(J));
        }),
        (J.kill = J.revert =
          function () {
            J.disable();
            var We = Zf.indexOf(J);
            We >= 0 && Zf.splice(We, 1), wa === J && (wa = 0);
          }),
        Zf.push(J),
        O && Rp(a) && (wa = J),
        J.enable(_);
    }),
    yQ(n, [
      {
        key: "velocityX",
        get: function () {
          return this._vx.getVelocity();
        },
      },
      {
        key: "velocityY",
        get: function () {
          return this._vy.getVelocity();
        },
      },
    ]),
    n
  );
})();
$n.version = "3.13.0";
$n.create = function (n) {
  return new $n(n);
};
$n.register = WU;
$n.getAll = function () {
  return Zf.slice();
};
$n.getById = function (n) {
  return Zf.filter(function (e) {
    return e.vars.id === n;
  })[0];
};
HU() && Li.registerPlugin($n);
/*!
 * ScrollTrigger 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var lt,
  Pf,
  Vt,
  An,
  as,
  fn,
  mC,
  A_,
  Em,
  Pp,
  ep,
  dv,
  Yi,
  Fx,
  Bw,
  mr,
  xI,
  AI,
  Bf,
  XU,
  BS,
  JU,
  hr,
  Iw,
  jU,
  YU,
  ul,
  Dw,
  gC,
  mh,
  vC,
  S_,
  Lw,
  IS,
  pv = 1,
  Ki = Date.now,
  DS = Ki(),
  Qs = 0,
  tp = 0,
  SI = function (e, t, i) {
    var r = ss(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
    return (i["_" + t + "Clamp"] = r), r ? e.substr(6, e.length - 7) : e;
  },
  MI = function (e, t) {
    return t && (!ss(e) || e.substr(0, 6) !== "clamp(")
      ? "clamp(" + e + ")"
      : e;
  },
  AQ = function n() {
    return tp && requestAnimationFrame(n);
  },
  wI = function () {
    return (Fx = 1);
  },
  EI = function () {
    return (Fx = 0);
  },
  No = function (e) {
    return e;
  },
  np = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  KU = function () {
    return typeof window < "u";
  },
  QU = function () {
    return lt || (KU() && (lt = window.gsap) && lt.registerPlugin && lt);
  },
  Pc = function (e) {
    return !!~mC.indexOf(e);
  },
  ZU = function (e) {
    return (
      (e === "Height" ? vC : Vt["inner" + e]) ||
      as["client" + e] ||
      fn["client" + e]
    );
  },
  qU = function (e) {
    return (
      Fl(e, "getBoundingClientRect") ||
      (Pc(e)
        ? function () {
            return (Kv.width = Vt.innerWidth), (Kv.height = vC), Kv;
          }
        : function () {
            return _a(e);
          })
    );
  },
  SQ = function (e, t, i) {
    var r = i.d,
      s = i.d2,
      o = i.a;
    return (o = Fl(e, "getBoundingClientRect"))
      ? function () {
          return o()[r];
        }
      : function () {
          return (t ? ZU(s) : e["client" + s]) || 0;
        };
  },
  MQ = function (e, t) {
    return !t || ~Jo.indexOf(e)
      ? qU(e)
      : function () {
          return Kv;
        };
  },
  zo = function (e, t) {
    var i = t.s,
      r = t.d2,
      s = t.d,
      o = t.a;
    return Math.max(
      0,
      (i = "scroll" + r) && (o = Fl(e, i))
        ? o() - qU(e)()[s]
        : Pc(e)
        ? (as[i] || fn[i]) - ZU(r)
        : e[i] - e["offset" + r]
    );
  },
  mv = function (e, t) {
    for (var i = 0; i < Bf.length; i += 3)
      (!t || ~t.indexOf(Bf[i + 1])) && e(Bf[i], Bf[i + 1], Bf[i + 2]);
  },
  ss = function (e) {
    return typeof e == "string";
  },
  qi = function (e) {
    return typeof e == "function";
  },
  ip = function (e) {
    return typeof e == "number";
  },
  Nu = function (e) {
    return typeof e == "object";
  },
  Vd = function (e, t, i) {
    return e && e.progress(t ? 0 : 1) && i && e.pause();
  },
  LS = function (e, t) {
    if (e.enabled) {
      var i = e._ctx
        ? e._ctx.add(function () {
            return t(e);
          })
        : t(e);
      i && i.totalTime && (e.callbackAnimation = i);
    }
  },
  Ef = Math.abs,
  $U = "left",
  ek = "top",
  yC = "right",
  _C = "bottom",
  hc = "width",
  dc = "height",
  Bp = "Right",
  Ip = "Left",
  Dp = "Top",
  Lp = "Bottom",
  ri = "padding",
  Hs = "margin",
  Uh = "Width",
  xC = "Height",
  ci = "px",
  Gs = function (e) {
    return Vt.getComputedStyle(e);
  },
  wQ = function (e) {
    var t = Gs(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative";
  },
  TI = function (e, t) {
    for (var i in t) i in e || (e[i] = t[i]);
    return e;
  },
  _a = function (e, t) {
    var i =
        t &&
        Gs(e)[Bw] !== "matrix(1, 0, 0, 1, 0, 0)" &&
        lt
          .to(e, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0,
          })
          .progress(1),
      r = e.getBoundingClientRect();
    return i && i.progress(0).kill(), r;
  },
  M_ = function (e, t) {
    var i = t.d2;
    return e["offset" + i] || e["client" + i] || 0;
  },
  tk = function (e) {
    var t = [],
      i = e.labels,
      r = e.duration(),
      s;
    for (s in i) t.push(i[s] / r);
    return t;
  },
  EQ = function (e) {
    return function (t) {
      return lt.utils.snap(tk(e), t);
    };
  },
  AC = function (e) {
    var t = lt.utils.snap(e),
      i =
        Array.isArray(e) &&
        e.slice(0).sort(function (r, s) {
          return r - s;
        });
    return i
      ? function (r, s, o) {
          o === void 0 && (o = 0.001);
          var a;
          if (!s) return t(r);
          if (s > 0) {
            for (r -= o, a = 0; a < i.length; a++) if (i[a] >= r) return i[a];
            return i[a - 1];
          } else for (a = i.length, r += o; a--; ) if (i[a] <= r) return i[a];
          return i[0];
        }
      : function (r, s, o) {
          o === void 0 && (o = 0.001);
          var a = t(r);
          return !s || Math.abs(a - r) < o || a - r < 0 == s < 0
            ? a
            : t(s < 0 ? r - e : r + e);
        };
  },
  TQ = function (e) {
    return function (t, i) {
      return AC(tk(e))(t, i.direction);
    };
  },
  gv = function (e, t, i, r) {
    return i.split(",").forEach(function (s) {
      return e(t, s, r);
    });
  },
  Ei = function (e, t, i, r, s) {
    return e.addEventListener(t, i, { passive: !r, capture: !!s });
  },
  wi = function (e, t, i, r) {
    return e.removeEventListener(t, i, !!r);
  },
  vv = function (e, t, i) {
    (i = i && i.wheelHandler), i && (e(t, "wheel", i), e(t, "touchmove", i));
  },
  CI = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal",
  },
  yv = { toggleActions: "play", anticipatePin: 0 },
  w_ = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
  Xv = function (e, t) {
    if (ss(e)) {
      var i = e.indexOf("="),
        r = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
      ~i && (e.indexOf("%") > i && (r *= t / 100), (e = e.substr(0, i - 1))),
        (e =
          r +
          (e in w_
            ? w_[e] * t
            : ~e.indexOf("%")
            ? (parseFloat(e) * t) / 100
            : parseFloat(e) || 0));
    }
    return e;
  },
  _v = function (e, t, i, r, s, o, a, l) {
    var u = s.startColor,
      c = s.endColor,
      d = s.fontSize,
      p = s.indent,
      m = s.fontWeight,
      v = An.createElement("div"),
      _ = Pc(i) || Fl(i, "pinType") === "fixed",
      x = e.indexOf("scroller") !== -1,
      g = _ ? fn : i,
      A = e.indexOf("start") !== -1,
      S = A ? u : c,
      w =
        "border-color:" +
        S +
        ";font-size:" +
        d +
        ";color:" +
        S +
        ";font-weight:" +
        m +
        ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return (
      (w += "position:" + ((x || l) && _ ? "fixed;" : "absolute;")),
      (x || l || !_) &&
        (w += (r === hi ? yC : _C) + ":" + (o + parseFloat(p)) + "px;"),
      a &&
        (w +=
          "box-sizing:border-box;text-align:left;width:" +
          a.offsetWidth +
          "px;"),
      (v._isStart = A),
      v.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
      (v.style.cssText = w),
      (v.innerText = t || t === 0 ? e + "-" + t : e),
      g.children[0] ? g.insertBefore(v, g.children[0]) : g.appendChild(v),
      (v._offset = v["offset" + r.op.d2]),
      Jv(v, 0, r, A),
      v
    );
  },
  Jv = function (e, t, i, r) {
    var s = { display: "block" },
      o = i[r ? "os2" : "p2"],
      a = i[r ? "p2" : "os2"];
    (e._isFlipped = r),
      (s[i.a + "Percent"] = r ? -100 : 0),
      (s[i.a] = r ? "1px" : 0),
      (s["border" + o + Uh] = 1),
      (s["border" + a + Uh] = 0),
      (s[i.p] = t + "px"),
      lt.set(e, s);
  },
  Ht = [],
  Fw = {},
  Tm,
  bI = function () {
    return Ki() - Qs > 34 && (Tm || (Tm = requestAnimationFrame(Pa)));
  },
  Tf = function () {
    (!hr || !hr.isPressed || hr.startX > fn.clientWidth) &&
      (Wt.cache++,
      hr ? Tm || (Tm = requestAnimationFrame(Pa)) : Pa(),
      Qs || Ic("scrollStart"),
      (Qs = Ki()));
  },
  FS = function () {
    (YU = Vt.innerWidth), (jU = Vt.innerHeight);
  },
  rp = function (e) {
    Wt.cache++,
      (e === !0 ||
        (!Yi &&
          !JU &&
          !An.fullscreenElement &&
          !An.webkitFullscreenElement &&
          (!Iw ||
            YU !== Vt.innerWidth ||
            Math.abs(Vt.innerHeight - jU) > Vt.innerHeight * 0.25))) &&
        A_.restart(!0);
  },
  Bc = {},
  CQ = [],
  nk = function n() {
    return wi(Gt, "scrollEnd", n) || qu(!0);
  },
  Ic = function (e) {
    return (
      (Bc[e] &&
        Bc[e].map(function (t) {
          return t();
        })) ||
      CQ
    );
  },
  is = [],
  ik = function (e) {
    for (var t = 0; t < is.length; t += 5)
      (!e || (is[t + 4] && is[t + 4].query === e)) &&
        ((is[t].style.cssText = is[t + 1]),
        is[t].getBBox && is[t].setAttribute("transform", is[t + 2] || ""),
        (is[t + 3].uncache = 1));
  },
  SC = function (e, t) {
    var i;
    for (mr = 0; mr < Ht.length; mr++)
      (i = Ht[mr]),
        i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
    (S_ = !0), t && ik(t), t || Ic("revert");
  },
  rk = function (e, t) {
    Wt.cache++,
      (t || !gr) &&
        Wt.forEach(function (i) {
          return qi(i) && i.cacheID++ && (i.rec = 0);
        }),
      ss(e) && (Vt.history.scrollRestoration = gC = e);
  },
  gr,
  pc = 0,
  RI,
  bQ = function () {
    if (RI !== pc) {
      var e = (RI = pc);
      requestAnimationFrame(function () {
        return e === pc && qu(!0);
      });
    }
  },
  sk = function () {
    fn.appendChild(mh),
      (vC = (!hr && mh.offsetHeight) || Vt.innerHeight),
      fn.removeChild(mh);
  },
  PI = function (e) {
    return Em(
      ".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end"
    ).forEach(function (t) {
      return (t.style.display = e ? "none" : "block");
    });
  },
  qu = function (e, t) {
    if (
      ((as = An.documentElement),
      (fn = An.body),
      (mC = [Vt, An, as, fn]),
      Qs && !e && !S_)
    ) {
      Ei(Gt, "scrollEnd", nk);
      return;
    }
    sk(),
      (gr = Gt.isRefreshing = !0),
      Wt.forEach(function (r) {
        return qi(r) && ++r.cacheID && (r.rec = r());
      });
    var i = Ic("refreshInit");
    XU && Gt.sort(),
      t || SC(),
      Wt.forEach(function (r) {
        qi(r) && (r.smooth && (r.target.style.scrollBehavior = "auto"), r(0));
      }),
      Ht.slice(0).forEach(function (r) {
        return r.refresh();
      }),
      (S_ = !1),
      Ht.forEach(function (r) {
        if (r._subPinOffset && r.pin) {
          var s = r.vars.horizontal ? "offsetWidth" : "offsetHeight",
            o = r.pin[s];
          r.revert(!0, 1), r.adjustPinSpacing(r.pin[s] - o), r.refresh();
        }
      }),
      (Lw = 1),
      PI(!0),
      Ht.forEach(function (r) {
        var s = zo(r.scroller, r._dir),
          o = r.vars.end === "max" || (r._endClamp && r.end > s),
          a = r._startClamp && r.start >= s;
        (o || a) &&
          r.setPositions(
            a ? s - 1 : r.start,
            o ? Math.max(a ? s : r.start + 1, s) : r.end,
            !0
          );
      }),
      PI(!1),
      (Lw = 0),
      i.forEach(function (r) {
        return r && r.render && r.render(-1);
      }),
      Wt.forEach(function (r) {
        qi(r) &&
          (r.smooth &&
            requestAnimationFrame(function () {
              return (r.target.style.scrollBehavior = "smooth");
            }),
          r.rec && r(r.rec));
      }),
      rk(gC, 1),
      A_.pause(),
      pc++,
      (gr = 2),
      Pa(2),
      Ht.forEach(function (r) {
        return qi(r.vars.onRefresh) && r.vars.onRefresh(r);
      }),
      (gr = Gt.isRefreshing = !1),
      Ic("refresh");
  },
  Nw = 0,
  jv = 1,
  Fp,
  Pa = function (e) {
    if (e === 2 || (!gr && !S_)) {
      (Gt.isUpdating = !0), Fp && Fp.update(0);
      var t = Ht.length,
        i = Ki(),
        r = i - DS >= 50,
        s = t && Ht[0].scroll();
      if (
        ((jv = Nw > s ? -1 : 1),
        gr || (Nw = s),
        r &&
          (Qs && !Fx && i - Qs > 200 && ((Qs = 0), Ic("scrollEnd")),
          (ep = DS),
          (DS = i)),
        jv < 0)
      ) {
        for (mr = t; mr-- > 0; ) Ht[mr] && Ht[mr].update(0, r);
        jv = 1;
      } else for (mr = 0; mr < t; mr++) Ht[mr] && Ht[mr].update(0, r);
      Gt.isUpdating = !1;
    }
    Tm = 0;
  },
  Ow = [
    $U,
    ek,
    _C,
    yC,
    Hs + Lp,
    Hs + Bp,
    Hs + Dp,
    Hs + Ip,
    "display",
    "flexShrink",
    "float",
    "zIndex",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRowStart",
    "gridRowEnd",
    "gridArea",
    "justifySelf",
    "alignSelf",
    "placeSelf",
    "order",
  ],
  Yv = Ow.concat([
    hc,
    dc,
    "boxSizing",
    "max" + Uh,
    "max" + xC,
    "position",
    Hs,
    ri,
    ri + Dp,
    ri + Bp,
    ri + Lp,
    ri + Ip,
  ]),
  RQ = function (e, t, i) {
    gh(i);
    var r = e._gsap;
    if (r.spacerIsNative) gh(r.spacerState);
    else if (e._gsap.swappedIn) {
      var s = t.parentNode;
      s && (s.insertBefore(e, t), s.removeChild(t));
    }
    e._gsap.swappedIn = !1;
  },
  NS = function (e, t, i, r) {
    if (!e._gsap.swappedIn) {
      for (var s = Ow.length, o = t.style, a = e.style, l; s--; )
        (l = Ow[s]), (o[l] = i[l]);
      (o.position = i.position === "absolute" ? "absolute" : "relative"),
        i.display === "inline" && (o.display = "inline-block"),
        (a[_C] = a[yC] = "auto"),
        (o.flexBasis = i.flexBasis || "auto"),
        (o.overflow = "visible"),
        (o.boxSizing = "border-box"),
        (o[hc] = M_(e, _r) + ci),
        (o[dc] = M_(e, hi) + ci),
        (o[ri] = a[Hs] = a[ek] = a[$U] = "0"),
        gh(r),
        (a[hc] = a["max" + Uh] = i[hc]),
        (a[dc] = a["max" + xC] = i[dc]),
        (a[ri] = i[ri]),
        e.parentNode !== t &&
          (e.parentNode.insertBefore(t, e), t.appendChild(e)),
        (e._gsap.swappedIn = !0);
    }
  },
  PQ = /([A-Z])/g,
  gh = function (e) {
    if (e) {
      var t = e.t.style,
        i = e.length,
        r = 0,
        s,
        o;
      for ((e.t._gsap || lt.core.getCache(e.t)).uncache = 1; r < i; r += 2)
        (o = e[r + 1]),
          (s = e[r]),
          o
            ? (t[s] = o)
            : t[s] && t.removeProperty(s.replace(PQ, "-$1").toLowerCase());
    }
  },
  xv = function (e) {
    for (var t = Yv.length, i = e.style, r = [], s = 0; s < t; s++)
      r.push(Yv[s], i[Yv[s]]);
    return (r.t = e), r;
  },
  BQ = function (e, t, i) {
    for (var r = [], s = e.length, o = i ? 8 : 0, a; o < s; o += 2)
      (a = e[o]), r.push(a, a in t ? t[a] : e[o + 1]);
    return (r.t = e.t), r;
  },
  Kv = { left: 0, top: 0 },
  BI = function (e, t, i, r, s, o, a, l, u, c, d, p, m, v) {
    qi(e) && (e = e(l)),
      ss(e) &&
        e.substr(0, 3) === "max" &&
        (e = p + (e.charAt(4) === "=" ? Xv("0" + e.substr(3), i) : 0));
    var _ = m ? m.time() : 0,
      x,
      g,
      A;
    if ((m && m.seek(0), isNaN(e) || (e = +e), ip(e)))
      m &&
        (e = lt.utils.mapRange(
          m.scrollTrigger.start,
          m.scrollTrigger.end,
          0,
          p,
          e
        )),
        a && Jv(a, i, r, !0);
    else {
      qi(t) && (t = t(l));
      var S = (e || "0").split(" "),
        w,
        C,
        b,
        P;
      (A = Lr(t, l) || fn),
        (w = _a(A) || {}),
        (!w || (!w.left && !w.top)) &&
          Gs(A).display === "none" &&
          ((P = A.style.display),
          (A.style.display = "block"),
          (w = _a(A)),
          P ? (A.style.display = P) : A.style.removeProperty("display")),
        (C = Xv(S[0], w[r.d])),
        (b = Xv(S[1] || "0", i)),
        (e = w[r.p] - u[r.p] - c + C + s - b),
        a && Jv(a, b, r, i - b < 20 || (a._isStart && b > 20)),
        (i -= i - b);
    }
    if ((v && ((l[v] = e || -0.001), e < 0 && (e = 0)), o)) {
      var I = e + i,
        R = o._isStart;
      (x = "scroll" + r.d2),
        Jv(
          o,
          I,
          r,
          (R && I > 20) ||
            (!R && (d ? Math.max(fn[x], as[x]) : o.parentNode[x]) <= I + 1)
        ),
        d &&
          ((u = _a(a)),
          d && (o.style[r.op.p] = u[r.op.p] - r.op.m - o._offset + ci));
    }
    return (
      m &&
        A &&
        ((x = _a(A)),
        m.seek(p),
        (g = _a(A)),
        (m._caScrollDist = x[r.p] - g[r.p]),
        (e = (e / m._caScrollDist) * p)),
      m && m.seek(_),
      m ? e : Math.round(e)
    );
  },
  IQ = /(webkit|moz|length|cssText|inset)/i,
  II = function (e, t, i, r) {
    if (e.parentNode !== t) {
      var s = e.style,
        o,
        a;
      if (t === fn) {
        (e._stOrig = s.cssText), (a = Gs(e));
        for (o in a)
          !+o &&
            !IQ.test(o) &&
            a[o] &&
            typeof s[o] == "string" &&
            o !== "0" &&
            (s[o] = a[o]);
        (s.top = i), (s.left = r);
      } else s.cssText = e._stOrig;
      (lt.core.getCache(e).uncache = 1), t.appendChild(e);
    }
  },
  ok = function (e, t, i) {
    var r = t,
      s = r;
    return function (o) {
      var a = Math.round(e());
      return (
        a !== r &&
          a !== s &&
          Math.abs(a - r) > 3 &&
          Math.abs(a - s) > 3 &&
          ((o = a), i && i()),
        (s = r),
        (r = Math.round(o)),
        r
      );
    };
  },
  Av = function (e, t, i) {
    var r = {};
    (r[t.p] = "+=" + i), lt.set(e, r);
  },
  DI = function (e, t) {
    var i = Wl(e, t),
      r = "_scroll" + t.p2,
      s = function o(a, l, u, c, d) {
        var p = o.tween,
          m = l.onComplete,
          v = {};
        u = u || i();
        var _ = ok(i, u, function () {
          p.kill(), (o.tween = 0);
        });
        return (
          (d = (c && d) || 0),
          (c = c || a - u),
          p && p.kill(),
          (l[r] = a),
          (l.inherit = !1),
          (l.modifiers = v),
          (v[r] = function () {
            return _(u + c * p.ratio + d * p.ratio * p.ratio);
          }),
          (l.onUpdate = function () {
            Wt.cache++, o.tween && Pa();
          }),
          (l.onComplete = function () {
            (o.tween = 0), m && m.call(p);
          }),
          (p = o.tween = lt.to(e, l)),
          p
        );
      };
    return (
      (e[r] = i),
      (i.wheelHandler = function () {
        return s.tween && s.tween.kill() && (s.tween = 0);
      }),
      Ei(e, "wheel", i.wheelHandler),
      Gt.isTouch && Ei(e, "touchmove", i.wheelHandler),
      s
    );
  },
  Gt = (function () {
    function n(t, i) {
      Pf ||
        n.register(lt) ||
        console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        Dw(this),
        this.init(t, i);
    }
    var e = n.prototype;
    return (
      (e.init = function (i, r) {
        if (
          ((this.progress = this.start = 0),
          this.vars && this.kill(!0, !0),
          !tp)
        ) {
          this.update = this.refresh = this.kill = No;
          return;
        }
        i = TI(ss(i) || ip(i) || i.nodeType ? { trigger: i } : i, yv);
        var s = i,
          o = s.onUpdate,
          a = s.toggleClass,
          l = s.id,
          u = s.onToggle,
          c = s.onRefresh,
          d = s.scrub,
          p = s.trigger,
          m = s.pin,
          v = s.pinSpacing,
          _ = s.invalidateOnRefresh,
          x = s.anticipatePin,
          g = s.onScrubComplete,
          A = s.onSnapComplete,
          S = s.once,
          w = s.snap,
          C = s.pinReparent,
          b = s.pinSpacer,
          P = s.containerAnimation,
          I = s.fastScrollEnd,
          R = s.preventOverlaps,
          T =
            i.horizontal || (i.containerAnimation && i.horizontal !== !1)
              ? _r
              : hi,
          D = !d && d !== 0,
          G = Lr(i.scroller || Vt),
          W = lt.core.getCache(G),
          q = Pc(G),
          Z =
            ("pinType" in i
              ? i.pinType
              : Fl(G, "pinType") || (q && "fixed")) === "fixed",
          K = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack],
          te = D && i.toggleActions.split(" "),
          O = "markers" in i ? i.markers : yv.markers,
          Y = q ? 0 : parseFloat(Gs(G)["border" + T.p2 + Uh]) || 0,
          F = this,
          se =
            i.onRefreshInit &&
            function () {
              return i.onRefreshInit(F);
            },
          Me = SQ(G, q, T),
          De = MQ(G, q),
          re = 0,
          xe = 0,
          Ce = 0,
          Se = Wl(G, T),
          Xe,
          et,
          Ye,
          Fe,
          de,
          ce,
          k,
          Ve,
          we,
          J,
          Te,
          st,
          Le,
          U,
          L,
          ie,
          fe,
          ye,
          me,
          Pe,
          Ie,
          ze,
          Mt,
          Re,
          Ne,
          mt,
          dt,
          Ke,
          X,
          pe,
          He,
          V,
          be,
          ue,
          ge,
          Ue,
          ke,
          ft,
          Ct;
        if (
          ((F._startClamp = F._endClamp = !1),
          (F._dir = T),
          (x *= 45),
          (F.scroller = G),
          (F.scroll = P ? P.time.bind(P) : Se),
          (Fe = Se()),
          (F.vars = i),
          (r = r || i.animation),
          "refreshPriority" in i &&
            ((XU = 1), i.refreshPriority === -9999 && (Fp = F)),
          (W.tweenScroll = W.tweenScroll || {
            top: DI(G, hi),
            left: DI(G, _r),
          }),
          (F.tweenTo = Xe = W.tweenScroll[T.p]),
          (F.scrubDuration = function (je) {
            (be = ip(je) && je),
              be
                ? V
                  ? V.duration(je)
                  : (V = lt.to(r, {
                      ease: "expo",
                      totalProgress: "+=0",
                      inherit: !1,
                      duration: be,
                      paused: !0,
                      onComplete: function () {
                        return g && g(F);
                      },
                    }))
                : (V && V.progress(1).kill(), (V = 0));
          }),
          r &&
            ((r.vars.lazy = !1),
            (r._initted && !F.isReverted) ||
              (r.vars.immediateRender !== !1 &&
                i.immediateRender !== !1 &&
                r.duration() &&
                r.render(0, !0, !0)),
            (F.animation = r.pause()),
            (r.scrollTrigger = F),
            F.scrubDuration(d),
            (pe = 0),
            l || (l = r.vars.id)),
          w &&
            ((!Nu(w) || w.push) && (w = { snapTo: w }),
            "scrollBehavior" in fn.style &&
              lt.set(q ? [fn, as] : G, { scrollBehavior: "auto" }),
            Wt.forEach(function (je) {
              return (
                qi(je) &&
                je.target === (q ? An.scrollingElement || as : G) &&
                (je.smooth = !1)
              );
            }),
            (Ye = qi(w.snapTo)
              ? w.snapTo
              : w.snapTo === "labels"
              ? EQ(r)
              : w.snapTo === "labelsDirectional"
              ? TQ(r)
              : w.directional !== !1
              ? function (je, Tt) {
                  return AC(w.snapTo)(je, Ki() - xe < 500 ? 0 : Tt.direction);
                }
              : lt.utils.snap(w.snapTo)),
            (ue = w.duration || { min: 0.1, max: 2 }),
            (ue = Nu(ue) ? Pp(ue.min, ue.max) : Pp(ue, ue)),
            (ge = lt
              .delayedCall(w.delay || be / 2 || 0.1, function () {
                var je = Se(),
                  Tt = Ki() - xe < 500,
                  ut = Xe.tween;
                if (
                  (Tt || Math.abs(F.getVelocity()) < 10) &&
                  !ut &&
                  !Fx &&
                  re !== je
                ) {
                  var St = (je - ce) / U,
                    Bn = r && !D ? r.totalProgress() : St,
                    bt = Tt ? 0 : ((Bn - He) / (Ki() - ep)) * 1e3 || 0,
                    gn = lt.utils.clamp(-St, 1 - St, (Ef(bt / 2) * bt) / 0.185),
                    Wn = St + (w.inertia === !1 ? 0 : gn),
                    hn,
                    dn,
                    sn = w,
                    sr = sn.onStart,
                    vn = sn.onInterrupt,
                    yi = sn.onComplete;
                  if (
                    ((hn = Ye(Wn, F)),
                    ip(hn) || (hn = Wn),
                    (dn = Math.max(0, Math.round(ce + hn * U))),
                    je <= k && je >= ce && dn !== je)
                  ) {
                    if (ut && !ut._initted && ut.data <= Ef(dn - je)) return;
                    w.inertia === !1 && (gn = hn - St),
                      Xe(
                        dn,
                        {
                          duration: ue(
                            Ef(
                              (Math.max(Ef(Wn - Bn), Ef(hn - Bn)) * 0.185) /
                                bt /
                                0.05 || 0
                            )
                          ),
                          ease: w.ease || "power3",
                          data: Ef(dn - je),
                          onInterrupt: function () {
                            return ge.restart(!0) && vn && vn(F);
                          },
                          onComplete: function () {
                            F.update(),
                              (re = Se()),
                              r &&
                                !D &&
                                (V
                                  ? V.resetTo(
                                      "totalProgress",
                                      hn,
                                      r._tTime / r._tDur
                                    )
                                  : r.progress(hn)),
                              (pe = He =
                                r && !D ? r.totalProgress() : F.progress),
                              A && A(F),
                              yi && yi(F);
                          },
                        },
                        je,
                        gn * U,
                        dn - je - gn * U
                      ),
                      sr && sr(F, Xe.tween);
                  }
                } else F.isActive && re !== je && ge.restart(!0);
              })
              .pause())),
          l && (Fw[l] = F),
          (p = F.trigger = Lr(p || (m !== !0 && m))),
          (Ct = p && p._gsap && p._gsap.stRevert),
          Ct && (Ct = Ct(F)),
          (m = m === !0 ? p : Lr(m)),
          ss(a) && (a = { targets: p, className: a }),
          m &&
            (v === !1 ||
              v === Hs ||
              (v =
                !v &&
                m.parentNode &&
                m.parentNode.style &&
                Gs(m.parentNode).display === "flex"
                  ? !1
                  : ri),
            (F.pin = m),
            (et = lt.core.getCache(m)),
            et.spacer
              ? (L = et.pinState)
              : (b &&
                  ((b = Lr(b)),
                  b && !b.nodeType && (b = b.current || b.nativeElement),
                  (et.spacerIsNative = !!b),
                  b && (et.spacerState = xv(b))),
                (et.spacer = ye = b || An.createElement("div")),
                ye.classList.add("pin-spacer"),
                l && ye.classList.add("pin-spacer-" + l),
                (et.pinState = L = xv(m))),
            i.force3D !== !1 && lt.set(m, { force3D: !0 }),
            (F.spacer = ye = et.spacer),
            (X = Gs(m)),
            (Re = X[v + T.os2]),
            (Pe = lt.getProperty(m)),
            (Ie = lt.quickSetter(m, T.a, ci)),
            NS(m, ye, X),
            (fe = xv(m))),
          O)
        ) {
          (st = Nu(O) ? TI(O, CI) : CI),
            (J = _v("scroller-start", l, G, T, st, 0)),
            (Te = _v("scroller-end", l, G, T, st, 0, J)),
            (me = J["offset" + T.op.d2]);
          var cn = Lr(Fl(G, "content") || G);
          (Ve = this.markerStart = _v("start", l, cn, T, st, me, 0, P)),
            (we = this.markerEnd = _v("end", l, cn, T, st, me, 0, P)),
            P && (ft = lt.quickSetter([Ve, we], T.a, ci)),
            !Z &&
              !(Jo.length && Fl(G, "fixedMarkers") === !0) &&
              (wQ(q ? fn : G),
              lt.set([J, Te], { force3D: !0 }),
              (mt = lt.quickSetter(J, T.a, ci)),
              (Ke = lt.quickSetter(Te, T.a, ci)));
        }
        if (P) {
          var We = P.vars.onUpdate,
            nt = P.vars.onUpdateParams;
          P.eventCallback("onUpdate", function () {
            F.update(0, 0, 1), We && We.apply(P, nt || []);
          });
        }
        if (
          ((F.previous = function () {
            return Ht[Ht.indexOf(F) - 1];
          }),
          (F.next = function () {
            return Ht[Ht.indexOf(F) + 1];
          }),
          (F.revert = function (je, Tt) {
            if (!Tt) return F.kill(!0);
            var ut = je !== !1 || !F.enabled,
              St = Yi;
            ut !== F.isReverted &&
              (ut &&
                ((Ue = Math.max(Se(), F.scroll.rec || 0)),
                (Ce = F.progress),
                (ke = r && r.progress())),
              Ve &&
                [Ve, we, J, Te].forEach(function (Bn) {
                  return (Bn.style.display = ut ? "none" : "block");
                }),
              ut && ((Yi = F), F.update(ut)),
              m &&
                (!C || !F.isActive) &&
                (ut ? RQ(m, ye, L) : NS(m, ye, Gs(m), Ne)),
              ut || F.update(ut),
              (Yi = St),
              (F.isReverted = ut));
          }),
          (F.refresh = function (je, Tt, ut, St) {
            if (!((Yi || !F.enabled) && !Tt)) {
              if (m && je && Qs) {
                Ei(n, "scrollEnd", nk);
                return;
              }
              !gr && se && se(F),
                (Yi = F),
                Xe.tween && !ut && (Xe.tween.kill(), (Xe.tween = 0)),
                V && V.pause(),
                _ &&
                  r &&
                  (r.revert({ kill: !1 }).invalidate(),
                  r.getChildren &&
                    r.getChildren(!0, !0, !1).forEach(function (rt) {
                      return rt.vars.immediateRender && rt.render(0, !0, !0);
                    })),
                F.isReverted || F.revert(!0, !0),
                (F._subPinOffset = !1);
              var Bn = Me(),
                bt = De(),
                gn = P ? P.duration() : zo(G, T),
                Wn = U <= 0.01 || !U,
                hn = 0,
                dn = St || 0,
                sn = Nu(ut) ? ut.end : i.end,
                sr = i.endTrigger || p,
                vn = Nu(ut)
                  ? ut.start
                  : i.start || (i.start === 0 || !p ? 0 : m ? "0 0" : "0 100%"),
                yi = (F.pinnedContainer =
                  i.pinnedContainer && Lr(i.pinnedContainer, F)),
                Er = (p && Math.max(0, Ht.indexOf(F))) || 0,
                Xn = Er,
                Jn,
                N,
                $,
                ae,
                oe,
                Q,
                Ee,
                Je,
                it,
                $e,
                ct,
                pt,
                Ge;
              for (
                O &&
                Nu(ut) &&
                ((pt = lt.getProperty(J, T.p)), (Ge = lt.getProperty(Te, T.p)));
                Xn-- > 0;

              )
                (Q = Ht[Xn]),
                  Q.end || Q.refresh(0, 1) || (Yi = F),
                  (Ee = Q.pin),
                  Ee &&
                    (Ee === p || Ee === m || Ee === yi) &&
                    !Q.isReverted &&
                    ($e || ($e = []), $e.unshift(Q), Q.revert(!0, !0)),
                  Q !== Ht[Xn] && (Er--, Xn--);
              for (
                qi(vn) && (vn = vn(F)),
                  vn = SI(vn, "start", F),
                  ce =
                    BI(
                      vn,
                      p,
                      Bn,
                      T,
                      Se(),
                      Ve,
                      J,
                      F,
                      bt,
                      Y,
                      Z,
                      gn,
                      P,
                      F._startClamp && "_startClamp"
                    ) || (m ? -0.001 : 0),
                  qi(sn) && (sn = sn(F)),
                  ss(sn) &&
                    !sn.indexOf("+=") &&
                    (~sn.indexOf(" ")
                      ? (sn = (ss(vn) ? vn.split(" ")[0] : "") + sn)
                      : ((hn = Xv(sn.substr(2), Bn)),
                        (sn = ss(vn)
                          ? vn
                          : (P
                              ? lt.utils.mapRange(
                                  0,
                                  P.duration(),
                                  P.scrollTrigger.start,
                                  P.scrollTrigger.end,
                                  ce
                                )
                              : ce) + hn),
                        (sr = p))),
                  sn = SI(sn, "end", F),
                  k =
                    Math.max(
                      ce,
                      BI(
                        sn || (sr ? "100% 0" : gn),
                        sr,
                        Bn,
                        T,
                        Se() + hn,
                        we,
                        Te,
                        F,
                        bt,
                        Y,
                        Z,
                        gn,
                        P,
                        F._endClamp && "_endClamp"
                      )
                    ) || -0.001,
                  hn = 0,
                  Xn = Er;
                Xn--;

              )
                (Q = Ht[Xn]),
                  (Ee = Q.pin),
                  Ee &&
                    Q.start - Q._pinPush <= ce &&
                    !P &&
                    Q.end > 0 &&
                    ((Jn =
                      Q.end - (F._startClamp ? Math.max(0, Q.start) : Q.start)),
                    ((Ee === p && Q.start - Q._pinPush < ce) || Ee === yi) &&
                      isNaN(vn) &&
                      (hn += Jn * (1 - Q.progress)),
                    Ee === m && (dn += Jn));
              if (
                ((ce += hn),
                (k += hn),
                F._startClamp && (F._startClamp += hn),
                F._endClamp &&
                  !gr &&
                  ((F._endClamp = k || -0.001), (k = Math.min(k, zo(G, T)))),
                (U = k - ce || ((ce -= 0.01) && 0.001)),
                Wn &&
                  (Ce = lt.utils.clamp(0, 1, lt.utils.normalize(ce, k, Ue))),
                (F._pinPush = dn),
                Ve &&
                  hn &&
                  ((Jn = {}),
                  (Jn[T.a] = "+=" + hn),
                  yi && (Jn[T.p] = "-=" + Se()),
                  lt.set([Ve, we], Jn)),
                m && !(Lw && F.end >= zo(G, T)))
              )
                (Jn = Gs(m)),
                  (ae = T === hi),
                  ($ = Se()),
                  (ze = parseFloat(Pe(T.a)) + dn),
                  !gn &&
                    k > 1 &&
                    ((ct = (q ? An.scrollingElement || as : G).style),
                    (ct = {
                      style: ct,
                      value: ct["overflow" + T.a.toUpperCase()],
                    }),
                    q &&
                      Gs(fn)["overflow" + T.a.toUpperCase()] !== "scroll" &&
                      (ct.style["overflow" + T.a.toUpperCase()] = "scroll")),
                  NS(m, ye, Jn),
                  (fe = xv(m)),
                  (N = _a(m, !0)),
                  (Je = Z && Wl(G, ae ? _r : hi)()),
                  v
                    ? ((Ne = [v + T.os2, U + dn + ci]),
                      (Ne.t = ye),
                      (Xn = v === ri ? M_(m, T) + U + dn : 0),
                      Xn &&
                        (Ne.push(T.d, Xn + ci),
                        ye.style.flexBasis !== "auto" &&
                          (ye.style.flexBasis = Xn + ci)),
                      gh(Ne),
                      yi &&
                        Ht.forEach(function (rt) {
                          rt.pin === yi &&
                            rt.vars.pinSpacing !== !1 &&
                            (rt._subPinOffset = !0);
                        }),
                      Z && Se(Ue))
                    : ((Xn = M_(m, T)),
                      Xn &&
                        ye.style.flexBasis !== "auto" &&
                        (ye.style.flexBasis = Xn + ci)),
                  Z &&
                    ((oe = {
                      top: N.top + (ae ? $ - ce : Je) + ci,
                      left: N.left + (ae ? Je : $ - ce) + ci,
                      boxSizing: "border-box",
                      position: "fixed",
                    }),
                    (oe[hc] = oe["max" + Uh] = Math.ceil(N.width) + ci),
                    (oe[dc] = oe["max" + xC] = Math.ceil(N.height) + ci),
                    (oe[Hs] =
                      oe[Hs + Dp] =
                      oe[Hs + Bp] =
                      oe[Hs + Lp] =
                      oe[Hs + Ip] =
                        "0"),
                    (oe[ri] = Jn[ri]),
                    (oe[ri + Dp] = Jn[ri + Dp]),
                    (oe[ri + Bp] = Jn[ri + Bp]),
                    (oe[ri + Lp] = Jn[ri + Lp]),
                    (oe[ri + Ip] = Jn[ri + Ip]),
                    (ie = BQ(L, oe, C)),
                    gr && Se(0)),
                  r
                    ? ((it = r._initted),
                      BS(1),
                      r.render(r.duration(), !0, !0),
                      (Mt = Pe(T.a) - ze + U + dn),
                      (dt = Math.abs(U - Mt) > 1),
                      Z && dt && ie.splice(ie.length - 2, 2),
                      r.render(0, !0, !0),
                      it || r.invalidate(!0),
                      r.parent || r.totalTime(r.totalTime()),
                      BS(0))
                    : (Mt = U),
                  ct &&
                    (ct.value
                      ? (ct.style["overflow" + T.a.toUpperCase()] = ct.value)
                      : ct.style.removeProperty("overflow-" + T.a));
              else if (p && Se() && !P)
                for (N = p.parentNode; N && N !== fn; )
                  N._pinOffset && ((ce -= N._pinOffset), (k -= N._pinOffset)),
                    (N = N.parentNode);
              $e &&
                $e.forEach(function (rt) {
                  return rt.revert(!1, !0);
                }),
                (F.start = ce),
                (F.end = k),
                (Fe = de = gr ? Ue : Se()),
                !P && !gr && (Fe < Ue && Se(Ue), (F.scroll.rec = 0)),
                F.revert(!1, !0),
                (xe = Ki()),
                ge && ((re = -1), ge.restart(!0)),
                (Yi = 0),
                r &&
                  D &&
                  (r._initted || ke) &&
                  r.progress() !== ke &&
                  r.progress(ke || 0, !0).render(r.time(), !0, !0),
                (Wn || Ce !== F.progress || P || _ || (r && !r._initted)) &&
                  (r &&
                    !D &&
                    (r._initted || Ce || r.vars.immediateRender !== !1) &&
                    r.totalProgress(
                      P && ce < -0.001 && !Ce
                        ? lt.utils.normalize(ce, k, 0)
                        : Ce,
                      !0
                    ),
                  (F.progress = Wn || (Fe - ce) / U === Ce ? 0 : Ce)),
                m && v && (ye._pinOffset = Math.round(F.progress * Mt)),
                V && V.invalidate(),
                isNaN(pt) ||
                  ((pt -= lt.getProperty(J, T.p)),
                  (Ge -= lt.getProperty(Te, T.p)),
                  Av(J, T, pt),
                  Av(Ve, T, pt - (St || 0)),
                  Av(Te, T, Ge),
                  Av(we, T, Ge - (St || 0))),
                Wn && !gr && F.update(),
                c && !gr && !Le && ((Le = !0), c(F), (Le = !1));
            }
          }),
          (F.getVelocity = function () {
            return ((Se() - de) / (Ki() - ep)) * 1e3 || 0;
          }),
          (F.endAnimation = function () {
            Vd(F.callbackAnimation),
              r &&
                (V
                  ? V.progress(1)
                  : r.paused()
                  ? D || Vd(r, F.direction < 0, 1)
                  : Vd(r, r.reversed()));
          }),
          (F.labelToScroll = function (je) {
            return (
              (r &&
                r.labels &&
                (ce || F.refresh() || ce) +
                  (r.labels[je] / r.duration()) * U) ||
              0
            );
          }),
          (F.getTrailing = function (je) {
            var Tt = Ht.indexOf(F),
              ut =
                F.direction > 0 ? Ht.slice(0, Tt).reverse() : Ht.slice(Tt + 1);
            return (
              ss(je)
                ? ut.filter(function (St) {
                    return St.vars.preventOverlaps === je;
                  })
                : ut
            ).filter(function (St) {
              return F.direction > 0 ? St.end <= ce : St.start >= k;
            });
          }),
          (F.update = function (je, Tt, ut) {
            if (!(P && !ut && !je)) {
              var St = gr === !0 ? Ue : F.scroll(),
                Bn = je ? 0 : (St - ce) / U,
                bt = Bn < 0 ? 0 : Bn > 1 ? 1 : Bn || 0,
                gn = F.progress,
                Wn,
                hn,
                dn,
                sn,
                sr,
                vn,
                yi,
                Er;
              if (
                (Tt &&
                  ((de = Fe),
                  (Fe = P ? Se() : St),
                  w && ((He = pe), (pe = r && !D ? r.totalProgress() : bt))),
                x &&
                  m &&
                  !Yi &&
                  !pv &&
                  Qs &&
                  (!bt && ce < St + ((St - de) / (Ki() - ep)) * x
                    ? (bt = 1e-4)
                    : bt === 1 &&
                      k > St + ((St - de) / (Ki() - ep)) * x &&
                      (bt = 0.9999)),
                bt !== gn && F.enabled)
              ) {
                if (
                  ((Wn = F.isActive = !!bt && bt < 1),
                  (hn = !!gn && gn < 1),
                  (vn = Wn !== hn),
                  (sr = vn || !!bt != !!gn),
                  (F.direction = bt > gn ? 1 : -1),
                  (F.progress = bt),
                  sr &&
                    !Yi &&
                    ((dn = bt && !gn ? 0 : bt === 1 ? 1 : gn === 1 ? 2 : 3),
                    D &&
                      ((sn =
                        (!vn && te[dn + 1] !== "none" && te[dn + 1]) || te[dn]),
                      (Er =
                        r &&
                        (sn === "complete" || sn === "reset" || sn in r)))),
                  R &&
                    (vn || Er) &&
                    (Er || d || !r) &&
                    (qi(R)
                      ? R(F)
                      : F.getTrailing(R).forEach(function ($) {
                          return $.endAnimation();
                        })),
                  D ||
                    (V && !Yi && !pv
                      ? (V._dp._time - V._start !== V._time &&
                          V.render(V._dp._time - V._start),
                        V.resetTo
                          ? V.resetTo("totalProgress", bt, r._tTime / r._tDur)
                          : ((V.vars.totalProgress = bt),
                            V.invalidate().restart()))
                      : r && r.totalProgress(bt, !!(Yi && (xe || je)))),
                  m)
                ) {
                  if ((je && v && (ye.style[v + T.os2] = Re), !Z))
                    Ie(np(ze + Mt * bt));
                  else if (sr) {
                    if (
                      ((yi =
                        !je && bt > gn && k + 1 > St && St + 1 >= zo(G, T)),
                      C)
                    )
                      if (!je && (Wn || yi)) {
                        var Xn = _a(m, !0),
                          Jn = St - ce;
                        II(
                          m,
                          fn,
                          Xn.top + (T === hi ? Jn : 0) + ci,
                          Xn.left + (T === hi ? 0 : Jn) + ci
                        );
                      } else II(m, ye);
                    gh(Wn || yi ? ie : fe),
                      (dt && bt < 1 && Wn) ||
                        Ie(ze + (bt === 1 && !yi ? Mt : 0));
                  }
                }
                w && !Xe.tween && !Yi && !pv && ge.restart(!0),
                  a &&
                    (vn || (S && bt && (bt < 1 || !IS))) &&
                    Em(a.targets).forEach(function ($) {
                      return $.classList[Wn || S ? "add" : "remove"](
                        a.className
                      );
                    }),
                  o && !D && !je && o(F),
                  sr && !Yi
                    ? (D &&
                        (Er &&
                          (sn === "complete"
                            ? r.pause().totalProgress(1)
                            : sn === "reset"
                            ? r.restart(!0).pause()
                            : sn === "restart"
                            ? r.restart(!0)
                            : r[sn]()),
                        o && o(F)),
                      (vn || !IS) &&
                        (u && vn && LS(F, u),
                        K[dn] && LS(F, K[dn]),
                        S && (bt === 1 ? F.kill(!1, 1) : (K[dn] = 0)),
                        vn || ((dn = bt === 1 ? 1 : 3), K[dn] && LS(F, K[dn]))),
                      I &&
                        !Wn &&
                        Math.abs(F.getVelocity()) > (ip(I) ? I : 2500) &&
                        (Vd(F.callbackAnimation),
                        V
                          ? V.progress(1)
                          : Vd(r, sn === "reverse" ? 1 : !bt, 1)))
                    : D && o && !Yi && o(F);
              }
              if (Ke) {
                var N = P ? (St / P.duration()) * (P._caScrollDist || 0) : St;
                mt(N + (J._isFlipped ? 1 : 0)), Ke(N);
              }
              ft && ft((-St / P.duration()) * (P._caScrollDist || 0));
            }
          }),
          (F.enable = function (je, Tt) {
            F.enabled ||
              ((F.enabled = !0),
              Ei(G, "resize", rp),
              q || Ei(G, "scroll", Tf),
              se && Ei(n, "refreshInit", se),
              je !== !1 && ((F.progress = Ce = 0), (Fe = de = re = Se())),
              Tt !== !1 && F.refresh());
          }),
          (F.getTween = function (je) {
            return je && Xe ? Xe.tween : V;
          }),
          (F.setPositions = function (je, Tt, ut, St) {
            if (P) {
              var Bn = P.scrollTrigger,
                bt = P.duration(),
                gn = Bn.end - Bn.start;
              (je = Bn.start + (gn * je) / bt),
                (Tt = Bn.start + (gn * Tt) / bt);
            }
            F.refresh(
              !1,
              !1,
              {
                start: MI(je, ut && !!F._startClamp),
                end: MI(Tt, ut && !!F._endClamp),
              },
              St
            ),
              F.update();
          }),
          (F.adjustPinSpacing = function (je) {
            if (Ne && je) {
              var Tt = Ne.indexOf(T.d) + 1;
              (Ne[Tt] = parseFloat(Ne[Tt]) + je + ci),
                (Ne[1] = parseFloat(Ne[1]) + je + ci),
                gh(Ne);
            }
          }),
          (F.disable = function (je, Tt) {
            if (
              F.enabled &&
              (je !== !1 && F.revert(!0, !0),
              (F.enabled = F.isActive = !1),
              Tt || (V && V.pause()),
              (Ue = 0),
              et && (et.uncache = 1),
              se && wi(n, "refreshInit", se),
              ge && (ge.pause(), Xe.tween && Xe.tween.kill() && (Xe.tween = 0)),
              !q)
            ) {
              for (var ut = Ht.length; ut--; )
                if (Ht[ut].scroller === G && Ht[ut] !== F) return;
              wi(G, "resize", rp), q || wi(G, "scroll", Tf);
            }
          }),
          (F.kill = function (je, Tt) {
            F.disable(je, Tt), V && !Tt && V.kill(), l && delete Fw[l];
            var ut = Ht.indexOf(F);
            ut >= 0 && Ht.splice(ut, 1),
              ut === mr && jv > 0 && mr--,
              (ut = 0),
              Ht.forEach(function (St) {
                return St.scroller === F.scroller && (ut = 1);
              }),
              ut || gr || (F.scroll.rec = 0),
              r &&
                ((r.scrollTrigger = null),
                je && r.revert({ kill: !1 }),
                Tt || r.kill()),
              Ve &&
                [Ve, we, J, Te].forEach(function (St) {
                  return St.parentNode && St.parentNode.removeChild(St);
                }),
              Fp === F && (Fp = 0),
              m &&
                (et && (et.uncache = 1),
                (ut = 0),
                Ht.forEach(function (St) {
                  return St.pin === m && ut++;
                }),
                ut || (et.spacer = 0)),
              i.onKill && i.onKill(F);
          }),
          Ht.push(F),
          F.enable(!1, !1),
          Ct && Ct(F),
          r && r.add && !U)
        ) {
          var Et = F.update;
          (F.update = function () {
            (F.update = Et), Wt.cache++, ce || k || F.refresh();
          }),
            lt.delayedCall(0.01, F.update),
            (U = 0.01),
            (ce = k = 0);
        } else F.refresh();
        m && bQ();
      }),
      (n.register = function (i) {
        return (
          Pf ||
            ((lt = i || QU()),
            KU() && window.document && n.enable(),
            (Pf = tp)),
          Pf
        );
      }),
      (n.defaults = function (i) {
        if (i) for (var r in i) yv[r] = i[r];
        return yv;
      }),
      (n.disable = function (i, r) {
        (tp = 0),
          Ht.forEach(function (o) {
            return o[r ? "kill" : "disable"](i);
          }),
          wi(Vt, "wheel", Tf),
          wi(An, "scroll", Tf),
          clearInterval(dv),
          wi(An, "touchcancel", No),
          wi(fn, "touchstart", No),
          gv(wi, An, "pointerdown,touchstart,mousedown", wI),
          gv(wi, An, "pointerup,touchend,mouseup", EI),
          A_.kill(),
          mv(wi);
        for (var s = 0; s < Wt.length; s += 3)
          vv(wi, Wt[s], Wt[s + 1]), vv(wi, Wt[s], Wt[s + 2]);
      }),
      (n.enable = function () {
        if (
          ((Vt = window),
          (An = document),
          (as = An.documentElement),
          (fn = An.body),
          lt &&
            ((Em = lt.utils.toArray),
            (Pp = lt.utils.clamp),
            (Dw = lt.core.context || No),
            (BS = lt.core.suppressOverwrites || No),
            (gC = Vt.history.scrollRestoration || "auto"),
            (Nw = Vt.pageYOffset || 0),
            lt.core.globals("ScrollTrigger", n),
            fn))
        ) {
          (tp = 1),
            (mh = document.createElement("div")),
            (mh.style.height = "100vh"),
            (mh.style.position = "absolute"),
            sk(),
            AQ(),
            $n.register(lt),
            (n.isTouch = $n.isTouch),
            (ul =
              $n.isTouch &&
              /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
            (Iw = $n.isTouch === 1),
            Ei(Vt, "wheel", Tf),
            (mC = [Vt, An, as, fn]),
            lt.matchMedia
              ? ((n.matchMedia = function (u) {
                  var c = lt.matchMedia(),
                    d;
                  for (d in u) c.add(d, u[d]);
                  return c;
                }),
                lt.addEventListener("matchMediaInit", function () {
                  return SC();
                }),
                lt.addEventListener("matchMediaRevert", function () {
                  return ik();
                }),
                lt.addEventListener("matchMedia", function () {
                  qu(0, 1), Ic("matchMedia");
                }),
                lt.matchMedia().add("(orientation: portrait)", function () {
                  return FS(), FS;
                }))
              : console.warn("Requires GSAP 3.11.0 or later"),
            FS(),
            Ei(An, "scroll", Tf);
          var i = fn.hasAttribute("style"),
            r = fn.style,
            s = r.borderTopStyle,
            o = lt.core.Animation.prototype,
            a,
            l;
          for (
            o.revert ||
              Object.defineProperty(o, "revert", {
                value: function () {
                  return this.time(-0.01, !0);
                },
              }),
              r.borderTopStyle = "solid",
              a = _a(fn),
              hi.m = Math.round(a.top + hi.sc()) || 0,
              _r.m = Math.round(a.left + _r.sc()) || 0,
              s ? (r.borderTopStyle = s) : r.removeProperty("border-top-style"),
              i || (fn.setAttribute("style", ""), fn.removeAttribute("style")),
              dv = setInterval(bI, 250),
              lt.delayedCall(0.5, function () {
                return (pv = 0);
              }),
              Ei(An, "touchcancel", No),
              Ei(fn, "touchstart", No),
              gv(Ei, An, "pointerdown,touchstart,mousedown", wI),
              gv(Ei, An, "pointerup,touchend,mouseup", EI),
              Bw = lt.utils.checkPrefix("transform"),
              Yv.push(Bw),
              Pf = Ki(),
              A_ = lt.delayedCall(0.2, qu).pause(),
              Bf = [
                An,
                "visibilitychange",
                function () {
                  var u = Vt.innerWidth,
                    c = Vt.innerHeight;
                  An.hidden
                    ? ((xI = u), (AI = c))
                    : (xI !== u || AI !== c) && rp();
                },
                An,
                "DOMContentLoaded",
                qu,
                Vt,
                "load",
                qu,
                Vt,
                "resize",
                rp,
              ],
              mv(Ei),
              Ht.forEach(function (u) {
                return u.enable(0, 1);
              }),
              l = 0;
            l < Wt.length;
            l += 3
          )
            vv(wi, Wt[l], Wt[l + 1]), vv(wi, Wt[l], Wt[l + 2]);
        }
      }),
      (n.config = function (i) {
        "limitCallbacks" in i && (IS = !!i.limitCallbacks);
        var r = i.syncInterval;
        (r && clearInterval(dv)) || ((dv = r) && setInterval(bI, r)),
          "ignoreMobileResize" in i &&
            (Iw = n.isTouch === 1 && i.ignoreMobileResize),
          "autoRefreshEvents" in i &&
            (mv(wi) || mv(Ei, i.autoRefreshEvents || "none"),
            (JU = (i.autoRefreshEvents + "").indexOf("resize") === -1));
      }),
      (n.scrollerProxy = function (i, r) {
        var s = Lr(i),
          o = Wt.indexOf(s),
          a = Pc(s);
        ~o && Wt.splice(o, a ? 6 : 2),
          r && (a ? Jo.unshift(Vt, r, fn, r, as, r) : Jo.unshift(s, r));
      }),
      (n.clearMatchMedia = function (i) {
        Ht.forEach(function (r) {
          return r._ctx && r._ctx.query === i && r._ctx.kill(!0, !0);
        });
      }),
      (n.isInViewport = function (i, r, s) {
        var o = (ss(i) ? Lr(i) : i).getBoundingClientRect(),
          a = o[s ? hc : dc] * r || 0;
        return s
          ? o.right - a > 0 && o.left + a < Vt.innerWidth
          : o.bottom - a > 0 && o.top + a < Vt.innerHeight;
      }),
      (n.positionInViewport = function (i, r, s) {
        ss(i) && (i = Lr(i));
        var o = i.getBoundingClientRect(),
          a = o[s ? hc : dc],
          l =
            r == null
              ? a / 2
              : r in w_
              ? w_[r] * a
              : ~r.indexOf("%")
              ? (parseFloat(r) * a) / 100
              : parseFloat(r) || 0;
        return s ? (o.left + l) / Vt.innerWidth : (o.top + l) / Vt.innerHeight;
      }),
      (n.killAll = function (i) {
        if (
          (Ht.slice(0).forEach(function (s) {
            return s.vars.id !== "ScrollSmoother" && s.kill();
          }),
          i !== !0)
        ) {
          var r = Bc.killAll || [];
          (Bc = {}),
            r.forEach(function (s) {
              return s();
            });
        }
      }),
      n
    );
  })();
Gt.version = "3.13.0";
Gt.saveStyles = function (n) {
  return n
    ? Em(n).forEach(function (e) {
        if (e && e.style) {
          var t = is.indexOf(e);
          t >= 0 && is.splice(t, 5),
            is.push(
              e,
              e.style.cssText,
              e.getBBox && e.getAttribute("transform"),
              lt.core.getCache(e),
              Dw()
            );
        }
      })
    : is;
};
Gt.revert = function (n, e) {
  return SC(!n, e);
};
Gt.create = function (n, e) {
  return new Gt(n, e);
};
Gt.refresh = function (n) {
  return n ? rp(!0) : (Pf || Gt.register()) && qu(!0);
};
Gt.update = function (n) {
  return ++Wt.cache && Pa(n === !0 ? 2 : 0);
};
Gt.clearScrollMemory = rk;
Gt.maxScroll = function (n, e) {
  return zo(n, e ? _r : hi);
};
Gt.getScrollFunc = function (n, e) {
  return Wl(Lr(n), e ? _r : hi);
};
Gt.getById = function (n) {
  return Fw[n];
};
Gt.getAll = function () {
  return Ht.filter(function (n) {
    return n.vars.id !== "ScrollSmoother";
  });
};
Gt.isScrolling = function () {
  return !!Qs;
};
Gt.snapDirectional = AC;
Gt.addEventListener = function (n, e) {
  var t = Bc[n] || (Bc[n] = []);
  ~t.indexOf(e) || t.push(e);
};
Gt.removeEventListener = function (n, e) {
  var t = Bc[n],
    i = t && t.indexOf(e);
  i >= 0 && t.splice(i, 1);
};
Gt.batch = function (n, e) {
  var t = [],
    i = {},
    r = e.interval || 0.016,
    s = e.batchMax || 1e9,
    o = function (u, c) {
      var d = [],
        p = [],
        m = lt
          .delayedCall(r, function () {
            c(d, p), (d = []), (p = []);
          })
          .pause();
      return function (v) {
        d.length || m.restart(!0),
          d.push(v.trigger),
          p.push(v),
          s <= d.length && m.progress(1);
      };
    },
    a;
  for (a in e)
    i[a] =
      a.substr(0, 2) === "on" && qi(e[a]) && a !== "onRefreshInit"
        ? o(a, e[a])
        : e[a];
  return (
    qi(s) &&
      ((s = s()),
      Ei(Gt, "refresh", function () {
        return (s = e.batchMax());
      })),
    Em(n).forEach(function (l) {
      var u = {};
      for (a in i) u[a] = i[a];
      (u.trigger = l), t.push(Gt.create(u));
    }),
    t
  );
};
var LI = function (e, t, i, r) {
    return (
      t > r ? e(r) : t < 0 && e(0),
      i > r ? (r - t) / (i - t) : i < 0 ? t / (t - i) : 1
    );
  },
  OS = function n(e, t) {
    t === !0
      ? e.style.removeProperty("touch-action")
      : (e.style.touchAction =
          t === !0
            ? "auto"
            : t
            ? "pan-" + t + ($n.isTouch ? " pinch-zoom" : "")
            : "none"),
      e === as && n(fn, t);
  },
  Sv = { auto: 1, scroll: 1 },
  DQ = function (e) {
    var t = e.event,
      i = e.target,
      r = e.axis,
      s = (t.changedTouches ? t.changedTouches[0] : t).target,
      o = s._gsap || lt.core.getCache(s),
      a = Ki(),
      l;
    if (!o._isScrollT || a - o._isScrollT > 2e3) {
      for (
        ;
        s &&
        s !== fn &&
        ((s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth) ||
          !(Sv[(l = Gs(s)).overflowY] || Sv[l.overflowX]));

      )
        s = s.parentNode;
      (o._isScroll =
        s &&
        s !== i &&
        !Pc(s) &&
        (Sv[(l = Gs(s)).overflowY] || Sv[l.overflowX])),
        (o._isScrollT = a);
    }
    (o._isScroll || r === "x") && (t.stopPropagation(), (t._gsapAllow = !0));
  },
  ak = function (e, t, i, r) {
    return $n.create({
      target: e,
      capture: !0,
      debounce: !1,
      lockAxis: !0,
      type: t,
      onWheel: (r = r && DQ),
      onPress: r,
      onDrag: r,
      onScroll: r,
      onEnable: function () {
        return i && Ei(An, $n.eventTypes[0], NI, !1, !0);
      },
      onDisable: function () {
        return wi(An, $n.eventTypes[0], NI, !0);
      },
    });
  },
  LQ = /(input|label|select|textarea)/i,
  FI,
  NI = function (e) {
    var t = LQ.test(e.target.tagName);
    (t || FI) && ((e._gsapAllow = !0), (FI = t));
  },
  FQ = function (e) {
    Nu(e) || (e = {}),
      (e.preventDefault = e.isNormalizer = e.allowClicks = !0),
      e.type || (e.type = "wheel,touch"),
      (e.debounce = !!e.debounce),
      (e.id = e.id || "normalizer");
    var t = e,
      i = t.normalizeScrollX,
      r = t.momentum,
      s = t.allowNestedScroll,
      o = t.onRelease,
      a,
      l,
      u = Lr(e.target) || as,
      c = lt.core.globals().ScrollSmoother,
      d = c && c.get(),
      p =
        ul &&
        ((e.content && Lr(e.content)) ||
          (d && e.content !== !1 && !d.smooth() && d.content())),
      m = Wl(u, hi),
      v = Wl(u, _r),
      _ = 1,
      x =
        ($n.isTouch && Vt.visualViewport
          ? Vt.visualViewport.scale * Vt.visualViewport.width
          : Vt.outerWidth) / Vt.innerWidth,
      g = 0,
      A = qi(r)
        ? function () {
            return r(a);
          }
        : function () {
            return r || 2.8;
          },
      S,
      w,
      C = ak(u, e.type, !0, s),
      b = function () {
        return (w = !1);
      },
      P = No,
      I = No,
      R = function () {
        (l = zo(u, hi)),
          (I = Pp(ul ? 1 : 0, l)),
          i && (P = Pp(0, zo(u, _r))),
          (S = pc);
      },
      T = function () {
        (p._gsap.y = np(parseFloat(p._gsap.y) + m.offset) + "px"),
          (p.style.transform =
            "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
            parseFloat(p._gsap.y) +
            ", 0, 1)"),
          (m.offset = m.cacheID = 0);
      },
      D = function () {
        if (w) {
          requestAnimationFrame(b);
          var O = np(a.deltaY / 2),
            Y = I(m.v - O);
          if (p && Y !== m.v + m.offset) {
            m.offset = Y - m.v;
            var F = np((parseFloat(p && p._gsap.y) || 0) - m.offset);
            (p.style.transform =
              "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
              F +
              ", 0, 1)"),
              (p._gsap.y = F + "px"),
              (m.cacheID = Wt.cache),
              Pa();
          }
          return !0;
        }
        m.offset && T(), (w = !0);
      },
      G,
      W,
      q,
      Z,
      K = function () {
        R(),
          G.isActive() &&
            G.vars.scrollY > l &&
            (m() > l ? G.progress(1) && m(l) : G.resetTo("scrollY", l));
      };
    return (
      p && lt.set(p, { y: "+=0" }),
      (e.ignoreCheck = function (te) {
        return (
          (ul && te.type === "touchmove" && D()) ||
          (_ > 1.05 && te.type !== "touchstart") ||
          a.isGesturing ||
          (te.touches && te.touches.length > 1)
        );
      }),
      (e.onPress = function () {
        w = !1;
        var te = _;
        (_ = np(((Vt.visualViewport && Vt.visualViewport.scale) || 1) / x)),
          G.pause(),
          te !== _ && OS(u, _ > 1.01 ? !0 : i ? !1 : "x"),
          (W = v()),
          (q = m()),
          R(),
          (S = pc);
      }),
      (e.onRelease = e.onGestureStart =
        function (te, O) {
          if ((m.offset && T(), !O)) Z.restart(!0);
          else {
            Wt.cache++;
            var Y = A(),
              F,
              se;
            i &&
              ((F = v()),
              (se = F + (Y * 0.05 * -te.velocityX) / 0.227),
              (Y *= LI(v, F, se, zo(u, _r))),
              (G.vars.scrollX = P(se))),
              (F = m()),
              (se = F + (Y * 0.05 * -te.velocityY) / 0.227),
              (Y *= LI(m, F, se, zo(u, hi))),
              (G.vars.scrollY = I(se)),
              G.invalidate().duration(Y).play(0.01),
              ((ul && G.vars.scrollY >= l) || F >= l - 1) &&
                lt.to({}, { onUpdate: K, duration: Y });
          }
          o && o(te);
        }),
      (e.onWheel = function () {
        G._ts && G.pause(), Ki() - g > 1e3 && ((S = 0), (g = Ki()));
      }),
      (e.onChange = function (te, O, Y, F, se) {
        if (
          (pc !== S && R(),
          O && i && v(P(F[2] === O ? W + (te.startX - te.x) : v() + O - F[1])),
          Y)
        ) {
          m.offset && T();
          var Me = se[2] === Y,
            De = Me ? q + te.startY - te.y : m() + Y - se[1],
            re = I(De);
          Me && De !== re && (q += re - De), m(re);
        }
        (Y || O) && Pa();
      }),
      (e.onEnable = function () {
        OS(u, i ? !1 : "x"),
          Gt.addEventListener("refresh", K),
          Ei(Vt, "resize", K),
          m.smooth &&
            ((m.target.style.scrollBehavior = "auto"),
            (m.smooth = v.smooth = !1)),
          C.enable();
      }),
      (e.onDisable = function () {
        OS(u, !0),
          wi(Vt, "resize", K),
          Gt.removeEventListener("refresh", K),
          C.kill();
      }),
      (e.lockAxis = e.lockAxis !== !1),
      (a = new $n(e)),
      (a.iOS = ul),
      ul && !m() && m(1),
      ul && lt.ticker.add(No),
      (Z = a._dc),
      (G = lt.to(a, {
        ease: "power4",
        paused: !0,
        inherit: !1,
        scrollX: i ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
          scrollY: ok(m, m(), function () {
            return G.pause();
          }),
        },
        onUpdate: Pa,
        onComplete: Z.vars.onComplete,
      })),
      a
    );
  };
Gt.sort = function (n) {
  if (qi(n)) return Ht.sort(n);
  var e = Vt.pageYOffset || 0;
  return (
    Gt.getAll().forEach(function (t) {
      return (t._sortY = t.trigger
        ? e + t.trigger.getBoundingClientRect().top
        : t.start + Vt.innerHeight);
    }),
    Ht.sort(
      n ||
        function (t, i) {
          return (
            (t.vars.refreshPriority || 0) * -1e6 +
            (t.vars.containerAnimation ? 1e6 : t._sortY) -
            ((i.vars.containerAnimation ? 1e6 : i._sortY) +
              (i.vars.refreshPriority || 0) * -1e6)
          );
        }
    )
  );
};
Gt.observe = function (n) {
  return new $n(n);
};
Gt.normalizeScroll = function (n) {
  if (typeof n > "u") return hr;
  if (n === !0 && hr) return hr.enable();
  if (n === !1) {
    hr && hr.kill(), (hr = n);
    return;
  }
  var e = n instanceof $n ? n : FQ(n);
  return hr && hr.target === e.target && hr.kill(), Pc(e.target) && (hr = e), e;
};
Gt.core = {
  _getVelocityProp: Pw,
  _inputObserver: ak,
  _scrollers: Wt,
  _proxies: Jo,
  bridge: {
    ss: function () {
      Qs || Ic("scrollStart"), (Qs = Ki());
    },
    ref: function () {
      return Yi;
    },
  },
};
QU() && lt.registerPlugin(Gt);
const lk = j.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: "never",
  }),
  Nx = j.createContext({});
function NQ() {
  return j.useContext(Nx).visualElement;
}
const MC = j.createContext(null),
  Ox = typeof document < "u",
  OI = Ox ? j.useLayoutEffect : j.useEffect,
  uk = j.createContext({ strict: !1 });
function OQ(n, e, t, i) {
  const r = NQ(),
    s = j.useContext(uk),
    o = j.useContext(MC),
    a = j.useContext(lk).reducedMotion,
    l = j.useRef();
  (i = i || s.renderer),
    !l.current &&
      i &&
      (l.current = i(n, {
        visualState: e,
        parent: r,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a,
      }));
  const u = l.current;
  return (
    j.useInsertionEffect(() => {
      u && u.update(t, o);
    }),
    OI(() => {
      u && u.render();
    }),
    j.useEffect(() => {
      u && u.updateFeatures();
    }),
    (window.HandoffAppearAnimations ? OI : j.useEffect)(() => {
      u && u.animationState && u.animationState.animateChanges();
    }),
    u
  );
}
function qf(n) {
  return (
    typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
  );
}
function UQ(n, e, t) {
  return j.useCallback(
    (i) => {
      i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == "function" ? t(i) : qf(t) && (t.current = i));
    },
    [e]
  );
}
function Cm(n) {
  return typeof n == "string" || Array.isArray(n);
}
function Ux(n) {
  return typeof n == "object" && typeof n.start == "function";
}
const wC = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  EC = ["initial", ...wC];
function kx(n) {
  return Ux(n.animate) || EC.some((e) => Cm(n[e]));
}
function ck(n) {
  return !!(kx(n) || n.variants);
}
function kQ(n, e) {
  if (kx(n)) {
    const { initial: t, animate: i } = n;
    return {
      initial: t === !1 || Cm(t) ? t : void 0,
      animate: Cm(i) ? i : void 0,
    };
  }
  return n.inherit !== !1 ? e : {};
}
function zQ(n) {
  const { initial: e, animate: t } = kQ(n, j.useContext(Nx));
  return j.useMemo(() => ({ initial: e, animate: t }), [UI(e), UI(t)]);
}
function UI(n) {
  return Array.isArray(n) ? n.join(" ") : n;
}
const kI = {
    animation: [
      "animate",
      "exit",
      "variants",
      "whileHover",
      "whileTap",
      "whileFocus",
      "whileDrag",
      "whileInView",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  bm = {};
for (const n in kI) bm[n] = { isEnabled: (e) => kI[n].some((t) => !!e[t]) };
function HQ(n) {
  for (const e in n) bm[e] = { ...bm[e], ...n[e] };
}
function fk(n) {
  const e = j.useRef(null);
  return e.current === null && (e.current = n()), e.current;
}
const Np = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
let GQ = 1;
function VQ() {
  return fk(() => {
    if (Np.hasEverUpdated) return GQ++;
  });
}
const hk = j.createContext({}),
  dk = j.createContext({}),
  WQ = Symbol.for("motionComponentSymbol");
function XQ({
  preloadedFeatures: n,
  createVisualElement: e,
  useRender: t,
  useVisualState: i,
  Component: r,
}) {
  n && HQ(n);
  function s(a, l) {
    let u;
    const c = { ...j.useContext(lk), ...a, layoutId: JQ(a) },
      { isStatic: d } = c,
      p = zQ(a),
      m = d ? void 0 : VQ(),
      v = i(a, d);
    if (!d && Ox) {
      p.visualElement = OQ(r, v, c, e);
      const _ = j.useContext(dk),
        x = j.useContext(uk).strict;
      p.visualElement && (u = p.visualElement.loadFeatures(c, x, n, m, _));
    }
    return j.createElement(
      Nx.Provider,
      { value: p },
      u && p.visualElement
        ? j.createElement(u, { visualElement: p.visualElement, ...c })
        : null,
      t(r, a, m, UQ(v, p.visualElement, l), v, d, p.visualElement)
    );
  }
  const o = j.forwardRef(s);
  return (o[WQ] = r), o;
}
function JQ({ layoutId: n }) {
  const e = j.useContext(hk).id;
  return e && n !== void 0 ? e + "-" + n : n;
}
function jQ(n) {
  function e(i, r = {}) {
    return XQ(n(i, r));
  }
  if (typeof Proxy > "u") return e;
  const t = new Map();
  return new Proxy(e, {
    get: (i, r) => (t.has(r) || t.set(r, e(r)), t.get(r)),
  });
}
const YQ = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function TC(n) {
  return typeof n != "string" || n.includes("-")
    ? !1
    : !!(YQ.indexOf(n) > -1 || /[A-Z]/.test(n));
}
const E_ = {};
function KQ(n) {
  Object.assign(E_, n);
}
const zx = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  Gc = new Set(zx);
function pk(n, { layout: e, layoutId: t }) {
  return (
    Gc.has(n) ||
    n.startsWith("origin") ||
    ((e || t !== void 0) && (!!E_[n] || n === "opacity"))
  );
}
const Kr = (n) => !!(n && n.getVelocity),
  QQ = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  ZQ = zx.length;
function qQ(
  n,
  { enableHardwareAcceleration: e = !0, allowTransformNone: t = !0 },
  i,
  r
) {
  let s = "";
  for (let o = 0; o < ZQ; o++) {
    const a = zx[o];
    if (n[a] !== void 0) {
      const l = QQ[a] || a;
      s += `${l}(${n[a]}) `;
    }
  }
  return (
    e && !n.z && (s += "translateZ(0)"),
    (s = s.trim()),
    r ? (s = r(n, i ? "" : s)) : t && i && (s = "none"),
    s
  );
}
const mk = (n) => (e) => typeof e == "string" && e.startsWith(n),
  gk = mk("--"),
  Uw = mk("var(--"),
  $Q = (n, e) => (e && typeof n == "number" ? e.transform(n) : n),
  kh = (n, e, t) => Math.min(Math.max(t, n), e),
  Vc = {
    test: (n) => typeof n == "number",
    parse: parseFloat,
    transform: (n) => n,
  },
  Op = { ...Vc, transform: (n) => kh(0, 1, n) },
  Mv = { ...Vc, default: 1 },
  Up = (n) => Math.round(n * 1e5) / 1e5,
  Rm = /(-)?([\d]*\.?[\d])+/g,
  kw =
    /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
  eZ =
    /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function ig(n) {
  return typeof n == "string";
}
const rg = (n) => ({
    test: (e) => ig(e) && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  cl = rg("deg"),
  jo = rg("%"),
  wt = rg("px"),
  tZ = rg("vh"),
  nZ = rg("vw"),
  zI = {
    ...jo,
    parse: (n) => jo.parse(n) / 100,
    transform: (n) => jo.transform(n * 100),
  },
  HI = { ...Vc, transform: Math.round },
  vk = {
    borderWidth: wt,
    borderTopWidth: wt,
    borderRightWidth: wt,
    borderBottomWidth: wt,
    borderLeftWidth: wt,
    borderRadius: wt,
    radius: wt,
    borderTopLeftRadius: wt,
    borderTopRightRadius: wt,
    borderBottomRightRadius: wt,
    borderBottomLeftRadius: wt,
    width: wt,
    maxWidth: wt,
    height: wt,
    maxHeight: wt,
    size: wt,
    top: wt,
    right: wt,
    bottom: wt,
    left: wt,
    padding: wt,
    paddingTop: wt,
    paddingRight: wt,
    paddingBottom: wt,
    paddingLeft: wt,
    margin: wt,
    marginTop: wt,
    marginRight: wt,
    marginBottom: wt,
    marginLeft: wt,
    rotate: cl,
    rotateX: cl,
    rotateY: cl,
    rotateZ: cl,
    scale: Mv,
    scaleX: Mv,
    scaleY: Mv,
    scaleZ: Mv,
    skew: cl,
    skewX: cl,
    skewY: cl,
    distance: wt,
    translateX: wt,
    translateY: wt,
    translateZ: wt,
    x: wt,
    y: wt,
    z: wt,
    perspective: wt,
    transformPerspective: wt,
    opacity: Op,
    originX: zI,
    originY: zI,
    originZ: wt,
    zIndex: HI,
    fillOpacity: Op,
    strokeOpacity: Op,
    numOctaves: HI,
  };
function CC(n, e, t, i) {
  const { style: r, vars: s, transform: o, transformOrigin: a } = n;
  let l = !1,
    u = !1,
    c = !0;
  for (const d in e) {
    const p = e[d];
    if (gk(d)) {
      s[d] = p;
      continue;
    }
    const m = vk[d],
      v = $Q(p, m);
    if (Gc.has(d)) {
      if (((l = !0), (o[d] = v), !c)) continue;
      p !== (m.default || 0) && (c = !1);
    } else d.startsWith("origin") ? ((u = !0), (a[d] = v)) : (r[d] = v);
  }
  if (
    (e.transform ||
      (l || i
        ? (r.transform = qQ(n.transform, t, c, i))
        : r.transform && (r.transform = "none")),
    u)
  ) {
    const { originX: d = "50%", originY: p = "50%", originZ: m = 0 } = a;
    r.transformOrigin = `${d} ${p} ${m}`;
  }
}
const bC = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function yk(n, e, t) {
  for (const i in e) !Kr(e[i]) && !pk(i, t) && (n[i] = e[i]);
}
function iZ({ transformTemplate: n }, e, t) {
  return j.useMemo(() => {
    const i = bC();
    return (
      CC(i, e, { enableHardwareAcceleration: !t }, n),
      Object.assign({}, i.vars, i.style)
    );
  }, [e]);
}
function rZ(n, e, t) {
  const i = n.style || {},
    r = {};
  return (
    yk(r, i, n),
    Object.assign(r, iZ(n, e, t)),
    n.transformValues ? n.transformValues(r) : r
  );
}
function sZ(n, e, t) {
  const i = {},
    r = rZ(n, e, t);
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((i.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none"),
      (r.touchAction =
        n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (i.tabIndex = 0),
    (i.style = r),
    i
  );
}
const oZ = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport",
]);
function T_(n) {
  return (
    n.startsWith("while") ||
    (n.startsWith("drag") && n !== "draggable") ||
    n.startsWith("layout") ||
    n.startsWith("onTap") ||
    n.startsWith("onPan") ||
    oZ.has(n)
  );
}
let _k = (n) => !T_(n);
function aZ(n) {
  n && (_k = (e) => (e.startsWith("on") ? !T_(e) : n(e)));
}
try {
  aZ(require("@emotion/is-prop-valid").default);
} catch {}
function lZ(n, e, t) {
  const i = {};
  for (const r in n)
    (r === "values" && typeof n.values == "object") ||
      ((_k(r) ||
        (t === !0 && T_(r)) ||
        (!e && !T_(r)) ||
        (n.draggable && r.startsWith("onDrag"))) &&
        (i[r] = n[r]));
  return i;
}
function GI(n, e, t) {
  return typeof n == "string" ? n : wt.transform(e + t * n);
}
function uZ(n, e, t) {
  const i = GI(e, n.x, n.width),
    r = GI(t, n.y, n.height);
  return `${i} ${r}`;
}
const cZ = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  fZ = { offset: "strokeDashoffset", array: "strokeDasharray" };
function hZ(n, e, t = 1, i = 0, r = !0) {
  n.pathLength = 1;
  const s = r ? cZ : fZ;
  n[s.offset] = wt.transform(-i);
  const o = wt.transform(e),
    a = wt.transform(t);
  n[s.array] = `${o} ${a}`;
}
function RC(
  n,
  {
    attrX: e,
    attrY: t,
    originX: i,
    originY: r,
    pathLength: s,
    pathSpacing: o = 1,
    pathOffset: a = 0,
    ...l
  },
  u,
  c,
  d
) {
  if ((CC(n, l, u, d), c)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  (n.attrs = n.style), (n.style = {});
  const { attrs: p, style: m, dimensions: v } = n;
  p.transform && (v && (m.transform = p.transform), delete p.transform),
    v &&
      (i !== void 0 || r !== void 0 || m.transform) &&
      (m.transformOrigin = uZ(
        v,
        i !== void 0 ? i : 0.5,
        r !== void 0 ? r : 0.5
      )),
    e !== void 0 && (p.x = e),
    t !== void 0 && (p.y = t),
    s !== void 0 && hZ(p, s, o, a, !1);
}
const xk = () => ({ ...bC(), attrs: {} }),
  PC = (n) => typeof n == "string" && n.toLowerCase() === "svg";
function dZ(n, e, t, i) {
  const r = j.useMemo(() => {
    const s = xk();
    return (
      RC(s, e, { enableHardwareAcceleration: !1 }, PC(i), n.transformTemplate),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (n.style) {
    const s = {};
    yk(s, n.style, n), (r.style = { ...s, ...r.style });
  }
  return r;
}
function pZ(n = !1) {
  return (t, i, r, s, { latestValues: o }, a) => {
    const u = (TC(t) ? dZ : sZ)(i, o, a, t),
      d = { ...lZ(i, typeof t == "string", n), ...u, ref: s },
      { children: p } = i,
      m = j.useMemo(() => (Kr(p) ? p.get() : p), [p]);
    return (
      r && (d["data-projection-id"] = r),
      j.createElement(t, { ...d, children: m })
    );
  };
}
const BC = (n) => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function Ak(n, { style: e, vars: t }, i, r) {
  Object.assign(n.style, e, r && r.getProjectionStyles(i));
  for (const s in t) n.style.setProperty(s, t[s]);
}
const Sk = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function Mk(n, e, t, i) {
  Ak(n, e, void 0, i);
  for (const r in e.attrs) n.setAttribute(Sk.has(r) ? r : BC(r), e.attrs[r]);
}
function IC(n, e) {
  const { style: t } = n,
    i = {};
  for (const r in t)
    (Kr(t[r]) || (e.style && Kr(e.style[r])) || pk(r, n)) && (i[r] = t[r]);
  return i;
}
function wk(n, e) {
  const t = IC(n, e);
  for (const i in n)
    if (Kr(n[i]) || Kr(e[i])) {
      const r = i === "x" || i === "y" ? "attr" + i.toUpperCase() : i;
      t[r] = n[i];
    }
  return t;
}
function DC(n, e, t, i = {}, r = {}) {
  return (
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    e
  );
}
const C_ = (n) => Array.isArray(n),
  mZ = (n) => !!(n && typeof n == "object" && n.mix && n.toValue),
  gZ = (n) => (C_(n) ? n[n.length - 1] || 0 : n);
function Qv(n) {
  const e = Kr(n) ? n.get() : n;
  return mZ(e) ? e.toValue() : e;
}
function vZ(
  { scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t },
  i,
  r,
  s
) {
  const o = { latestValues: yZ(i, r, s, n), renderState: e() };
  return t && (o.mount = (a) => t(i, a, o)), o;
}
const Ek = (n) => (e, t) => {
  const i = j.useContext(Nx),
    r = j.useContext(MC),
    s = () => vZ(n, e, i, r);
  return t ? s() : fk(s);
};
function yZ(n, e, t, i) {
  const r = {},
    s = i(n, {});
  for (const p in s) r[p] = Qv(s[p]);
  let { initial: o, animate: a } = n;
  const l = kx(n),
    u = ck(n);
  e &&
    u &&
    !l &&
    n.inherit !== !1 &&
    (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let c = t ? t.initial === !1 : !1;
  c = c || o === !1;
  const d = c ? a : o;
  return (
    d &&
      typeof d != "boolean" &&
      !Ux(d) &&
      (Array.isArray(d) ? d : [d]).forEach((m) => {
        const v = DC(n, m);
        if (!v) return;
        const { transitionEnd: _, transition: x, ...g } = v;
        for (const A in g) {
          let S = g[A];
          if (Array.isArray(S)) {
            const w = c ? S.length - 1 : 0;
            S = S[w];
          }
          S !== null && (r[A] = S);
        }
        for (const A in _) r[A] = _[A];
      }),
    r
  );
}
const _Z = {
    useVisualState: Ek({
      scrapeMotionValuesFromProps: wk,
      createRenderState: xk,
      onMount: (n, e, { renderState: t, latestValues: i }) => {
        try {
          t.dimensions =
            typeof e.getBBox == "function"
              ? e.getBBox()
              : e.getBoundingClientRect();
        } catch {
          t.dimensions = { x: 0, y: 0, width: 0, height: 0 };
        }
        RC(
          t,
          i,
          { enableHardwareAcceleration: !1 },
          PC(e.tagName),
          n.transformTemplate
        ),
          Mk(e, t);
      },
    }),
  },
  xZ = {
    useVisualState: Ek({
      scrapeMotionValuesFromProps: IC,
      createRenderState: bC,
    }),
  };
function AZ(n, { forwardMotionProps: e = !1 }, t, i) {
  return {
    ...(TC(n) ? _Z : xZ),
    preloadedFeatures: t,
    useRender: pZ(e),
    createVisualElement: i,
    Component: n,
  };
}
function Ea(n, e, t, i = { passive: !0 }) {
  return n.addEventListener(e, t, i), () => n.removeEventListener(e, t);
}
const Tk = (n) =>
  n.pointerType === "mouse"
    ? typeof n.button != "number" || n.button <= 0
    : n.isPrimary !== !1;
function Hx(n, e = "page") {
  return { point: { x: n[e + "X"], y: n[e + "Y"] } };
}
const SZ = (n) => (e) => Tk(e) && n(e, Hx(e));
function Ba(n, e, t, i) {
  return Ea(n, e, SZ(t), i);
}
const MZ = (n, e) => (t) => e(n(t)),
  Nl = (...n) => n.reduce(MZ);
function Ck(n) {
  let e = null;
  return () => {
    const t = () => {
      e = null;
    };
    return e === null ? ((e = n), t) : !1;
  };
}
const VI = Ck("dragHorizontal"),
  WI = Ck("dragVertical");
function bk(n) {
  let e = !1;
  if (n === "y") e = WI();
  else if (n === "x") e = VI();
  else {
    const t = VI(),
      i = WI();
    t && i
      ? (e = () => {
          t(), i();
        })
      : (t && t(), i && i());
  }
  return e;
}
function Rk() {
  const n = bk(!0);
  return n ? (n(), !1) : !0;
}
class eu {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
function XI(n, e) {
  const t = "pointer" + (e ? "enter" : "leave"),
    i = "onHover" + (e ? "Start" : "End"),
    r = (s, o) => {
      if (s.type === "touch" || Rk()) return;
      const a = n.getProps();
      n.animationState &&
        a.whileHover &&
        n.animationState.setActive("whileHover", e),
        a[i] && a[i](s, o);
    };
  return Ba(n.current, t, r, { passive: !n.getProps()[i] });
}
class wZ extends eu {
  mount() {
    this.unmount = Nl(XI(this.node, !0), XI(this.node, !1));
  }
  unmount() {}
}
class EZ extends eu {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = Nl(
      Ea(this.node.current, "focus", () => this.onFocus()),
      Ea(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
const Pk = (n, e) => (e ? (n === e ? !0 : Pk(n, e.parentElement)) : !1),
  Zs = (n) => n;
function US(n, e) {
  if (!e) return;
  const t = new PointerEvent("pointer" + n);
  e(t, Hx(t));
}
class TZ extends eu {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = Zs),
      (this.removeEndListeners = Zs),
      (this.removeAccessibleListeners = Zs),
      (this.startPointerPress = (e, t) => {
        if ((this.removeEndListeners(), this.isPressing)) return;
        const i = this.node.getProps(),
          s = Ba(
            window,
            "pointerup",
            (a, l) => {
              if (!this.checkPressEnd()) return;
              const { onTap: u, onTapCancel: c } = this.node.getProps();
              Pk(this.node.current, a.target) ? u && u(a, l) : c && c(a, l);
            },
            { passive: !(i.onTap || i.onPointerUp) }
          ),
          o = Ba(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
            passive: !(i.onTapCancel || i.onPointerCancel),
          });
        (this.removeEndListeners = Nl(s, o)), this.startPress(e, t);
      }),
      (this.startAccessiblePress = () => {
        const e = (s) => {
            if (s.key !== "Enter" || this.isPressing) return;
            const o = (a) => {
              a.key !== "Enter" ||
                !this.checkPressEnd() ||
                US("up", this.node.getProps().onTap);
            };
            this.removeEndListeners(),
              (this.removeEndListeners = Ea(this.node.current, "keyup", o)),
              US("down", (a, l) => {
                this.startPress(a, l);
              });
          },
          t = Ea(this.node.current, "keydown", e),
          i = () => {
            this.isPressing && US("cancel", (s, o) => this.cancelPress(s, o));
          },
          r = Ea(this.node.current, "blur", i);
        this.removeAccessibleListeners = Nl(t, r);
      });
  }
  startPress(e, t) {
    this.isPressing = !0;
    const { onTapStart: i, whileTap: r } = this.node.getProps();
    r &&
      this.node.animationState &&
      this.node.animationState.setActive("whileTap", !0),
      i && i(e, t);
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive("whileTap", !1),
      !Rk()
    );
  }
  cancelPress(e, t) {
    if (!this.checkPressEnd()) return;
    const { onTapCancel: i } = this.node.getProps();
    i && i(e, t);
  }
  mount() {
    const e = this.node.getProps(),
      t = Ba(this.node.current, "pointerdown", this.startPointerPress, {
        passive: !(e.onTapStart || e.onPointerStart),
      }),
      i = Ea(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Nl(t, i);
  }
  unmount() {
    this.removeStartListeners(),
      this.removeEndListeners(),
      this.removeAccessibleListeners();
  }
}
const zw = new WeakMap(),
  kS = new WeakMap(),
  CZ = (n) => {
    const e = zw.get(n.target);
    e && e(n);
  },
  bZ = (n) => {
    n.forEach(CZ);
  };
function RZ({ root: n, ...e }) {
  const t = n || document;
  kS.has(t) || kS.set(t, {});
  const i = kS.get(t),
    r = JSON.stringify(e);
  return i[r] || (i[r] = new IntersectionObserver(bZ, { root: n, ...e })), i[r];
}
function PZ(n, e, t) {
  const i = RZ(e);
  return (
    zw.set(n, t),
    i.observe(n),
    () => {
      zw.delete(n), i.unobserve(n);
    }
  );
}
const BZ = { some: 0, all: 1 };
class IZ extends eu {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  viewportFallback() {
    requestAnimationFrame(() => {
      this.hasEnteredView = !0;
      const { onViewportEnter: e } = this.node.getProps();
      e && e(null),
        this.node.animationState &&
          this.node.animationState.setActive("whileInView", !0);
    });
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: i, amount: r = "some", once: s, fallback: o = !0 } = e;
    if (typeof IntersectionObserver > "u") {
      o && this.viewportFallback();
      return;
    }
    const a = {
        root: t ? t.current : void 0,
        rootMargin: i,
        threshold: typeof r == "number" ? r : BZ[r],
      },
      l = (u) => {
        const { isIntersecting: c } = u;
        if (
          this.isInView === c ||
          ((this.isInView = c), s && !c && this.hasEnteredView)
        )
          return;
        c && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", c);
        const { onViewportEnter: d, onViewportLeave: p } = this.node.getProps(),
          m = c ? d : p;
        m && m(u);
      };
    return PZ(this.node.current, a, l);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(DZ(e, t)) && this.startObserver();
  }
  unmount() {}
}
function DZ({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t];
}
const LZ = {
  inView: { Feature: IZ },
  tap: { Feature: TZ },
  focus: { Feature: EZ },
  hover: { Feature: wZ },
};
function Bk(n, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== n.length) return !1;
  for (let i = 0; i < t; i++) if (e[i] !== n[i]) return !1;
  return !0;
}
const FZ = (n) => /^\-?\d*\.?\d+$/.test(n),
  NZ = (n) => /^0[^.\s]+$/.test(n),
  Ia = { delta: 0, timestamp: 0 },
  Ik = (1 / 60) * 1e3,
  OZ = typeof performance < "u" ? () => performance.now() : () => Date.now(),
  Dk =
    typeof window < "u"
      ? (n) => window.requestAnimationFrame(n)
      : (n) => setTimeout(() => n(OZ()), Ik);
function UZ(n) {
  let e = [],
    t = [],
    i = 0,
    r = !1,
    s = !1;
  const o = new WeakSet(),
    a = {
      schedule: (l, u = !1, c = !1) => {
        const d = c && r,
          p = d ? e : t;
        return (
          u && o.add(l),
          p.indexOf(l) === -1 && (p.push(l), d && r && (i = e.length)),
          l
        );
      },
      cancel: (l) => {
        const u = t.indexOf(l);
        u !== -1 && t.splice(u, 1), o.delete(l);
      },
      process: (l) => {
        if (r) {
          s = !0;
          return;
        }
        if (((r = !0), ([e, t] = [t, e]), (t.length = 0), (i = e.length), i))
          for (let u = 0; u < i; u++) {
            const c = e[u];
            c(l), o.has(c) && (a.schedule(c), n());
          }
        (r = !1), s && ((s = !1), a.process(l));
      },
    };
  return a;
}
const kZ = 40;
let Hw = !0,
  Pm = !1,
  Gw = !1;
const sg = ["read", "update", "preRender", "render", "postRender"],
  Gx = sg.reduce((n, e) => ((n[e] = UZ(() => (Pm = !0))), n), {}),
  Sr = sg.reduce((n, e) => {
    const t = Gx[e];
    return (n[e] = (i, r = !1, s = !1) => (Pm || HZ(), t.schedule(i, r, s))), n;
  }, {}),
  Xl = sg.reduce((n, e) => ((n[e] = Gx[e].cancel), n), {}),
  zS = sg.reduce((n, e) => ((n[e] = () => Gx[e].process(Ia)), n), {}),
  zZ = (n) => Gx[n].process(Ia),
  Lk = (n) => {
    (Pm = !1),
      (Ia.delta = Hw ? Ik : Math.max(Math.min(n - Ia.timestamp, kZ), 1)),
      (Ia.timestamp = n),
      (Gw = !0),
      sg.forEach(zZ),
      (Gw = !1),
      Pm && ((Hw = !1), Dk(Lk));
  },
  HZ = () => {
    (Pm = !0), (Hw = !0), Gw || Dk(Lk);
  };
function LC(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function FC(n, e) {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}
class NC {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return LC(this.subscriptions, e), () => FC(this.subscriptions, e);
  }
  notify(e, t, i) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, t, i);
      else
        for (let s = 0; s < r; s++) {
          const o = this.subscriptions[s];
          o && o(e, t, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function OC(n, e) {
  return e ? n * (1e3 / e) : 0;
}
const GZ = (n) => !isNaN(parseFloat(n));
class VZ {
  constructor(e, t = {}) {
    (this.version = "9.1.7"),
      (this.timeDelta = 0),
      (this.lastUpdated = 0),
      (this.canTrackVelocity = !1),
      (this.events = {}),
      (this.updateAndNotify = (i, r = !0) => {
        (this.prev = this.current), (this.current = i);
        const { delta: s, timestamp: o } = Ia;
        this.lastUpdated !== o &&
          ((this.timeDelta = s),
          (this.lastUpdated = o),
          Sr.postRender(this.scheduleVelocityCheck)),
          this.prev !== this.current &&
            this.events.change &&
            this.events.change.notify(this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()),
          r &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current);
      }),
      (this.scheduleVelocityCheck = () => Sr.postRender(this.velocityCheck)),
      (this.velocityCheck = ({ timestamp: i }) => {
        i !== this.lastUpdated &&
          ((this.prev = this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()));
      }),
      (this.hasAnimated = !1),
      (this.prev = this.current = e),
      (this.canTrackVelocity = GZ(this.current)),
      (this.owner = t.owner);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new NC());
    const i = this.events[e].add(t);
    return e === "change"
      ? () => {
          i(),
            Sr.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : i;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    (this.passiveEffect = e), (this.stopPassiveEffect = t);
  }
  set(e, t = !0) {
    !t || !this.passiveEffect
      ? this.updateAndNotify(e, t)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, t, i) {
    this.set(t), (this.prev = e), (this.timeDelta = i);
  }
  jump(e) {
    this.updateAndNotify(e),
      (this.prev = e),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    return this.canTrackVelocity
      ? OC(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      : 0;
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        (this.hasAnimated = !0),
          (this.animation = e(t) || null),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    this.animation = null;
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function zh(n, e) {
  return new VZ(n, e);
}
const UC = (n, e) => (t) =>
    !!(
      (ig(t) && eZ.test(t) && t.startsWith(n)) ||
      (e && Object.prototype.hasOwnProperty.call(t, e))
    ),
  Fk = (n, e, t) => (i) => {
    if (!ig(i)) return i;
    const [r, s, o, a] = i.match(Rm);
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    };
  },
  WZ = (n) => kh(0, 255, n),
  HS = { ...Vc, transform: (n) => Math.round(WZ(n)) },
  $u = {
    test: UC("rgb", "red"),
    parse: Fk("red", "green", "blue"),
    transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) =>
      "rgba(" +
      HS.transform(n) +
      ", " +
      HS.transform(e) +
      ", " +
      HS.transform(t) +
      ", " +
      Up(Op.transform(i)) +
      ")",
  };
function XZ(n) {
  let e = "",
    t = "",
    i = "",
    r = "";
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (i = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (i = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const Vw = { test: UC("#"), parse: XZ, transform: $u.transform },
  $f = {
    test: UC("hsl", "hue"),
    parse: Fk("hue", "saturation", "lightness"),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) =>
      "hsla(" +
      Math.round(n) +
      ", " +
      jo.transform(Up(e)) +
      ", " +
      jo.transform(Up(t)) +
      ", " +
      Up(Op.transform(i)) +
      ")",
  },
  dr = {
    test: (n) => $u.test(n) || Vw.test(n) || $f.test(n),
    parse: (n) =>
      $u.test(n) ? $u.parse(n) : $f.test(n) ? $f.parse(n) : Vw.parse(n),
    transform: (n) =>
      ig(n) ? n : n.hasOwnProperty("red") ? $u.transform(n) : $f.transform(n),
  },
  Nk = "${c}",
  Ok = "${n}";
function JZ(n) {
  var e, t;
  return (
    isNaN(n) &&
    ig(n) &&
    (((e = n.match(Rm)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((t = n.match(kw)) === null || t === void 0 ? void 0 : t.length) || 0) >
      0
  );
}
function b_(n) {
  typeof n == "number" && (n = `${n}`);
  const e = [];
  let t = 0,
    i = 0;
  const r = n.match(kw);
  r && ((t = r.length), (n = n.replace(kw, Nk)), e.push(...r.map(dr.parse)));
  const s = n.match(Rm);
  return (
    s && ((i = s.length), (n = n.replace(Rm, Ok)), e.push(...s.map(Vc.parse))),
    { values: e, numColors: t, numNumbers: i, tokenised: n }
  );
}
function Uk(n) {
  return b_(n).values;
}
function kk(n) {
  const { values: e, numColors: t, tokenised: i } = b_(n),
    r = e.length;
  return (s) => {
    let o = i;
    for (let a = 0; a < r; a++)
      o = o.replace(a < t ? Nk : Ok, a < t ? dr.transform(s[a]) : Up(s[a]));
    return o;
  };
}
const jZ = (n) => (typeof n == "number" ? 0 : n);
function YZ(n) {
  const e = Uk(n);
  return kk(n)(e.map(jZ));
}
const Jl = {
    test: JZ,
    parse: Uk,
    createTransformer: kk,
    getAnimatableNone: YZ,
  },
  KZ = new Set(["brightness", "contrast", "saturate", "opacity"]);
function QZ(n) {
  const [e, t] = n.slice(0, -1).split("(");
  if (e === "drop-shadow") return n;
  const [i] = t.match(Rm) || [];
  if (!i) return n;
  const r = t.replace(i, "");
  let s = KZ.has(e) ? 1 : 0;
  return i !== t && (s *= 100), e + "(" + s + r + ")";
}
const ZZ = /([a-z-]*)\(.*?\)/g,
  Ww = {
    ...Jl,
    getAnimatableNone: (n) => {
      const e = n.match(ZZ);
      return e ? e.map(QZ).join(" ") : n;
    },
  },
  qZ = {
    ...vk,
    color: dr,
    backgroundColor: dr,
    outlineColor: dr,
    fill: dr,
    stroke: dr,
    borderColor: dr,
    borderTopColor: dr,
    borderRightColor: dr,
    borderBottomColor: dr,
    borderLeftColor: dr,
    filter: Ww,
    WebkitFilter: Ww,
  },
  kC = (n) => qZ[n];
function zC(n, e) {
  let t = kC(n);
  return (
    t !== Ww && (t = Jl), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
const zk = (n) => (e) => e.test(n),
  $Z = { test: (n) => n === "auto", parse: (n) => n },
  Hk = [Vc, wt, jo, cl, nZ, tZ, $Z],
  Wd = (n) => Hk.find(zk(n)),
  eq = [...Hk, dr, Jl],
  tq = (n) => eq.find(zk(n));
function nq(n) {
  const e = {};
  return n.values.forEach((t, i) => (e[i] = t.get())), e;
}
function iq(n) {
  const e = {};
  return n.values.forEach((t, i) => (e[i] = t.getVelocity())), e;
}
function Vx(n, e, t) {
  const i = n.getProps();
  return DC(i, e, t !== void 0 ? t : i.custom, nq(n), iq(n));
}
function rq(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, zh(t));
}
function sq(n, e) {
  const t = Vx(n, e);
  let {
    transitionEnd: i = {},
    transition: r = {},
    ...s
  } = t ? n.makeTargetAnimatable(t, !1) : {};
  s = { ...s, ...i };
  for (const o in s) {
    const a = gZ(s[o]);
    rq(n, o, a);
  }
}
function oq(n, e, t) {
  var i, r;
  const s = Object.keys(e).filter((a) => !n.hasValue(a)),
    o = s.length;
  if (o)
    for (let a = 0; a < o; a++) {
      const l = s[a],
        u = e[l];
      let c = null;
      Array.isArray(u) && (c = u[0]),
        c === null &&
          (c =
            (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !==
              null && r !== void 0
              ? r
              : e[l]),
        c != null &&
          (typeof c == "string" && (FZ(c) || NZ(c))
            ? (c = parseFloat(c))
            : !tq(c) && Jl.test(u) && (c = zC(l, u)),
          n.addValue(l, zh(c, { owner: n })),
          t[l] === void 0 && (t[l] = c),
          c !== null && n.setBaseTarget(l, c));
    }
}
function aq(n, e) {
  return e ? (e[n] || e.default || e).from : void 0;
}
function lq(n, e, t) {
  const i = {};
  for (const r in n) {
    const s = aq(r, e);
    if (s !== void 0) i[r] = s;
    else {
      const o = t.getValue(r);
      o && (i[r] = o.get());
    }
  }
  return i;
}
function R_(n) {
  return !!(Kr(n) && n.add);
}
const uq = "framerAppearId",
  cq = "data-" + BC(uq);
let fq = Zs,
  P_ = Zs;
const Zv = (n) => n * 1e3,
  hq = { current: !1 },
  HC = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
  GC = (n) => (e) => 1 - n(1 - e),
  VC = (n) => n * n,
  dq = GC(VC),
  WC = HC(VC),
  On = (n, e, t) => -t * n + t * e + n;
function GS(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  );
}
function pq({ hue: n, saturation: e, lightness: t, alpha: i }) {
  (n /= 360), (e /= 100), (t /= 100);
  let r = 0,
    s = 0,
    o = 0;
  if (!e) r = s = o = t;
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e,
      l = 2 * t - a;
    (r = GS(l, a, n + 1 / 3)), (s = GS(l, a, n)), (o = GS(l, a, n - 1 / 3));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: i,
  };
}
const VS = (n, e, t) => {
    const i = n * n;
    return Math.sqrt(Math.max(0, t * (e * e - i) + i));
  },
  mq = [Vw, $u, $f],
  gq = (n) => mq.find((e) => e.test(n));
function JI(n) {
  const e = gq(n);
  let t = e.parse(n);
  return e === $f && (t = pq(t)), t;
}
const Gk = (n, e) => {
  const t = JI(n),
    i = JI(e),
    r = { ...t };
  return (s) => (
    (r.red = VS(t.red, i.red, s)),
    (r.green = VS(t.green, i.green, s)),
    (r.blue = VS(t.blue, i.blue, s)),
    (r.alpha = On(t.alpha, i.alpha, s)),
    $u.transform(r)
  );
};
function Vk(n, e) {
  return typeof n == "number"
    ? (t) => On(n, e, t)
    : dr.test(n)
    ? Gk(n, e)
    : Xk(n, e);
}
const Wk = (n, e) => {
    const t = [...n],
      i = t.length,
      r = n.map((s, o) => Vk(s, e[o]));
    return (s) => {
      for (let o = 0; o < i; o++) t[o] = r[o](s);
      return t;
    };
  },
  vq = (n, e) => {
    const t = { ...n, ...e },
      i = {};
    for (const r in t)
      n[r] !== void 0 && e[r] !== void 0 && (i[r] = Vk(n[r], e[r]));
    return (r) => {
      for (const s in i) t[s] = i[s](r);
      return t;
    };
  },
  Xk = (n, e) => {
    const t = Jl.createTransformer(e),
      i = b_(n),
      r = b_(e);
    return i.numColors === r.numColors && i.numNumbers >= r.numNumbers
      ? Nl(Wk(i.values, r.values), t)
      : (o) => `${o > 0 ? e : n}`;
  },
  Bm = (n, e, t) => {
    const i = e - n;
    return i === 0 ? 1 : (t - n) / i;
  },
  jI = (n, e) => (t) => On(n, e, t);
function yq(n) {
  return typeof n == "number"
    ? jI
    : typeof n == "string"
    ? dr.test(n)
      ? Gk
      : Xk
    : Array.isArray(n)
    ? Wk
    : typeof n == "object"
    ? vq
    : jI;
}
function _q(n, e, t) {
  const i = [],
    r = t || yq(n[0]),
    s = n.length - 1;
  for (let o = 0; o < s; o++) {
    let a = r(n[o], n[o + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[o] : e;
      a = Nl(l, a);
    }
    i.push(a);
  }
  return i;
}
function Jk(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length;
  P_(s === e.length),
    P_(!i || !Array.isArray(i) || i.length === s - 1),
    n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()));
  const o = _q(e, i, r),
    a = o.length,
    l = (u) => {
      let c = 0;
      if (a > 1) for (; c < n.length - 2 && !(u < n[c + 1]); c++);
      const d = Bm(n[c], n[c + 1], u);
      return o[c](d);
    };
  return t ? (u) => l(kh(n[0], n[s - 1], u)) : l;
}
function xq(n, e) {
  const t = n[n.length - 1];
  for (let i = 1; i <= e; i++) {
    const r = Bm(0, e, i);
    n.push(On(t, 1, r));
  }
}
function Aq(n) {
  const e = [0];
  return xq(e, n.length - 1), e;
}
function Sq(n, e) {
  return n.map((t) => t * e);
}
const jk = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  Mq = 1e-7,
  wq = 12;
function Eq(n, e, t, i, r) {
  let s,
    o,
    a = 0;
  do (o = e + (t - e) / 2), (s = jk(o, i, r) - n), s > 0 ? (t = o) : (e = o);
  while (Math.abs(s) > Mq && ++a < wq);
  return o;
}
function Yk(n, e, t, i) {
  if (n === e && t === i) return Zs;
  const r = (s) => Eq(s, 0, 1, n, t);
  return (s) => (s === 0 || s === 1 ? s : jk(r(s), e, i));
}
const Kk = (n) => 1 - Math.sin(Math.acos(n)),
  XC = GC(Kk),
  Tq = HC(XC),
  Qk = Yk(0.33, 1.53, 0.69, 0.99),
  JC = GC(Qk),
  Cq = HC(JC),
  bq = (n) =>
    (n *= 2) < 1 ? 0.5 * JC(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  Rq = {
    linear: Zs,
    easeIn: VC,
    easeInOut: WC,
    easeOut: dq,
    circIn: Kk,
    circInOut: Tq,
    circOut: XC,
    backIn: JC,
    backInOut: Cq,
    backOut: Qk,
    anticipate: bq,
  },
  YI = (n) => {
    if (Array.isArray(n)) {
      P_(n.length === 4);
      const [e, t, i, r] = n;
      return Yk(e, t, i, r);
    } else if (typeof n == "string") return Rq[n];
    return n;
  },
  Pq = (n) => Array.isArray(n) && typeof n[0] != "number";
function Bq(n, e) {
  return n.map(() => e || WC).splice(0, n.length - 1);
}
function Xw({ keyframes: n, ease: e = WC, times: t, duration: i = 300 }) {
  n = [...n];
  const r = Pq(e) ? e.map(YI) : YI(e),
    s = { done: !1, value: n[0] },
    o = Sq(t && t.length === n.length ? t : Aq(n), i);
  function a() {
    return Jk(o, n, { ease: Array.isArray(r) ? r : Bq(n, r) });
  }
  let l = a();
  return {
    next: (u) => ((s.value = l(u)), (s.done = u >= i), s),
    flipTarget: () => {
      n.reverse(), (l = a());
    },
  };
}
const WS = 0.001,
  Iq = 0.01,
  KI = 10,
  Dq = 0.05,
  Lq = 1;
function Fq({
  duration: n = 800,
  bounce: e = 0.25,
  velocity: t = 0,
  mass: i = 1,
}) {
  let r, s;
  fq(n <= KI * 1e3);
  let o = 1 - e;
  (o = kh(Dq, Lq, o)),
    (n = kh(Iq, KI, n / 1e3)),
    o < 1
      ? ((r = (u) => {
          const c = u * o,
            d = c * n,
            p = c - t,
            m = Jw(u, o),
            v = Math.exp(-d);
          return WS - (p / m) * v;
        }),
        (s = (u) => {
          const d = u * o * n,
            p = d * t + t,
            m = Math.pow(o, 2) * Math.pow(u, 2) * n,
            v = Math.exp(-d),
            _ = Jw(Math.pow(u, 2), o);
          return ((-r(u) + WS > 0 ? -1 : 1) * ((p - m) * v)) / _;
        }))
      : ((r = (u) => {
          const c = Math.exp(-u * n),
            d = (u - t) * n + 1;
          return -WS + c * d;
        }),
        (s = (u) => {
          const c = Math.exp(-u * n),
            d = (t - u) * (n * n);
          return c * d;
        }));
  const a = 5 / n,
    l = Oq(r, s, a);
  if (((n = n * 1e3), isNaN(l)))
    return { stiffness: 100, damping: 10, duration: n };
  {
    const u = Math.pow(l, 2) * i;
    return { stiffness: u, damping: o * 2 * Math.sqrt(i * u), duration: n };
  }
}
const Nq = 12;
function Oq(n, e, t) {
  let i = t;
  for (let r = 1; r < Nq; r++) i = i - n(i) / e(i);
  return i;
}
function Jw(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const Uq = ["duration", "bounce"],
  kq = ["stiffness", "damping", "mass"];
function QI(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function zq(n) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...n,
  };
  if (!QI(n, kq) && QI(n, Uq)) {
    const t = Fq(n);
    (e = { ...e, ...t, velocity: 0, mass: 1 }), (e.isResolvedFromDuration = !0);
  }
  return e;
}
const Hq = 5;
function Zk({ keyframes: n, restDelta: e, restSpeed: t, ...i }) {
  let r = n[0],
    s = n[n.length - 1];
  const o = { done: !1, value: r },
    {
      stiffness: a,
      damping: l,
      mass: u,
      velocity: c,
      duration: d,
      isResolvedFromDuration: p,
    } = zq(i);
  let m = Gq,
    v = c ? -(c / 1e3) : 0;
  const _ = l / (2 * Math.sqrt(a * u));
  function x() {
    const g = s - r,
      A = Math.sqrt(a / u) / 1e3,
      S = Math.abs(g) < 5;
    if ((t || (t = S ? 0.01 : 2), e || (e = S ? 0.005 : 0.5), _ < 1)) {
      const w = Jw(A, _);
      m = (C) => {
        const b = Math.exp(-_ * A * C);
        return (
          s -
          b * (((v + _ * A * g) / w) * Math.sin(w * C) + g * Math.cos(w * C))
        );
      };
    } else if (_ === 1) m = (w) => s - Math.exp(-A * w) * (g + (v + A * g) * w);
    else {
      const w = A * Math.sqrt(_ * _ - 1);
      m = (C) => {
        const b = Math.exp(-_ * A * C),
          P = Math.min(w * C, 300);
        return (
          s - (b * ((v + _ * A * g) * Math.sinh(P) + w * g * Math.cosh(P))) / w
        );
      };
    }
  }
  return (
    x(),
    {
      next: (g) => {
        const A = m(g);
        if (p) o.done = g >= d;
        else {
          let S = v;
          if (g !== 0)
            if (_ < 1) {
              const b = Math.max(0, g - Hq);
              S = OC(A - m(b), g - b);
            } else S = 0;
          const w = Math.abs(S) <= t,
            C = Math.abs(s - A) <= e;
          o.done = w && C;
        }
        return (o.value = o.done ? s : A), o;
      },
      flipTarget: () => {
        (v = -v), ([r, s] = [s, r]), x();
      },
    }
  );
}
Zk.needsInterpolation = (n, e) => typeof n == "string" || typeof e == "string";
const Gq = (n) => 0;
function Vq({
  keyframes: n = [0],
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: i = 350,
  restDelta: r = 0.5,
  modifyTarget: s,
}) {
  const o = n[0],
    a = { done: !1, value: o };
  let l = t * e;
  const u = o + l,
    c = s === void 0 ? u : s(u);
  return (
    c !== u && (l = c - o),
    {
      next: (d) => {
        const p = -l * Math.exp(-d / i);
        return (a.done = !(p > r || p < -r)), (a.value = a.done ? c : c + p), a;
      },
      flipTarget: () => {},
    }
  );
}
const Wq = { decay: Vq, keyframes: Xw, tween: Xw, spring: Zk };
function qk(n, e, t = 0) {
  return n - e - t;
}
function Xq(n, e = 0, t = 0, i = !0) {
  return i ? qk(e + -n, e, t) : e - (n - e) + t;
}
function Jq(n, e, t, i) {
  return i ? n >= e + t : n <= -t;
}
const jq = (n) => {
  const e = ({ delta: t }) => n(t);
  return { start: () => Sr.update(e, !0), stop: () => Xl.update(e) };
};
function B_({
  duration: n,
  driver: e = jq,
  elapsed: t = 0,
  repeat: i = 0,
  repeatType: r = "loop",
  repeatDelay: s = 0,
  keyframes: o,
  autoplay: a = !0,
  onPlay: l,
  onStop: u,
  onComplete: c,
  onRepeat: d,
  onUpdate: p,
  type: m = "keyframes",
  ...v
}) {
  const _ = t;
  let x,
    g = 0,
    A = n,
    S = !1,
    w = !0,
    C;
  const b = Wq[o.length > 2 ? "keyframes" : m] || Xw,
    P = o[0],
    I = o[o.length - 1];
  let R = { done: !1, value: P };
  const { needsInterpolation: T } = b;
  T && T(P, I) && ((C = Jk([0, 100], [P, I], { clamp: !1 })), (o = [0, 100]));
  const D = b({ ...v, duration: n, keyframes: o });
  function G() {
    g++,
      r === "reverse"
        ? ((w = g % 2 === 0), (t = Xq(t, A, s, w)))
        : ((t = qk(t, A, s)), r === "mirror" && D.flipTarget()),
      (S = !1),
      d && d();
  }
  function W() {
    x && x.stop(), c && c();
  }
  function q(K) {
    w || (K = -K),
      (t += K),
      S ||
        ((R = D.next(Math.max(0, t))),
        C && (R.value = C(R.value)),
        (S = w ? R.done : t <= 0)),
      p && p(R.value),
      S &&
        (g === 0 && (A = A !== void 0 ? A : t),
        g < i ? Jq(t, A, s, w) && G() : W());
  }
  function Z() {
    l && l(), (x = e(q)), x.start();
  }
  return (
    a && Z(),
    {
      stop: () => {
        u && u(), x && x.stop();
      },
      set currentTime(K) {
        (t = _), q(K);
      },
      sample: (K) => {
        t = _;
        const te = n && typeof n == "number" ? Math.max(n * 0.5, 50) : 50;
        let O = 0;
        for (q(0); O <= K; ) {
          const Y = K - O;
          q(Math.min(Y, te)), (O += te);
        }
        return R;
      },
    }
  );
}
function Yq(n) {
  return !n || Array.isArray(n) || (typeof n == "string" && $k[n]);
}
const sp = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
  $k = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: sp([0, 0.65, 0.55, 1]),
    circOut: sp([0.55, 0, 1, 0.45]),
    backIn: sp([0.31, 0.01, 0.66, -0.59]),
    backOut: sp([0.33, 1.53, 0.69, 0.99]),
  };
function Kq(n) {
  if (n) return Array.isArray(n) ? sp(n) : $k[n];
}
function Qq(
  n,
  e,
  t,
  {
    delay: i = 0,
    duration: r,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a,
    times: l,
  } = {}
) {
  return n.animate(
    { [e]: t, offset: l },
    {
      delay: i,
      duration: r,
      easing: Kq(a),
      fill: "both",
      iterations: s + 1,
      direction: o === "reverse" ? "alternate" : "normal",
    }
  );
}
const ZI = {
    waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
  },
  XS = {},
  ez = {};
for (const n in ZI)
  ez[n] = () => (XS[n] === void 0 && (XS[n] = ZI[n]()), XS[n]);
function Zq(n, { repeat: e, repeatType: t = "loop" }) {
  const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1;
  return n[i];
}
const qq = new Set(["opacity", "clipPath", "filter", "transform"]),
  wv = 10;
function $q(n, e, { onUpdate: t, onComplete: i, ...r }) {
  if (
    !(
      ez.waapi() &&
      qq.has(e) &&
      !r.repeatDelay &&
      r.repeatType !== "mirror" &&
      r.damping !== 0
    )
  )
    return !1;
  let { keyframes: o, duration: a = 300, elapsed: l = 0, ease: u } = r;
  if (r.type === "spring" || !Yq(r.ease)) {
    if (r.repeat === 1 / 0) return;
    const d = B_({ ...r, elapsed: 0 });
    let p = { done: !1, value: o[0] };
    const m = [];
    let v = 0;
    for (; !p.done && v < 2e4; ) (p = d.sample(v)), m.push(p.value), (v += wv);
    (o = m), (a = v - wv), (u = "linear");
  }
  const c = Qq(n.owner.current, e, o, {
    ...r,
    delay: -l,
    duration: a,
    ease: u,
  });
  return (
    (c.onfinish = () => {
      n.set(Zq(o, r)), Sr.update(() => c.cancel()), i && i();
    }),
    {
      get currentTime() {
        return c.currentTime || 0;
      },
      set currentTime(d) {
        c.currentTime = d;
      },
      stop: () => {
        const { currentTime: d } = c;
        if (d) {
          const p = B_({ ...r, autoplay: !1 });
          n.setWithVelocity(p.sample(d - wv).value, p.sample(d).value, wv);
        }
        Sr.update(() => c.cancel());
      },
    }
  );
}
function tz(n, e) {
  const t = performance.now(),
    i = ({ timestamp: r }) => {
      const s = r - t;
      s >= e && (Xl.read(i), n(s - e));
    };
  return Sr.read(i, !0), () => Xl.read(i);
}
function e$({ keyframes: n, elapsed: e, onUpdate: t, onComplete: i }) {
  const r = () => {
    t && t(n[n.length - 1]), i && i();
  };
  return e ? { stop: tz(r, -e) } : r();
}
function t$({
  keyframes: n,
  velocity: e = 0,
  min: t,
  max: i,
  power: r = 0.8,
  timeConstant: s = 750,
  bounceStiffness: o = 500,
  bounceDamping: a = 10,
  restDelta: l = 1,
  modifyTarget: u,
  driver: c,
  onUpdate: d,
  onComplete: p,
  onStop: m,
}) {
  const v = n[0];
  let _;
  function x(w) {
    return (t !== void 0 && w < t) || (i !== void 0 && w > i);
  }
  function g(w) {
    return t === void 0
      ? i
      : i === void 0 || Math.abs(t - w) < Math.abs(i - w)
      ? t
      : i;
  }
  function A(w) {
    _ && _.stop(),
      (_ = B_({
        keyframes: [0, 1],
        velocity: 0,
        ...w,
        driver: c,
        onUpdate: (C) => {
          d && d(C), w.onUpdate && w.onUpdate(C);
        },
        onComplete: p,
        onStop: m,
      }));
  }
  function S(w) {
    A({ type: "spring", stiffness: o, damping: a, restDelta: l, ...w });
  }
  if (x(v)) S({ velocity: e, keyframes: [v, g(v)] });
  else {
    let w = r * e + v;
    typeof u < "u" && (w = u(w));
    const C = g(w),
      b = C === t ? -1 : 1;
    let P, I;
    const R = (T) => {
      (P = I),
        (I = T),
        (e = OC(T - P, Ia.delta)),
        ((b === 1 && T > C) || (b === -1 && T < C)) &&
          S({ keyframes: [T, C], velocity: e });
    };
    A({
      type: "decay",
      keyframes: [v, 0],
      velocity: e,
      timeConstant: s,
      power: r,
      restDelta: l,
      modifyTarget: u,
      onUpdate: x(w) ? R : void 0,
    });
  }
  return { stop: () => _ && _.stop() };
}
const n$ = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  i$ = (n) => ({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  r$ = { type: "keyframes", duration: 0.8 },
  s$ = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  o$ = (n, { keyframes: e }) =>
    e.length > 2
      ? r$
      : Gc.has(n)
      ? n.startsWith("scale")
        ? i$(e[1])
        : n$
      : s$,
  jw = (n, e) =>
    n === "zIndex"
      ? !1
      : !!(
          typeof e == "number" ||
          Array.isArray(e) ||
          (typeof e == "string" && Jl.test(e) && !e.startsWith("url("))
        );
function a$({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: l,
  elapsed: u,
  ...c
}) {
  return !!Object.keys(c).length;
}
function qI(n) {
  return (
    n === 0 ||
    (typeof n == "string" && parseFloat(n) === 0 && n.indexOf(" ") === -1)
  );
}
function $I(n) {
  return typeof n == "number" ? 0 : zC("", n);
}
function nz(n, e) {
  return n[e] || n.default || n;
}
function l$(n, e, t, i) {
  const r = jw(e, t);
  let s = i.from !== void 0 ? i.from : n.get();
  return (
    s === "none" && r && typeof t == "string"
      ? (s = zC(e, t))
      : qI(s) && typeof t == "string"
      ? (s = $I(t))
      : !Array.isArray(t) && qI(t) && typeof s == "string" && (t = $I(s)),
    Array.isArray(t) ? (t[0] === null && (t[0] = s), t) : [s, t]
  );
}
const jC =
  (n, e, t, i = {}) =>
  (r) => {
    const s = nz(i, n) || {},
      o = s.delay || i.delay || 0;
    let { elapsed: a = 0 } = i;
    a = a - Zv(o);
    const l = l$(e, n, t, s),
      u = l[0],
      c = l[l.length - 1],
      d = jw(n, u),
      p = jw(n, c);
    let m = {
      keyframes: l,
      velocity: e.getVelocity(),
      ...s,
      elapsed: a,
      onUpdate: (v) => {
        e.set(v), s.onUpdate && s.onUpdate(v);
      },
      onComplete: () => {
        r(), s.onComplete && s.onComplete();
      },
    };
    if (!d || !p || hq.current || s.type === !1) return e$(m);
    if (s.type === "inertia") return t$(m);
    if (
      (a$(s) || (m = { ...m, ...o$(n, m) }),
      m.duration && (m.duration = Zv(m.duration)),
      m.repeatDelay && (m.repeatDelay = Zv(m.repeatDelay)),
      e.owner &&
        e.owner.current instanceof HTMLElement &&
        !e.owner.getProps().onUpdate)
    ) {
      const v = $q(e, n, m);
      if (v) return v;
    }
    return B_(m);
  };
function u$(n, e, t = {}) {
  n.notify("AnimationStart", e);
  let i;
  if (Array.isArray(e)) {
    const r = e.map((s) => Yw(n, s, t));
    i = Promise.all(r);
  } else if (typeof e == "string") i = Yw(n, e, t);
  else {
    const r = typeof e == "function" ? Vx(n, e, t.custom) : e;
    i = iz(n, r, t);
  }
  return i.then(() => n.notify("AnimationComplete", e));
}
function Yw(n, e, t = {}) {
  const i = Vx(n, e, t.custom);
  let { transition: r = n.getDefaultTransition() || {} } = i || {};
  t.transitionOverride && (r = t.transitionOverride);
  const s = i ? () => iz(n, i, t) : () => Promise.resolve(),
    o =
      n.variantChildren && n.variantChildren.size
        ? (l = 0) => {
            const {
              delayChildren: u = 0,
              staggerChildren: c,
              staggerDirection: d,
            } = r;
            return c$(n, e, u + l, c, d, t);
          }
        : () => Promise.resolve(),
    { when: a } = r;
  if (a) {
    const [l, u] = a === "beforeChildren" ? [s, o] : [o, s];
    return l().then(u);
  } else return Promise.all([s(), o(t.delay)]);
}
function iz(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) {
  let {
    transition: s = n.getDefaultTransition(),
    transitionEnd: o,
    ...a
  } = n.makeTargetAnimatable(e);
  const l = n.getValue("willChange");
  i && (s = i);
  const u = [],
    c = r && n.animationState && n.animationState.getState()[r];
  for (const d in a) {
    const p = n.getValue(d),
      m = a[d];
    if (!p || m === void 0 || (c && h$(c, d))) continue;
    const v = { delay: t, elapsed: 0, ...s };
    if (window.HandoffAppearAnimations && !p.hasAnimated) {
      const x = n.getProps()[cq];
      x && (v.elapsed = window.HandoffAppearAnimations(x, d, p, Sr));
    }
    let _ = p.start(
      jC(d, p, m, n.shouldReduceMotion && Gc.has(d) ? { type: !1 } : v)
    );
    R_(l) && (l.add(d), (_ = _.then(() => l.remove(d)))), u.push(_);
  }
  return Promise.all(u).then(() => {
    o && sq(n, o);
  });
}
function c$(n, e, t = 0, i = 0, r = 1, s) {
  const o = [],
    a = (n.variantChildren.size - 1) * i,
    l = r === 1 ? (u = 0) => u * i : (u = 0) => a - u * i;
  return (
    Array.from(n.variantChildren)
      .sort(f$)
      .forEach((u, c) => {
        u.notify("AnimationStart", e),
          o.push(
            Yw(u, e, { ...s, delay: t + l(c) }).then(() =>
              u.notify("AnimationComplete", e)
            )
          );
      }),
    Promise.all(o)
  );
}
function f$(n, e) {
  return n.sortNodePosition(e);
}
function h$({ protectedKeys: n, needsAnimating: e }, t) {
  const i = n.hasOwnProperty(t) && e[t] !== !0;
  return (e[t] = !1), i;
}
const d$ = [...wC].reverse(),
  p$ = wC.length;
function m$(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: i }) => u$(n, t, i)));
}
function g$(n) {
  let e = m$(n);
  const t = y$();
  let i = !0;
  const r = (l, u) => {
    const c = Vx(n, u);
    if (c) {
      const { transition: d, transitionEnd: p, ...m } = c;
      l = { ...l, ...m, ...p };
    }
    return l;
  };
  function s(l) {
    e = l(n);
  }
  function o(l, u) {
    const c = n.getProps(),
      d = n.getVariantContext(!0) || {},
      p = [],
      m = new Set();
    let v = {},
      _ = 1 / 0;
    for (let g = 0; g < p$; g++) {
      const A = d$[g],
        S = t[A],
        w = c[A] !== void 0 ? c[A] : d[A],
        C = Cm(w),
        b = A === u ? S.isActive : null;
      b === !1 && (_ = g);
      let P = w === d[A] && w !== c[A] && C;
      if (
        (P && i && n.manuallyAnimateOnMount && (P = !1),
        (S.protectedKeys = { ...v }),
        (!S.isActive && b === null) ||
          (!w && !S.prevProp) ||
          Ux(w) ||
          typeof w == "boolean")
      )
        continue;
      const I = v$(S.prevProp, w);
      let R = I || (A === u && S.isActive && !P && C) || (g > _ && C);
      const T = Array.isArray(w) ? w : [w];
      let D = T.reduce(r, {});
      b === !1 && (D = {});
      const { prevResolvedValues: G = {} } = S,
        W = { ...G, ...D },
        q = (Z) => {
          (R = !0), m.delete(Z), (S.needsAnimating[Z] = !0);
        };
      for (const Z in W) {
        const K = D[Z],
          te = G[Z];
        v.hasOwnProperty(Z) ||
          (K !== te
            ? C_(K) && C_(te)
              ? !Bk(K, te) || I
                ? q(Z)
                : (S.protectedKeys[Z] = !0)
              : K !== void 0
              ? q(Z)
              : m.add(Z)
            : K !== void 0 && m.has(Z)
            ? q(Z)
            : (S.protectedKeys[Z] = !0));
      }
      (S.prevProp = w),
        (S.prevResolvedValues = D),
        S.isActive && (v = { ...v, ...D }),
        i && n.blockInitialAnimation && (R = !1),
        R &&
          !P &&
          p.push(
            ...T.map((Z) => ({ animation: Z, options: { type: A, ...l } }))
          );
    }
    if (m.size) {
      const g = {};
      m.forEach((A) => {
        const S = n.getBaseTarget(A);
        S !== void 0 && (g[A] = S);
      }),
        p.push({ animation: g });
    }
    let x = !!p.length;
    return (
      i && c.initial === !1 && !n.manuallyAnimateOnMount && (x = !1),
      (i = !1),
      x ? e(p) : Promise.resolve()
    );
  }
  function a(l, u, c) {
    var d;
    if (t[l].isActive === u) return Promise.resolve();
    (d = n.variantChildren) === null ||
      d === void 0 ||
      d.forEach((m) => {
        var v;
        return (v = m.animationState) === null || v === void 0
          ? void 0
          : v.setActive(l, u);
      }),
      (t[l].isActive = u);
    const p = o(c, l);
    for (const m in t) t[m].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
  };
}
function v$(n, e) {
  return typeof e == "string" ? e !== n : Array.isArray(e) ? !Bk(e, n) : !1;
}
function Cu(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function y$() {
  return {
    animate: Cu(!0),
    whileInView: Cu(),
    whileHover: Cu(),
    whileTap: Cu(),
    whileDrag: Cu(),
    whileFocus: Cu(),
    exit: Cu(),
  };
}
class _$ extends eu {
  constructor(e) {
    super(e), e.animationState || (e.animationState = g$(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    this.unmount(), Ux(e) && (this.unmount = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {}
}
let x$ = 0;
class A$ extends eu {
  constructor() {
    super(...arguments), (this.id = x$++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const {
        isPresent: e,
        onExitComplete: t,
        custom: i,
      } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r) return;
    const s = this.node.animationState.setActive("exit", !e, {
      custom: i ?? this.node.getProps().custom,
    });
    t && !e && s.then(() => t(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const S$ = { animation: { Feature: _$ }, exit: { Feature: A$ } },
  eD = (n, e) => Math.abs(n - e);
function M$(n, e) {
  const t = eD(n.x, e.x),
    i = eD(n.y, e.y);
  return Math.sqrt(t ** 2 + i ** 2);
}
class rz {
  constructor(e, t, { transformPagePoint: i } = {}) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const u = jS(this.lastMoveEventInfo, this.history),
          c = this.startEvent !== null,
          d = M$(u.offset, { x: 0, y: 0 }) >= 3;
        if (!c && !d) return;
        const { point: p } = u,
          { timestamp: m } = Ia;
        this.history.push({ ...p, timestamp: m });
        const { onStart: v, onMove: _ } = this.handlers;
        c ||
          (v && v(this.lastMoveEvent, u),
          (this.startEvent = this.lastMoveEvent)),
          _ && _(this.lastMoveEvent, u);
      }),
      (this.handlePointerMove = (u, c) => {
        (this.lastMoveEvent = u),
          (this.lastMoveEventInfo = JS(c, this.transformPagePoint)),
          Sr.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (u, c) => {
        if ((this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)))
          return;
        const { onEnd: d, onSessionEnd: p } = this.handlers,
          m = jS(
            u.type === "pointercancel"
              ? this.lastMoveEventInfo
              : JS(c, this.transformPagePoint),
            this.history
          );
        this.startEvent && d && d(u, m), p && p(u, m);
      }),
      !Tk(e))
    )
      return;
    (this.handlers = t), (this.transformPagePoint = i);
    const r = Hx(e),
      s = JS(r, this.transformPagePoint),
      { point: o } = s,
      { timestamp: a } = Ia;
    this.history = [{ ...o, timestamp: a }];
    const { onSessionStart: l } = t;
    l && l(e, jS(s, this.history)),
      (this.removeListeners = Nl(
        Ba(window, "pointermove", this.handlePointerMove),
        Ba(window, "pointerup", this.handlePointerUp),
        Ba(window, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Xl.update(this.updatePoint);
  }
}
function JS(n, e) {
  return e ? { point: e(n.point) } : n;
}
function tD(n, e) {
  return { x: n.x - e.x, y: n.y - e.y };
}
function jS({ point: n }, e) {
  return {
    point: n,
    delta: tD(n, sz(e)),
    offset: tD(n, w$(e)),
    velocity: E$(e, 0.1),
  };
}
function w$(n) {
  return n[0];
}
function sz(n) {
  return n[n.length - 1];
}
function E$(n, e) {
  if (n.length < 2) return { x: 0, y: 0 };
  let t = n.length - 1,
    i = null;
  const r = sz(n);
  for (; t >= 0 && ((i = n[t]), !(r.timestamp - i.timestamp > Zv(e))); ) t--;
  if (!i) return { x: 0, y: 0 };
  const s = (r.timestamp - i.timestamp) / 1e3;
  if (s === 0) return { x: 0, y: 0 };
  const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function Ss(n) {
  return n.max - n.min;
}
function Kw(n, e = 0, t = 0.01) {
  return Math.abs(n - e) <= t;
}
function nD(n, e, t, i = 0.5) {
  (n.origin = i),
    (n.originPoint = On(e.min, e.max, n.origin)),
    (n.scale = Ss(t) / Ss(e)),
    (Kw(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1),
    (n.translate = On(t.min, t.max, n.origin) - n.originPoint),
    (Kw(n.translate) || isNaN(n.translate)) && (n.translate = 0);
}
function kp(n, e, t, i) {
  nD(n.x, e.x, t.x, i ? i.originX : void 0),
    nD(n.y, e.y, t.y, i ? i.originY : void 0);
}
function iD(n, e, t) {
  (n.min = t.min + e.min), (n.max = n.min + Ss(e));
}
function T$(n, e, t) {
  iD(n.x, e.x, t.x), iD(n.y, e.y, t.y);
}
function rD(n, e, t) {
  (n.min = e.min - t.min), (n.max = n.min + Ss(e));
}
function zp(n, e, t) {
  rD(n.x, e.x, t.x), rD(n.y, e.y, t.y);
}
function C$(n, { min: e, max: t }, i) {
  return (
    e !== void 0 && n < e
      ? (n = i ? On(e, n, i.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = i ? On(t, n, i.max) : Math.min(n, t)),
    n
  );
}
function sD(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  };
}
function b$(n, { top: e, left: t, bottom: i, right: r }) {
  return { x: sD(n.x, t, r), y: sD(n.y, e, i) };
}
function oD(n, e) {
  let t = e.min - n.min,
    i = e.max - n.max;
  return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), { min: t, max: i };
}
function R$(n, e) {
  return { x: oD(n.x, e.x), y: oD(n.y, e.y) };
}
function P$(n, e) {
  let t = 0.5;
  const i = Ss(n),
    r = Ss(e);
  return (
    r > i
      ? (t = Bm(e.min, e.max - i, n.min))
      : i > r && (t = Bm(n.min, n.max - r, e.min)),
    kh(0, 1, t)
  );
}
function B$(n, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  );
}
const Qw = 0.35;
function I$(n = Qw) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = Qw),
    { x: aD(n, "left", "right"), y: aD(n, "top", "bottom") }
  );
}
function aD(n, e, t) {
  return { min: lD(n, e), max: lD(n, t) };
}
function lD(n, e) {
  return typeof n == "number" ? n : n[e] || 0;
}
const uD = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  Hp = () => ({ x: uD(), y: uD() }),
  cD = () => ({ min: 0, max: 0 }),
  ii = () => ({ x: cD(), y: cD() });
function Lo(n) {
  return [n("x"), n("y")];
}
function oz({ top: n, left: e, right: t, bottom: i }) {
  return { x: { min: e, max: t }, y: { min: n, max: i } };
}
function D$({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min };
}
function L$(n, e) {
  if (!e) return n;
  const t = e({ x: n.left, y: n.top }),
    i = e({ x: n.right, y: n.bottom });
  return { top: t.y, left: t.x, bottom: i.y, right: i.x };
}
function YS(n) {
  return n === void 0 || n === 1;
}
function Zw({ scale: n, scaleX: e, scaleY: t }) {
  return !YS(n) || !YS(e) || !YS(t);
}
function Ou(n) {
  return Zw(n) || az(n) || n.z || n.rotate || n.rotateX || n.rotateY;
}
function az(n) {
  return fD(n.x) || fD(n.y);
}
function fD(n) {
  return n && n !== "0%";
}
function I_(n, e, t) {
  const i = n - t,
    r = e * i;
  return t + r;
}
function hD(n, e, t, i, r) {
  return r !== void 0 && (n = I_(n, r, i)), I_(n, t, i) + e;
}
function qw(n, e = 0, t = 1, i, r) {
  (n.min = hD(n.min, e, t, i, r)), (n.max = hD(n.max, e, t, i, r));
}
function lz(n, { x: e, y: t }) {
  qw(n.x, e.translate, e.scale, e.originPoint),
    qw(n.y, t.translate, t.scale, t.originPoint);
}
function F$(n, e, t, i = !1) {
  const r = t.length;
  if (!r) return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < r; a++) {
    (s = t[a]), (o = s.projectionDelta);
    const l = s.instance;
    (l && l.style && l.style.display === "contents") ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        eh(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), lz(n, o)),
      i && Ou(s.latestValues) && eh(n, s.latestValues));
  }
  (e.x = dD(e.x)), (e.y = dD(e.y));
}
function dD(n) {
  return Number.isInteger(n) || n > 1.0000000000001 || n < 0.999999999999
    ? n
    : 1;
}
function dl(n, e) {
  (n.min = n.min + e), (n.max = n.max + e);
}
function pD(n, e, [t, i, r]) {
  const s = e[r] !== void 0 ? e[r] : 0.5,
    o = On(n.min, n.max, s);
  qw(n, e[t], e[i], o, e.scale);
}
const N$ = ["x", "scaleX", "originX"],
  O$ = ["y", "scaleY", "originY"];
function eh(n, e) {
  pD(n.x, e, N$), pD(n.y, e, O$);
}
function uz(n, e) {
  return oz(L$(n.getBoundingClientRect(), e));
}
function U$(n, e, t) {
  const i = uz(n, t),
    { scroll: r } = e;
  return r && (dl(i.x, r.offset.x), dl(i.y, r.offset.y)), i;
}
const k$ = new WeakMap();
class z$ {
  constructor(e) {
    (this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = ii()),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1) return;
    const r = (l) => {
        this.stopAnimation(), t && this.snapToCursor(Hx(l, "page").point);
      },
      s = (l, u) => {
        const { drag: c, dragPropagation: d, onDragStart: p } = this.getProps();
        if (
          c &&
          !d &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = bk(c)),
          !this.openGlobalLock)
        )
          return;
        (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Lo((v) => {
            let _ = this.getAxisMotionValue(v).get() || 0;
            if (jo.test(_)) {
              const { projection: x } = this.visualElement;
              if (x && x.layout) {
                const g = x.layout.layoutBox[v];
                g && (_ = Ss(g) * (parseFloat(_) / 100));
              }
            }
            this.originPoint[v] = _;
          }),
          p && p(l, u);
        const { animationState: m } = this.visualElement;
        m && m.setActive("whileDrag", !0);
      },
      o = (l, u) => {
        const {
          dragPropagation: c,
          dragDirectionLock: d,
          onDirectionLock: p,
          onDrag: m,
        } = this.getProps();
        if (!c && !this.openGlobalLock) return;
        const { offset: v } = u;
        if (d && this.currentDirection === null) {
          (this.currentDirection = H$(v)),
            this.currentDirection !== null && p && p(this.currentDirection);
          return;
        }
        this.updateAxis("x", u.point, v),
          this.updateAxis("y", u.point, v),
          this.visualElement.render(),
          m && m(l, u);
      },
      a = (l, u) => this.stop(l, u);
    this.panSession = new rz(
      e,
      { onSessionStart: r, onStart: s, onMove: o, onSessionEnd: a },
      { transformPagePoint: this.visualElement.getTransformPagePoint() }
    );
  }
  stop(e, t) {
    const i = this.isDragging;
    if ((this.cancel(), !i)) return;
    const { velocity: r } = t;
    this.startAnimation(r);
    const { onDragEnd: s } = this.getProps();
    s && s(e, t);
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: i } = this.getProps();
    !i &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      t && t.setActive("whileDrag", !1);
  }
  updateAxis(e, t, i) {
    const { drag: r } = this.getProps();
    if (!i || !Ev(e, r, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + i[e];
    this.constraints &&
      this.constraints[e] &&
      (o = C$(o, this.constraints[e], this.elastic[e])),
      s.set(o);
  }
  resolveConstraints() {
    const { dragConstraints: e, dragElastic: t } = this.getProps(),
      { layout: i } = this.visualElement.projection || {},
      r = this.constraints;
    e && qf(e)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : e && i
      ? (this.constraints = b$(i.layoutBox, e))
      : (this.constraints = !1),
      (this.elastic = I$(t)),
      r !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Lo((s) => {
          this.getAxisMotionValue(s) &&
            (this.constraints[s] = B$(i.layoutBox[s], this.constraints[s]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !qf(e)) return !1;
    const i = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const s = U$(i, r.root, this.visualElement.getTransformPagePoint());
    let o = R$(r.layout.layoutBox, s);
    if (t) {
      const a = t(D$(o));
      (this.hasMutatedConstraints = !!a), a && (o = oz(a));
    }
    return o;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      l = this.constraints || {},
      u = Lo((c) => {
        if (!Ev(c, t, this.currentDirection)) return;
        let d = (l && l[c]) || {};
        o && (d = { min: 0, max: 0 });
        const p = r ? 200 : 1e6,
          m = r ? 40 : 1e7,
          v = {
            type: "inertia",
            velocity: i ? e[c] : 0,
            bounceStiffness: p,
            bounceDamping: m,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...d,
          };
        return this.startAxisValueAnimation(c, v);
      });
    return Promise.all(u).then(a);
  }
  startAxisValueAnimation(e, t) {
    const i = this.getAxisMotionValue(e);
    return i.start(jC(e, i, 0, t));
  }
  stopAnimation() {
    Lo((e) => this.getAxisMotionValue(e).stop());
  }
  getAxisMotionValue(e) {
    const t = "_drag" + e.toUpperCase(),
      i = this.visualElement.getProps(),
      r = i[t];
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    Lo((t) => {
      const { drag: i } = this.getProps();
      if (!Ev(t, i, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: o, max: a } = r.layout.layoutBox[t];
        s.set(e[t] - On(o, a, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: i } = this.visualElement;
    if (!qf(t) || !i || !this.constraints) return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    Lo((o) => {
      const a = this.getAxisMotionValue(o);
      if (a) {
        const l = a.get();
        r[o] = P$({ min: l, max: l }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      Lo((o) => {
        if (!Ev(o, e, null)) return;
        const a = this.getAxisMotionValue(o),
          { min: l, max: u } = this.constraints[o];
        a.set(On(l, u, r[o]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    k$.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = Ba(e, "pointerdown", (l) => {
        const { drag: u, dragListener: c = !0 } = this.getProps();
        u && c && this.start(l);
      }),
      i = () => {
        const { dragConstraints: l } = this.getProps();
        qf(l) && (this.constraints = this.resolveRefConstraints());
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener("measure", i);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), i();
    const o = Ea(window, "resize", () => this.scalePositionWithinConstraints()),
      a = r.addEventListener(
        "didUpdate",
        ({ delta: l, hasLayoutChanged: u }) => {
          this.isDragging &&
            u &&
            (Lo((c) => {
              const d = this.getAxisMotionValue(c);
              d &&
                ((this.originPoint[c] += l[c].translate),
                d.set(d.get() + l[c].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      o(), t(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: o = Qw,
        dragMomentum: a = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    };
  }
}
function Ev(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n);
}
function H$(n, e = 10) {
  let t = null;
  return Math.abs(n.y) > e ? (t = "y") : Math.abs(n.x) > e && (t = "x"), t;
}
class G$ extends eu {
  constructor(e) {
    super(e),
      (this.removeGroupControls = Zs),
      (this.removeListeners = Zs),
      (this.controls = new z$(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Zs);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
class V$ extends eu {
  constructor() {
    super(...arguments), (this.removePointerDownListener = Zs);
  }
  onPointerDown(e) {
    this.session = new rz(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: e,
      onStart: t,
      onMove: i,
      onEnd: (s, o) => {
        delete this.session, r && r(s, o);
      },
    };
  }
  mount() {
    this.removePointerDownListener = Ba(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function W$() {
  const n = j.useContext(MC);
  if (n === null) return [!0, null];
  const { isPresent: e, onExitComplete: t, register: i } = n,
    r = j.useId();
  return j.useEffect(() => i(r), []), !e && t ? [!1, () => t && t(r)] : [!0];
}
function mD(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100;
}
const Xd = {
    correct: (n, e) => {
      if (!e.target) return n;
      if (typeof n == "string")
        if (wt.test(n)) n = parseFloat(n);
        else return n;
      const t = mD(n, e.target.x),
        i = mD(n, e.target.y);
      return `${t}% ${i}%`;
    },
  },
  cz = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function X$(n) {
  const e = cz.exec(n);
  if (!e) return [,];
  const [, t, i] = e;
  return [t, i];
}
function $w(n, e, t = 1) {
  const [i, r] = X$(n);
  if (!i) return;
  const s = window.getComputedStyle(e).getPropertyValue(i);
  return s ? s.trim() : Uw(r) ? $w(r, e, t + 1) : r;
}
function J$(n, { ...e }, t) {
  const i = n.current;
  if (!(i instanceof Element)) return { target: e, transitionEnd: t };
  t && (t = { ...t }),
    n.values.forEach((r) => {
      const s = r.get();
      if (!Uw(s)) return;
      const o = $w(s, i);
      o && r.set(o);
    });
  for (const r in e) {
    const s = e[r];
    if (!Uw(s)) continue;
    const o = $w(s, i);
    o && ((e[r] = o), t && t[r] === void 0 && (t[r] = s));
  }
  return { target: e, transitionEnd: t };
}
const gD = "_$css",
  j$ = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const i = n,
        r = n.includes("var("),
        s = [];
      r && (n = n.replace(cz, (m) => (s.push(m), gD)));
      const o = Jl.parse(n);
      if (o.length > 5) return i;
      const a = Jl.createTransformer(n),
        l = typeof o[0] != "number" ? 1 : 0,
        u = t.x.scale * e.x,
        c = t.y.scale * e.y;
      (o[0 + l] /= u), (o[1 + l] /= c);
      const d = On(u, c, 0.5);
      typeof o[2 + l] == "number" && (o[2 + l] /= d),
        typeof o[3 + l] == "number" && (o[3 + l] /= d);
      let p = a(o);
      if (r) {
        let m = 0;
        p = p.replace(gD, () => {
          const v = s[m];
          return m++, v;
        });
      }
      return p;
    },
  };
class Y$ extends zr.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e;
    KQ(K$),
      s &&
        (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Np.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      o = i.projection;
    return (
      o &&
        ((o.isPresent = s),
        r || e.layoutDependency !== t || t === void 0
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              Sr.postRender(() => {
                const a = o.getStack();
                (!a || !a.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      !e.currentAnimation && e.isLead() && this.safeToRemove());
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e;
    r &&
      (r.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(r),
      i && i.deregister && i.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function fz(n) {
  const [e, t] = W$(),
    i = j.useContext(hk);
  return zr.createElement(Y$, {
    ...n,
    layoutGroup: i,
    switchLayoutGroup: j.useContext(dk),
    isPresent: e,
    safeToRemove: t,
  });
}
const K$ = {
  borderRadius: {
    ...Xd,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: Xd,
  borderTopRightRadius: Xd,
  borderBottomLeftRadius: Xd,
  borderBottomRightRadius: Xd,
  boxShadow: j$,
};
function Q$(n, e, t = {}) {
  const i = Kr(n) ? n : zh(n);
  return (
    i.start(jC("", i, e, t)),
    { stop: () => i.stop(), isAnimating: () => i.isAnimating() }
  );
}
const hz = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  Z$ = hz.length,
  vD = (n) => (typeof n == "string" ? parseFloat(n) : n),
  yD = (n) => typeof n == "number" || wt.test(n);
function q$(n, e, t, i, r, s) {
  r
    ? ((n.opacity = On(0, t.opacity !== void 0 ? t.opacity : 1, $$(i))),
      (n.opacityExit = On(e.opacity !== void 0 ? e.opacity : 1, 0, eee(i))))
    : s &&
      (n.opacity = On(
        e.opacity !== void 0 ? e.opacity : 1,
        t.opacity !== void 0 ? t.opacity : 1,
        i
      ));
  for (let o = 0; o < Z$; o++) {
    const a = `border${hz[o]}Radius`;
    let l = _D(e, a),
      u = _D(t, a);
    if (l === void 0 && u === void 0) continue;
    l || (l = 0),
      u || (u = 0),
      l === 0 || u === 0 || yD(l) === yD(u)
        ? ((n[a] = Math.max(On(vD(l), vD(u), i), 0)),
          (jo.test(u) || jo.test(l)) && (n[a] += "%"))
        : (n[a] = u);
  }
  (e.rotate || t.rotate) && (n.rotate = On(e.rotate || 0, t.rotate || 0, i));
}
function _D(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius;
}
const $$ = dz(0, 0.5, XC),
  eee = dz(0.5, 0.95, Zs);
function dz(n, e, t) {
  return (i) => (i < n ? 0 : i > e ? 1 : t(Bm(n, e, i)));
}
function xD(n, e) {
  (n.min = e.min), (n.max = e.max);
}
function Fs(n, e) {
  xD(n.x, e.x), xD(n.y, e.y);
}
function AD(n, e, t, i, r) {
  return (
    (n -= e), (n = I_(n, 1 / t, i)), r !== void 0 && (n = I_(n, 1 / r, i)), n
  );
}
function tee(n, e = 0, t = 1, i = 0.5, r, s = n, o = n) {
  if (
    (jo.test(e) &&
      ((e = parseFloat(e)), (e = On(o.min, o.max, e / 100) - o.min)),
    typeof e != "number")
  )
    return;
  let a = On(s.min, s.max, i);
  n === s && (a -= e),
    (n.min = AD(n.min, e, t, a, r)),
    (n.max = AD(n.max, e, t, a, r));
}
function SD(n, e, [t, i, r], s, o) {
  tee(n, e[t], e[i], e[r], e.scale, s, o);
}
const nee = ["x", "scaleX", "originX"],
  iee = ["y", "scaleY", "originY"];
function MD(n, e, t, i) {
  SD(n.x, e, nee, t ? t.x : void 0, i ? i.x : void 0),
    SD(n.y, e, iee, t ? t.y : void 0, i ? i.y : void 0);
}
function wD(n) {
  return n.translate === 0 && n.scale === 1;
}
function pz(n) {
  return wD(n.x) && wD(n.y);
}
function eE(n, e) {
  return (
    n.x.min === e.x.min &&
    n.x.max === e.x.max &&
    n.y.min === e.y.min &&
    n.y.max === e.y.max
  );
}
function ED(n) {
  return Ss(n.x) / Ss(n.y);
}
class ree {
  constructor() {
    this.members = [];
  }
  add(e) {
    LC(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (FC(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0) return !1;
    let i;
    for (let r = t; r >= 0; r--) {
      const s = this.members[r];
      if (s.isPresent !== !1) {
        i = s;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(e, t) {
    const i = this.lead;
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        t && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: r } = e.options;
      r === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: i } = e;
      t.onExitComplete && t.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function TD(n, e, t) {
  let i = "";
  const r = n.x.translate / e.x,
    s = n.y.translate / e.y;
  if (
    ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const { rotate: l, rotateX: u, rotateY: c } = t;
    l && (i += `rotate(${l}deg) `),
      u && (i += `rotateX(${u}deg) `),
      c && (i += `rotateY(${c}deg) `);
  }
  const o = n.x.scale * e.x,
    a = n.y.scale * e.y;
  return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none";
}
const see = (n, e) => n.depth - e.depth;
class oee {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    LC(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    FC(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(see),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function aee(n) {
  window.MotionDebug && window.MotionDebug.record(n);
}
const CD = ["", "X", "Y", "Z"],
  bD = 1e3;
let lee = 0;
const Uu = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
};
function mz({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(o, a = {}, l = e == null ? void 0 : e()) {
      (this.id = lee++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.potentialNodes = new Map()),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (Uu.totalNodes =
            Uu.resolvedTargetDeltas =
            Uu.recalculatedProjection =
              0),
            this.nodes.forEach(fee),
            this.nodes.forEach(mee),
            this.nodes.forEach(gee),
            this.nodes.forEach(hee),
            aee(Uu);
        }),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.elementId = o),
        (this.latestValues = a),
        (this.root = l ? l.root || l : this),
        (this.path = l ? [...l.path, l] : []),
        (this.parent = l),
        (this.depth = l ? l.depth + 1 : 0),
        o && this.root.registerPotentialNode(o, this);
      for (let u = 0; u < this.path.length; u++)
        this.path[u].shouldResetTransform = !0;
      this.root === this && (this.nodes = new oee());
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new NC()),
        this.eventHandlers.get(o).add(a)
      );
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o);
      l && l.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    registerPotentialNode(o, a) {
      this.potentialNodes.set(o, a);
    }
    mount(o, a = !1) {
      if (this.instance) return;
      (this.isSVG = o instanceof SVGElement && o.tagName !== "svg"),
        (this.instance = o);
      const { layoutId: l, layout: u, visualElement: c } = this.options;
      if (
        (c && !c.current && c.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.elementId && this.root.potentialNodes.delete(this.elementId),
        a && (u || l) && (this.isLayoutDirty = !0),
        n)
      ) {
        let d;
        const p = () => (this.root.updateBlockedByResize = !1);
        n(o, () => {
          (this.root.updateBlockedByResize = !0),
            d && d(),
            (d = tz(p, 250)),
            Np.hasAnimatedSinceResize &&
              ((Np.hasAnimatedSinceResize = !1), this.nodes.forEach(PD));
        });
      }
      l && this.root.registerSharedNode(l, this),
        this.options.animate !== !1 &&
          c &&
          (l || u) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: d,
              hasLayoutChanged: p,
              hasRelativeTargetChanged: m,
              layout: v,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const _ =
                  this.options.transition || c.getDefaultTransition() || Aee,
                { onLayoutAnimationStart: x, onLayoutAnimationComplete: g } =
                  c.getProps(),
                A = !this.targetLayout || !eE(this.targetLayout, v) || m,
                S = !p && m;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                S ||
                (p && (A || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(d, S);
                const w = { ...nz(_, "layout"), onPlay: x, onComplete: g };
                (c.shouldReduceMotion || this.options.layoutRoot) &&
                  ((w.delay = 0), (w.type = !1)),
                  this.startAnimation(w);
              } else
                !p && this.animationProgress === 0 && PD(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = v;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Xl.preRender(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(vee),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let c = 0; c < this.path.length; c++) {
        const d = this.path[c];
        (d.shouldResetTransform = !0),
          d.updateScroll("snapshot"),
          d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l) return;
      const u = this.getTransformTemplate();
      (this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners("willUpdate");
    }
    didUpdate() {
      if (this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(RD);
        return;
      }
      this.isUpdating &&
        ((this.isUpdating = !1),
        this.potentialNodes.size &&
          (this.potentialNodes.forEach(See), this.potentialNodes.clear()),
        this.nodes.forEach(pee),
        this.nodes.forEach(uee),
        this.nodes.forEach(cee),
        this.clearAllSnapshots(),
        zS.update(),
        zS.preRender(),
        zS.render());
    }
    clearAllSnapshots() {
      this.nodes.forEach(dee), this.sharedNodes.forEach(yee);
    }
    scheduleUpdateProjection() {
      Sr.preRender(this.updateProjection, !1, !0);
    }
    scheduleCheckAfterUnmount() {
      Sr.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const o = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = ii()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a &&
        a.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          o ? o.layoutBox : void 0
        );
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === o &&
        (a = !1),
        a &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: o,
            isRoot: i(this.instance),
            offset: t(this.instance),
          });
    }
    resetTransform() {
      if (!r) return;
      const o = this.isLayoutDirty || this.shouldResetTransform,
        a = this.projectionDelta && !pz(this.projectionDelta),
        l = this.getTransformTemplate(),
        u = l ? l(this.latestValues, "") : void 0,
        c = u !== this.prevTransformTemplateValue;
      o &&
        (a || Ou(this.latestValues) || c) &&
        (r(this.instance, u),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return (
        o && (l = this.removeTransform(l)),
        Mee(l),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: o } = this.options;
      if (!o) return ii();
      const a = o.measureViewportBox(),
        { scroll: l } = this.root;
      return l && (dl(a.x, l.offset.x), dl(a.y, l.offset.y)), a;
    }
    removeElementScroll(o) {
      const a = ii();
      Fs(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l],
          { scroll: c, options: d } = u;
        if (u !== this.root && c && d.layoutScroll) {
          if (c.isRoot) {
            Fs(a, o);
            const { scroll: p } = this.root;
            p && (dl(a.x, -p.offset.x), dl(a.y, -p.offset.y));
          }
          dl(a.x, c.offset.x), dl(a.y, c.offset.y);
        }
      }
      return a;
    }
    applyTransform(o, a = !1) {
      const l = ii();
      Fs(l, o);
      for (let u = 0; u < this.path.length; u++) {
        const c = this.path[u];
        !a &&
          c.options.layoutScroll &&
          c.scroll &&
          c !== c.root &&
          eh(l, { x: -c.scroll.offset.x, y: -c.scroll.offset.y }),
          Ou(c.latestValues) && eh(l, c.latestValues);
      }
      return Ou(this.latestValues) && eh(l, this.latestValues), l;
    }
    removeTransform(o) {
      const a = ii();
      Fs(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l];
        if (!u.instance || !Ou(u.latestValues)) continue;
        Zw(u.latestValues) && u.updateSnapshot();
        const c = ii(),
          d = u.measurePageBox();
        Fs(c, d),
          MD(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c);
      }
      return Ou(this.latestValues) && MD(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      (this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    resolveTargetDelta() {
      var o;
      const a = this.getLead();
      if (
        (this.isProjectionDirty ||
          (this.isProjectionDirty = a.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = a.isSharedProjectionDirty),
        !(
          ((!!this.resumingFrom || this !== a) &&
            this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        ))
      )
        return;
      const { layout: c, layoutId: d } = this.options;
      if (!(!this.layout || !(c || d))) {
        if (!this.targetDelta && !this.relativeTarget) {
          const p = this.getClosestProjectingParent();
          p && p.layout
            ? ((this.relativeParent = p),
              (this.relativeTarget = ii()),
              (this.relativeTargetOrigin = ii()),
              zp(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                p.layout.layoutBox
              ),
              Fs(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = ii()), (this.targetWithTransforms = ii())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? T$(this.target, this.relativeTarget, this.relativeParent.target)
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : Fs(this.target, this.layout.layoutBox),
                lz(this.target, this.targetDelta))
              : Fs(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const p = this.getClosestProjectingParent();
            p &&
            !!p.resumingFrom == !!this.resumingFrom &&
            !p.options.layoutScroll &&
            p.target
              ? ((this.relativeParent = p),
                (this.relativeTarget = ii()),
                (this.relativeTargetOrigin = ii()),
                zp(this.relativeTargetOrigin, this.target, p.target),
                Fs(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          Uu.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          Zw(this.parent.latestValues) ||
          az(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var o;
      const a = this.getLead(),
        l = !!this.resumingFrom || this !== a;
      let u = !0;
      if (
        ((this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty)) &&
          (u = !1),
        l &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (u = !1),
        u)
      )
        return;
      const { layout: c, layoutId: d } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(c || d))
      )
        return;
      Fs(this.layoutCorrected, this.layout.layoutBox),
        F$(this.layoutCorrected, this.treeScale, this.path, l);
      const { target: p } = a;
      if (!p) return;
      this.projectionDelta ||
        ((this.projectionDelta = Hp()),
        (this.projectionDeltaWithTransform = Hp()));
      const m = this.treeScale.x,
        v = this.treeScale.y,
        _ = this.projectionTransform;
      kp(this.projectionDelta, this.layoutCorrected, p, this.latestValues),
        (this.projectionTransform = TD(this.projectionDelta, this.treeScale)),
        (this.projectionTransform !== _ ||
          this.treeScale.x !== m ||
          this.treeScale.y !== v) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", p)),
        Uu.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), o)) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot,
        u = l ? l.latestValues : {},
        c = { ...this.latestValues },
        d = Hp();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a);
      const p = ii(),
        m = l ? l.source : void 0,
        v = this.layout ? this.layout.source : void 0,
        _ = m !== v,
        x = this.getStack(),
        g = !x || x.members.length <= 1,
        A = !!(
          _ &&
          !g &&
          this.options.crossfade === !0 &&
          !this.path.some(xee)
        );
      this.animationProgress = 0;
      let S;
      (this.mixTargetDelta = (w) => {
        const C = w / 1e3;
        BD(d.x, o.x, C),
          BD(d.y, o.y, C),
          this.setTargetDelta(d),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (zp(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            _ee(this.relativeTarget, this.relativeTargetOrigin, p, C),
            S && eE(this.relativeTarget, S) && (this.isProjectionDirty = !1),
            S || (S = ii()),
            Fs(S, this.relativeTarget)),
          _ &&
            ((this.animationValues = c), q$(c, u, this.latestValues, C, A, g)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = C);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (Xl.update(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = Sr.update(() => {
          (Np.hasAnimatedSinceResize = !0),
            (this.currentAnimation = Q$(0, bD, {
              ...o,
              onUpdate: (a) => {
                this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
              },
              onComplete: () => {
                o.onComplete && o.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const o = this.getStack();
      o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(bD),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let {
        targetWithTransforms: a,
        target: l,
        layout: u,
        latestValues: c,
      } = o;
      if (!(!a || !l || !u)) {
        if (
          this !== o &&
          this.layout &&
          u &&
          gz(this.options.animationType, this.layout.layoutBox, u.layoutBox)
        ) {
          l = this.target || ii();
          const d = Ss(this.layout.layoutBox.x);
          (l.x.min = o.target.x.min), (l.x.max = l.x.min + d);
          const p = Ss(this.layout.layoutBox.y);
          (l.y.min = o.target.y.min), (l.y.max = l.y.min + p);
        }
        Fs(a, l),
          eh(a, c),
          kp(this.projectionDeltaWithTransform, this.layoutCorrected, a, c);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new ree()),
        this.sharedNodes.get(o).add(a);
      const u = a.options.initialPromotionConfig;
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity:
          u && u.shouldPreserveFollowOpacity
            ? u.shouldPreserveFollowOpacity(a)
            : void 0,
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? (o = this.getStack()) === null || o === void 0
          ? void 0
          : o.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o) return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const u = this.getStack();
      u && u.promote(this, l),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: o } = this.options;
      if (!o) return;
      let a = !1;
      const { latestValues: l } = o;
      if (((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a))
        return;
      const u = {};
      for (let c = 0; c < CD.length; c++) {
        const d = "rotate" + CD[c];
        l[d] && ((u[d] = l[d]), o.setStaticValue(d, 0));
      }
      o.render();
      for (const c in u) o.setStaticValue(c, u[c]);
      o.scheduleRender();
    }
    getProjectionStyles(o = {}) {
      var a, l;
      const u = {};
      if (!this.instance || this.isSVG) return u;
      if (this.isVisible) u.visibility = "";
      else return { visibility: "hidden" };
      const c = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (u.opacity = ""),
          (u.pointerEvents = Qv(o.pointerEvents) || ""),
          (u.transform = c ? c(this.latestValues, "") : "none"),
          u
        );
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const _ = {};
        return (
          this.options.layoutId &&
            ((_.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (_.pointerEvents = Qv(o.pointerEvents) || "")),
          this.hasProjected &&
            !Ou(this.latestValues) &&
            ((_.transform = c ? c({}, "") : "none"), (this.hasProjected = !1)),
          _
        );
      }
      const p = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(),
        (u.transform = TD(
          this.projectionDeltaWithTransform,
          this.treeScale,
          p
        )),
        c && (u.transform = c(p, u.transform));
      const { x: m, y: v } = this.projectionDelta;
      (u.transformOrigin = `${m.origin * 100}% ${v.origin * 100}% 0`),
        d.animationValues
          ? (u.opacity =
              d === this
                ? (l =
                    (a = p.opacity) !== null && a !== void 0
                      ? a
                      : this.latestValues.opacity) !== null && l !== void 0
                  ? l
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : p.opacityExit)
          : (u.opacity =
              d === this
                ? p.opacity !== void 0
                  ? p.opacity
                  : ""
                : p.opacityExit !== void 0
                ? p.opacityExit
                : 0);
      for (const _ in E_) {
        if (p[_] === void 0) continue;
        const { correct: x, applyTo: g } = E_[_],
          A = u.transform === "none" ? p[_] : x(p[_], d);
        if (g) {
          const S = g.length;
          for (let w = 0; w < S; w++) u[g[w]] = A;
        } else u[_] = A;
      }
      return (
        this.options.layoutId &&
          (u.pointerEvents = d === this ? Qv(o.pointerEvents) || "" : "none"),
        u
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0
          ? void 0
          : a.stop();
      }),
        this.root.nodes.forEach(RD),
        this.root.sharedNodes.clear();
    }
  };
}
function uee(n) {
  n.updateLayout();
}
function cee(n) {
  var e;
  const t =
    ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    n.snapshot;
  if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) {
    const { layoutBox: i, measuredBox: r } = n.layout,
      { animationType: s } = n.options,
      o = t.source !== n.layout.source;
    s === "size"
      ? Lo((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            m = Ss(p);
          (p.min = i[d].min), (p.max = p.min + m);
        })
      : gz(s, t.layoutBox, i) &&
        Lo((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            m = Ss(i[d]);
          p.max = p.min + m;
        });
    const a = Hp();
    kp(a, i, t.layoutBox);
    const l = Hp();
    o ? kp(l, n.applyTransform(r, !0), t.measuredBox) : kp(l, i, t.layoutBox);
    const u = !pz(a);
    let c = !1;
    if (!n.resumeFrom) {
      const d = n.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: p, layout: m } = d;
        if (p && m) {
          const v = ii();
          zp(v, t.layoutBox, p.layoutBox);
          const _ = ii();
          zp(_, i, m.layoutBox),
            eE(v, _) || (c = !0),
            d.options.layoutRoot &&
              ((n.relativeTarget = _),
              (n.relativeTargetOrigin = v),
              (n.relativeParent = d));
        }
      }
    }
    n.notifyListeners("didUpdate", {
      layout: i,
      snapshot: t,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: u,
      hasRelativeTargetChanged: c,
    });
  } else if (n.isLead()) {
    const { onExitComplete: i } = n.options;
    i && i();
  }
  n.options.transition = void 0;
}
function fee(n) {
  Uu.totalNodes++,
    n.parent &&
      (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
      n.isSharedProjectionDirty ||
        (n.isSharedProjectionDirty = !!(
          n.isProjectionDirty ||
          n.parent.isProjectionDirty ||
          n.parent.isSharedProjectionDirty
        )),
      n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty));
}
function hee(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function dee(n) {
  n.clearSnapshot();
}
function RD(n) {
  n.clearMeasurements();
}
function pee(n) {
  const { visualElement: e } = n.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform();
}
function PD(n) {
  n.finishAnimation(), (n.targetDelta = n.relativeTarget = n.target = void 0);
}
function mee(n) {
  n.resolveTargetDelta();
}
function gee(n) {
  n.calcProjection();
}
function vee(n) {
  n.resetRotation();
}
function yee(n) {
  n.removeLeadSnapshot();
}
function BD(n, e, t) {
  (n.translate = On(e.translate, 0, t)),
    (n.scale = On(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint);
}
function ID(n, e, t, i) {
  (n.min = On(e.min, t.min, i)), (n.max = On(e.max, t.max, i));
}
function _ee(n, e, t, i) {
  ID(n.x, e.x, t.x, i), ID(n.y, e.y, t.y, i);
}
function xee(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const Aee = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
function See(n, e) {
  let t = n.root;
  for (let s = n.path.length - 1; s >= 0; s--)
    if (n.path[s].instance) {
      t = n.path[s];
      break;
    }
  const r = (t && t !== n.root ? t.instance : document).querySelector(
    `[data-projection-id="${e}"]`
  );
  r && n.mount(r, !0);
}
function DD(n) {
  (n.min = Math.round(n.min)), (n.max = Math.round(n.max));
}
function Mee(n) {
  DD(n.x), DD(n.y);
}
function gz(n, e, t) {
  return (
    n === "position" || (n === "preserve-aspect" && !Kw(ED(e), ED(t), 0.2))
  );
}
const wee = mz({
    attachResizeListener: (n, e) => Ea(n, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  KS = { current: void 0 },
  vz = mz({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!KS.current) {
        const n = new wee(0, {});
        n.mount(window), n.setOptions({ layoutScroll: !0 }), (KS.current = n);
      }
      return KS.current;
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === "fixed",
  }),
  Eee = {
    pan: { Feature: V$ },
    drag: { Feature: G$, ProjectionNode: vz, MeasureLayout: fz },
  },
  Tee = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
  ]),
  yz = (n) => Tee.has(n),
  Cee = (n) => Object.keys(n).some(yz),
  LD = (n) => n === Vc || n === wt,
  FD = (n, e) => parseFloat(n.split(", ")[e]),
  ND =
    (n, e) =>
    (t, { transform: i }) => {
      if (i === "none" || !i) return 0;
      const r = i.match(/^matrix3d\((.+)\)$/);
      if (r) return FD(r[1], e);
      {
        const s = i.match(/^matrix\((.+)\)$/);
        return s ? FD(s[1], n) : 0;
      }
    },
  bee = new Set(["x", "y", "z"]),
  Ree = zx.filter((n) => !bee.has(n));
function Pee(n) {
  const e = [];
  return (
    Ree.forEach((t) => {
      const i = n.getValue(t);
      i !== void 0 &&
        (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0));
    }),
    e.length && n.render(),
    e
  );
}
const OD = {
    width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
      n.max - n.min - parseFloat(e) - parseFloat(t),
    height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
      n.max - n.min - parseFloat(e) - parseFloat(t),
    top: (n, { top: e }) => parseFloat(e),
    left: (n, { left: e }) => parseFloat(e),
    bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
    right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
    x: ND(4, 13),
    y: ND(5, 14),
  },
  Bee = (n, e, t) => {
    const i = e.measureViewportBox(),
      r = e.current,
      s = getComputedStyle(r),
      { display: o } = s,
      a = {};
    o === "none" && e.setStaticValue("display", n.display || "block"),
      t.forEach((u) => {
        a[u] = OD[u](i, s);
      }),
      e.render();
    const l = e.measureViewportBox();
    return (
      t.forEach((u) => {
        const c = e.getValue(u);
        c && c.jump(a[u]), (n[u] = OD[u](l, s));
      }),
      n
    );
  },
  Iee = (n, e, t = {}, i = {}) => {
    (e = { ...e }), (i = { ...i });
    const r = Object.keys(e).filter(yz);
    let s = [],
      o = !1;
    const a = [];
    if (
      (r.forEach((l) => {
        const u = n.getValue(l);
        if (!n.hasValue(l)) return;
        let c = t[l],
          d = Wd(c);
        const p = e[l];
        let m;
        if (C_(p)) {
          const v = p.length,
            _ = p[0] === null ? 1 : 0;
          (c = p[_]), (d = Wd(c));
          for (let x = _; x < v; x++) m ? P_(Wd(p[x]) === m) : (m = Wd(p[x]));
        } else m = Wd(p);
        if (d !== m)
          if (LD(d) && LD(m)) {
            const v = u.get();
            typeof v == "string" && u.set(parseFloat(v)),
              typeof p == "string"
                ? (e[l] = parseFloat(p))
                : Array.isArray(p) && m === wt && (e[l] = p.map(parseFloat));
          } else
            d != null &&
            d.transform &&
            m != null &&
            m.transform &&
            (c === 0 || p === 0)
              ? c === 0
                ? u.set(m.transform(c))
                : (e[l] = d.transform(p))
              : (o || ((s = Pee(n)), (o = !0)),
                a.push(l),
                (i[l] = i[l] !== void 0 ? i[l] : e[l]),
                u.jump(p));
      }),
      a.length)
    ) {
      const l = a.indexOf("height") >= 0 ? window.pageYOffset : null,
        u = Bee(e, n, a);
      return (
        s.length &&
          s.forEach(([c, d]) => {
            n.getValue(c).set(d);
          }),
        n.render(),
        Ox && l !== null && window.scrollTo({ top: l }),
        { target: u, transitionEnd: i }
      );
    } else return { target: e, transitionEnd: i };
  };
function Dee(n, e, t, i) {
  return Cee(e) ? Iee(n, e, t, i) : { target: e, transitionEnd: i };
}
const Lee = (n, e, t, i) => {
    const r = J$(n, e, i);
    return (e = r.target), (i = r.transitionEnd), Dee(n, e, t, i);
  },
  tE = { current: null },
  _z = { current: !1 };
function Fee() {
  if (((_z.current = !0), !!Ox))
    if (window.matchMedia) {
      const n = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (tE.current = n.matches);
      n.addListener(e), e();
    } else tE.current = !1;
}
function Nee(n, e, t) {
  const { willChange: i } = e;
  for (const r in e) {
    const s = e[r],
      o = t[r];
    if (Kr(s)) n.addValue(r, s), R_(i) && i.add(r);
    else if (Kr(o)) n.addValue(r, zh(s, { owner: n })), R_(i) && i.remove(r);
    else if (o !== s)
      if (n.hasValue(r)) {
        const a = n.getValue(r);
        !a.hasAnimated && a.set(s);
      } else {
        const a = n.getStaticValue(r);
        n.addValue(r, zh(a !== void 0 ? a : s, { owner: n }));
      }
  }
  for (const r in t) e[r] === void 0 && n.removeValue(r);
  return e;
}
const xz = Object.keys(bm),
  Oee = xz.length,
  UD = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ],
  Uee = EC.length;
class kee {
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: i,
      reducedMotionConfig: r,
      visualState: s,
    },
    o = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.scheduleRender = () => Sr.render(this.render, !1, !0));
    const { latestValues: a, renderState: l } = s;
    (this.latestValues = a),
      (this.baseTarget = { ...a }),
      (this.initialValues = t.initial ? { ...a } : {}),
      (this.renderState = l),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = i),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = o),
      (this.isControllingVariants = kx(t)),
      (this.isVariantNode = ck(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: u, ...c } = this.scrapeMotionValuesFromProps(t, {});
    for (const d in c) {
      const p = c[d];
      a[d] !== void 0 && Kr(p) && (p.set(a[d], !1), R_(u) && u.add(d));
    }
  }
  scrapeMotionValuesFromProps(e, t) {
    return {};
  }
  mount(e) {
    (this.current = e),
      this.projection && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, i) => this.bindToMotionValue(i, t)),
      _z.current || Fee(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : tE.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(),
      Xl.update(this.notifyUpdate),
      Xl.render(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) this.features[e].unmount();
    this.current = null;
  }
  bindToMotionValue(e, t) {
    const i = Gc.has(e),
      r = t.on("change", (o) => {
        (this.latestValues[e] = o),
          this.props.onUpdate && Sr.update(this.notifyUpdate, !1, !0),
          i && this.projection && (this.projection.isTransformDirty = !0);
      }),
      s = t.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      r(), s();
    });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  loadFeatures({ children: e, ...t }, i, r, s, o) {
    let a, l;
    for (let u = 0; u < Oee; u++) {
      const c = xz[u],
        {
          isEnabled: d,
          Feature: p,
          ProjectionNode: m,
          MeasureLayout: v,
        } = bm[c];
      m && (a = m),
        d(t) &&
          (!this.features[c] && p && (this.features[c] = new p(this)),
          v && (l = v));
    }
    if (!this.projection && a) {
      this.projection = new a(
        s,
        this.latestValues,
        this.parent && this.parent.projection
      );
      const {
        layoutId: u,
        layout: c,
        drag: d,
        dragConstraints: p,
        layoutScroll: m,
        layoutRoot: v,
      } = t;
      this.projection.setOptions({
        layoutId: u,
        layout: c,
        alwaysMeasureLayout: !!d || (p && qf(p)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof c == "string" ? c : "both",
        initialPromotionConfig: o,
        layoutScroll: m,
        layoutRoot: v,
      });
    }
    return l;
  }
  updateFeatures() {
    for (const e in this.features) {
      const t = this.features[e];
      t.isMounted
        ? t.update(this.props, this.prevProps)
        : (t.mount(), (t.isMounted = !0));
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : ii();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  makeTargetAnimatable(e, t = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, t);
  }
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t);
    for (let i = 0; i < UD.length; i++) {
      const r = UD[i];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const s = e["on" + r];
      s && (this.propEventSubscriptions[r] = this.on(r, s));
    }
    (this.prevMotionValues = Nee(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  getVariantContext(e = !1) {
    if (e) return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const i = this.parent ? this.parent.getVariantContext() || {} : {};
      return (
        this.props.initial !== void 0 && (i.initial = this.props.initial), i
      );
    }
    const t = {};
    for (let i = 0; i < Uee; i++) {
      const r = EC[i],
        s = this.props[r];
      (Cm(s) || s === !1) && (t[r] = s);
    }
    return t;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    t !== this.values.get(e) &&
      (this.removeValue(e), this.bindToMotionValue(e, t)),
      this.values.set(e, t),
      (this.latestValues[e] = t.get());
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let i = this.values.get(e);
    return (
      i === void 0 &&
        t !== void 0 &&
        ((i = zh(t, { owner: this })), this.addValue(e, i)),
      i
    );
  }
  readValue(e) {
    return this.latestValues[e] !== void 0 || !this.current
      ? this.latestValues[e]
      : this.readValueFromInstance(this.current, e, this.options);
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var t;
    const { initial: i } = this.props,
      r =
        typeof i == "string" || typeof i == "object"
          ? (t = DC(this.props, i)) === null || t === void 0
            ? void 0
            : t[e]
          : void 0;
    if (i && r !== void 0) return r;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Kr(s)
      ? s
      : this.initialValues[e] !== void 0 && r === void 0
      ? void 0
      : this.baseTarget[e];
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new NC()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
}
class Az extends kee {
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: i }) {
    delete t[e], delete i[e];
  }
  makeTargetAnimatableFromInstance(
    { transition: e, transitionEnd: t, ...i },
    { transformValues: r },
    s
  ) {
    let o = lq(i, e || {}, this);
    if ((r && (t && (t = r(t)), i && (i = r(i)), o && (o = r(o))), s)) {
      oq(this, i, o);
      const a = Lee(this, i, o, t);
      (t = a.transitionEnd), (i = a.target);
    }
    return { transition: e, transitionEnd: t, ...i };
  }
}
function zee(n) {
  return window.getComputedStyle(n);
}
class Hee extends Az {
  readValueFromInstance(e, t) {
    if (Gc.has(t)) {
      const i = kC(t);
      return (i && i.default) || 0;
    } else {
      const i = zee(e),
        r = (gk(t) ? i.getPropertyValue(t) : i[t]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return uz(e, t);
  }
  build(e, t, i, r) {
    CC(e, t, i, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t) {
    return IC(e, t);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Kr(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
  renderInstance(e, t, i, r) {
    Ak(e, t, i, r);
  }
}
class Gee extends Az {
  constructor() {
    super(...arguments), (this.isSVGTag = !1);
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (Gc.has(t)) {
      const i = kC(t);
      return (i && i.default) || 0;
    }
    return (t = Sk.has(t) ? t : BC(t)), e.getAttribute(t);
  }
  measureInstanceViewportBox() {
    return ii();
  }
  scrapeMotionValuesFromProps(e, t) {
    return wk(e, t);
  }
  build(e, t, i, r) {
    RC(e, t, i, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(e, t, i, r) {
    Mk(e, t, i, r);
  }
  mount(e) {
    (this.isSVGTag = PC(e.tagName)), super.mount(e);
  }
}
const Vee = (n, e) =>
    TC(n)
      ? new Gee(e, { enableHardwareAcceleration: !1 })
      : new Hee(e, { enableHardwareAcceleration: !0 }),
  Wee = { layout: { ProjectionNode: vz, MeasureLayout: fz } },
  Xee = { ...S$, ...LZ, ...Eee, ...Wee },
  D_ = jQ((n, e) => AZ(n, e, Xee, Vee)),
  kD = (n, e, t, i) => ({
    hidden: {
      x: n === "left" ? "-100%" : n === "right" ? "100%" : 0,
      y: n === "up" || n === "down" ? "100%" : 0,
    },
    show: {
      x: 0,
      y: 0,
      transition: { type: e, delay: t, duration: i, ease: "easeOut" },
    },
  }),
  Jee = (n, e) => ({
    hidden: {},
    show: { transition: { staggerChildren: n, delayChildren: e || 0 } },
  }),
  og = (n, e) =>
    function () {
      return Dt(D_.section, {
        variants: Jee(),
        initial: "hidden",
        whileInView: "show",
        viewport: { once: !0, amount: 0.25 },
        className: `${pi.padding} max-w-7xl mx-auto relative z-0`,
        children: [
          _e("span", { className: "hash-span", id: e, children: "" }),
          _e(n, {}),
        ],
      });
    };
Hc.registerPlugin(Gt);
const zD = (n, e, t = 0) => {
    j.useEffect(() => {
      n.current &&
        Hc.fromTo(n.current, e.from, {
          ...e.to,
          delay: t,
          scrollTrigger: {
            trigger: n.current,
            start: "top 85%",
            toggleActions: "play none none reverse",
          },
        });
    }, [n, e, t]);
  },
  jee = () => {
    const n = j.useRef(null),
      e = j.useRef(null);
    return (
      zD(n, {
        from: { opacity: 0, x: -50 },
        to: { opacity: 1, x: 0, duration: 1, ease: "power2.out" },
      }),
      zD(
        e,
        {
          from: { opacity: 0, y: 50 },
          to: { opacity: 1, y: 0, duration: 1.2, ease: "power3.out" },
        },
        0.3
      ),
      Dt("div", {
        className: "mt-4",
        children: [
          Dt("div", {
            ref: n,
            children: [
              _e("p", {
                className: pi.sectionSubText,
                children: "Introduction",
              }),
              _e("h2", {
                className: pi.sectionHeadText,
                children: "Overview.",
              }),
            ],
          }),
          _e("p", {
            ref: e,
            className:
              "mt-3 text-secondary text-[17px] max-w-3xl leading-[30px]",
            children:
              "I'm a skilled video editor with expertise in Premiere Pro and After Effects. I use AI tools to speed up edits and add a creative edge. My work blends clean visuals with storytelling and generating over 50 millions+ views for my clients and increases there maximum ROI through my editing.",
          }),
        ],
      })
    );
  },
  Yee = og(jee, "about"),
  pte = "assets/2swag.jpg",
  Ste = "assets/SNK.jpg",
  Tte = "assets/Justin.jpg",
  Kee = "assets/ae-fa46086a.png",
  Qee = "assets/ai-d39f1241.png",
  Zee = "assets/aws-048c56c4.png",
  qee = "assets/css-79a7f026.png",
  $ee = "assets/cutting-f7263590.jpg",
  ete = "assets/docker-602a695a.png",
  tte = "assets/enrico-dc75bcba.png",
  nte = "assets/express-612b36c0.png",
  ite = "assets/fi-bbf1905b.png",
  rte = "assets/figma-184a11e6.png",
  ste = "assets/framer-d9a31b62.png",
  ote =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANG0lEQVR4nO2dX6xcRR2AD9QYgpYElEDv3fltqdUSHtSISNWIiIE09vbuzMKa+GBq4p/4hoIGEx/qSxOiL1T62Adj4kN90gegSXnQxAdCIiYkloQKSKKQpo3c7szeikrXzPZCW3r39uzdc2bOzPm+5Jc0t7t7dn4z386cc+bMFAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQFs415cdVqtHrJZjzqgTToudhFEn/N/8//nXxP6eAHAJIy13Oi3HnZFxqdBy3L+HJAJEZLy/e5016og1cr60vGvh3+Pf6z+DSgQIzGhZLVgjz80q7hUia/XC6mCHUIEAgfDCWS2vzCvvJRK/zrkxQILyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMbSe1OVFYmgtuciLxNBKnJE/xJaucomNeu1cr7s9dm4Baie3HpieGFoHEgMkDhIDJA4SAyQOEgMkDhIDNASn5YDV8vis70NigMg4LT++eFsFibnFBMngjPzoynujSIzE0Hhsv/vo9AkOSIzE0Fj8vrtXn6WExEgMjcMa9cPyUw2RGImhMVijfjD7fGEkRmKIjtXq4c1P+kdiJIZojLR8z+9wP9+TO0iMxBAcp+W788qLxDyKCBFwRr5TlbxIjMQQENeTb1st71QpLxIjMSQ2bJ4qsVE/m/V7+SVs/FI2l/8YqDeslmecVof9ebYPp9Uhq9VTTqtTdZahwlywPA80v+etSmJn5EVn5Aln5DPjorhm2mvHB4prR8uLd1stB61Wb8YWFYmhVlxPfSuUvPNcnd4M46Vt1zsjjzmj3oot6/RcqNfP9WVHiHxAZjit9oeWN7TEntGgs2i1PB9bViSGynB9+WYseecZTs/ZGx+NLesGueCcGMphtfq6NfLfRjTcgD3xeFBssUY9HbvM03PBcBqugjUyaIq8MSRe2Ss3Oi0vxy4zEsPMDI081DR5Y0g87KkvxS4vEkOyw+ZpMdTdfqhqndxHbkCZp/6gcU4MKfS8lzTYf9t9t90SqtZGpnNX7DIjMVwV36tZrf7T/MYqvwtdnc7IycbnRXNhq7WMTNekIK+PkVbfD50fp9UvY5e73I+b4hZT2xhp1bNavR278ZUWeHnx7tA5clqWYpcbieEKRj21LyV5fQwHt94cuipX9nV2xi43EsNlONPZY7U6F7uxzRrjwR0fDF2Vp5d3bY1d7pkl1pwTZ4vrd7/mr+bGbmSbEnhp2/Wh8+VnZsUu96YkNpwTZ4fT6oEUe953Y7W3oELn7MyenTfELvemJdb0xNmQurwTgXX386Hz5h/ji13uuSQ29MTJY42632pZjd2Y5m6MWj0S42Jf7HIjcYuxPflqDvJeEFh+Hzx/Wv0idrmRuKXYfvcr1sgoduOpTmD1dsiplH5ZnhRmYrmy+WM4nQ621703J3nfC61+GvJ2W/TyInH7GPbli06Ljd1Y6gl11hnZFiKPq4MdYrW8Er/M1Ybl6nRzmTzHmq28a6HVb0Llc70la3MIy3C6eZztyRecUcPYjSNIA9Tq4VB5pSeG2mmTvBcElv9Z3flGqKZFTwy1MTLd3WvnhtHFCiqx3yVCq59stIh7lSAxVI7fhcAZ+VdsmaKGlj8Ol+WOEM2L4TRUvORLc3cUCH6PWKtfj3Tnc3U3MXpimJvRg+qzyLu+zGVz6Iz81hn1Vy/krPlHYtg0rtf9tDNyJnav19Qoncc59x5iOA0zg7zVC4zEst4pCRuqVY0z2z9Fz1uPwEgsSFwn9sHFTzojp2MPT3MWGIkFietg2O/e3vSNqHMRGIkFiZE3bYGRWJC4Cs4ub99ltXojdo/WRoGRWJAYedMWGIkFiTfV8+qFT1gj/4zdk6UaVQqMxILEM8nbX/w48jZLYCQWJEbedHvgeR+CX2/apb+2Mdl/WKvDfuNyH06rQ1arp5xWp2KPYlyN+cgSvweP1fKP2JWSQ5TNechG69/jjLzojDzhnyDb6BHI8YHiWr+Rm9VysOm3Dy0SF8Vqf3s3x2VbchQ49DRDv52MM/JYkx9csW2edom86Qkco9GOBp1Fq+X52LK6huSjEZzbJ7f5gsdOfm5RNv+pDR/XeuOjsfPrGpKPqIyW1QLD5rQFjiLxl4sPOC3HY8vqNsiHb9tFzoz3d6+zRp6Lnexco2w9pDp8XNkrNzotL8fOs5uejz/H2Ao2GNaoI7GTnHOUrYdKG23gntjvvBE7z27jfBwpcn0g32p5J3aCc47SdVF1ow3cE0/uIzcg3269XBg5P9JyZ5EbTT5/ySVK10Utx+/sKYIuahg/31NDy/EiJ1LfLDqVKFsfNRz7ZKg1qt/FGvVq7HxvFFndWrL97qOxE9qGKFsfVR/XGvXzelvQOmXQ6lDsfDdtU/basFqOxU5oG6JsfVR93FFP7au3Ba1TBi1LsfO9Ufg2X+SC0+ql2AltQ5SujwyGi34OvWtAzqeGVi8VudCmzcdiRvn6qPa4p5d3bS0C44/pGpDz6aGGRS4gcN4CjwfFliIw/pguuqRtEZghdN4C33/Lh4rAJNADnyhygYtYeQvMObDkfRHLX1KP/4uYf5StjxqOvbfeFpTiVWiVz22ktVUZoic19yhbH5UfW6tD9bag9cqgnoyd79ZM5PAwlTJfgf2sqCIwjZ6JpTObSunxE7z9RO/oyc04ytZFHcf285OLQDR5LrTN9WEGD48T5iuwf0KoCESzn0ZSeT5O6OGB/nwFXut97qt/w7vOPbEldW19oN/Dkjr5CuyfSloZdG6qq+34z3ZG/hZbVNfWJXXeZXWwQ6yWV2InPbcom/96v4d61q9fVcfMK2vU07Fz7NaJdq5Muc6q/UQOAk/iaJVDySavSmnbtCLl+6EnrrYxlc17oIb9F7/2d87rQts29rzvB4nzFHgSWqzf++jMnp03zNou/PzqJu/MYJH3IgynMxX4YmN/0+93NDLd3X7/ow33RjLd3U3fG8m2edg8DSTOV+DLQqtTk4tRl+9OeHjtb43fndAi73QYTrdA4ITDMmy+OkiMwLFFdcg7H0hMDxxbWEfPi8ShG1rZjMcWIqWwDJvpiRE4vogOeePAcJoeGHkTB4kZQtPzJg4Scw7MsDlxkJiLWJzzJg4ScxWaC1aJw7TL99/qkHesVk+VzZ9/LZuty8X8MT0yPEh8YQE1a+RXK1p9bNb8+ff497Z9oUGLvPFos8RWq7/bXvfeeXPoP8N/VuzyIG9LaeM58eQB90H31qpyOFza9lGn1Z/alUPFw/hNoU09sV/p4tTg5g9XnUP/mf6zW5LD13iet2G0QWL/kPtqb0HVlUP/2U1+kB55Myf34fTQyEN159AaGWQrr2bY3Hiy7YkD7reT4z5WlmFzOuTYE1uj7g+VP6fVA1nlTtPzJkdmPfHJcVFcEyp3/lj+mFnIa7hglSwZ9cRPhM6d3/M3eXk1PW/y5CDxsCcPhs6bv2AWu9zIC1kMp4f97u2hq9IfM3a5NxuWYXN+pNwTn9ULHwmdr8nsrBTl1QybsyXVnriO3f6uhj9mcvIaLlhlT4o9sd8nKHSeTi/v2pqUvJqetzWk1hPH2AFvZV9nZzLyGnre1pGYxHtD58dpWWpAuZEXMhhOa3UodD06o56MXu6rhGXYDClI7B+4D11T1qhXY5cbeSGb4fTIdO4KVZ3+WI2Wl3NeSK0ntlqeCVVrVsux5uaBq82QqsRG7qu78ob9zj2xy4m8kKXE/rzUz5Cqq3pXBp2bmvoUEj0vZCGxM+rZOmZmjQfFFmvU0/HLh7yQ/4Wto+OlbddXVdH+s/xnNqBcVwQXrCDLntivILna396dt3pHg87iZJnaJpaRC1aQs8ROi7VaHj+zZ+cNs5bLz692Rh5zRr0VvRzICy0eTk+Wm7VaDo5Md/f4QHHttHL4//Ov8a9t8vKxDJuhdRK/F1qdmlyM0uqw7519TP594W+non8/5IVYNHo4nUFwzgu1g8TIC4mDxPS8kDhIzLAZEgeJOeeFxEFiLlhB4iAxV5shcZCYW0WQOEjMfV5IHCRmkgYkDhIzwwoSB4mZHgmJ03aJmdsMydNWiZEXsqFtEiMvZEdbJEZeyJbcJUZeyJ5cJUZeaA25SYy80DpykRh5obWkLjHyQutJVWLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFCMxoWS1YI89VIO8L/geBCgQIzHh/9zpr1BFr5PzM4ho579/rP4OKA4jISMudTsvx0gJrOe7fQ6UBNIhzfdlhtXrEajnmjDrhtNhJGHXC/83/n39N7O8JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFCE4v/t8177cNMPugAAAABJRU5ErkJggg==",
  ate = "assets/gsap-e19a1565.png",
  lte = "assets/html-92b76a73.png",
  ute =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAOgElEQVR4nO2dCdCVZRXHz8Pnwi4groElmijuK6m4YCqJpZmJqJla40qGWjgYZZQL5p4GJZlboKKTGzoouWSAiQsuqONY42Q1LVrZYlpZnebcy51B6uO7977LeZ/7/H4z/wGGmfve5zznf577vu+ziAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtIW+JIqIQafkgKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyB/Sp+yKQJHwmlft+3l4kumiN62dmixx8WdJ9dg246LOjggUH79A4aQv3v79sg6Oab1P//pAlBL50iev9s0b8tq3bBkdTwDnjsisHA7zwj+v1viB62f9C+vbN9395rBx03JuhV00TfXFrF/kgM74DHriob+A8/EZ16YtChg7N9x+40oF/QyccGfXVhlfojMbwDHruqaOB3l4teMkV00IBijLuq1loz6PRJov94rgr9kRjeAY9dVTPwy/eJ7rZtOcZdVVtvHvSp2737IzG8DRC7qmTghdeWN+p2p769g94zEwNj4AqYMyYDz7tcdI0uX/PKCtn3mP01r/5IDG8DxK4qGPjumdUxr6yQvY6aezEGxsAVMGmVDWz3vAP7+xtWunnltGRu2f2RGN4GiF2eBranvttu4W9UWY3WHxL0tYcwMAaugFmrZuDzJ2e/fhkaN6a82WaSGt4GiF1eBv79Y6L9+/qbs1ndcCEGxsAVMGxVDDztZH9TtqIh64Ra0Sm+PxLD2wCxy8PANtNqw6H+pmxWgwcGvWZ6Wf2RGN4GiF0eBr732/nd+24/MugVU0WfuUP09cX11Ub259J5oldPE917l/oroXY//9hDgr6xpMz+SAxvA8QuDwNPOjq7cfv1qd+X/ufFnq9nr4J22LK1z990WKgtPyy/PxLD2wCxy8PANuc46/vZR29qfR3xxPE9f3ZXV9Azjwv61tNe/ZEY3gaIXWUb+O/PSs0kWa553ufba+u/losefuDqf44/eZt3fySGtwFiV9kGfnF+tmvarht/far99trIOmqz//3MGWeK/vP5KvRHYngHPHaVbeAHr8t2zQP2yD6pwh54NeZejx0d9JUFVeqPxPAOeOwq28C2cCHL9T57eD6zor46SfTa85p7CKal9kdieAc8dpVt4NuvzHZN28ius/sjMbwDHrvKNnDWd8AH7omBOwpvA8Susg38yA2S+f2v7VLZuf2RGN4Bj11lG9geGGW95qxzO7k/EsM74LGrbAPb6NmrV7Zrrjso6E/v79T+SAzvgMeusg1s2nJEtmuaRgwPtd08Oq8/EsM74LHLw8C2QCDrdU22Fc+NM6r3Kkgz9UdieAc8dnkY+KaL8t2Jw1YcPXZzp/RHYngHPHZ5GNiOTFlzjfwM3JAdZLZgduz9kRjeAY9dHgY2fXI1iwqyasetgt5yaTXmNmvL/ZEY3gGPXV4GtuWARRm4ITti1FYu/XZRTP2RGN4Bj11eBjbZrKqiTWxae62gnz406LN3xtAfieEd8NjlaeDn75LayYBlmHjl1UwPfLe6T64lNbwDHrs8DWz6+uk+e0NvNzLozZeI/vsF/z54b38khnfAY5e3gc1AB+9TvoEbsu19bruiSv2RGN4Bj13eBja9uVRqI6KXiUWCfvhD/mcDY+AKGCI2VcHApt8tzr7ZXVZ1dQX94gm+q50kNbwNELuqYmDTHx+X2mQMTxOLBN1qRNAnnDa3k9TwNkDsqpKBGycW2iiYdcVSVq3RFfSCM8p/Wi2p4W2A2FU1Azf0w+9JbSKG92h81MGhthUuBsbA7maNycAmO0zshMP8R+OD9irvvlhSw9sAsavKBl55G9j9Rvua+JCxobYxPAbGwO6mjc3ADc2fJbrLNn4mPuv44tsqqeFtgNgVk4EbWjRH9KP7Zjt1sB2FEGq7ahbbH4nhbYDYFaOBG3ruzvo9sh12VpaJN14/29EuPfdHYngbIHbFbOCVZ3JdeY7o+zcux8TnnlZcmyU1vJMndnWCgRt6d7norZeJ7jSqWAMP7B/0z08U1R+J4Z00sauTDLyyFl4rtfnNRZn4m18qqj8SwztRYlenGrghO+93/93zN/Do7Yppt6SGd4LErk43cEN3Xi26wbr5GbhXr6C/frSI/kgM78SIXakY2GR7Y+21c34mnnd5Ef2RGN5JEbtSMrDpradF99gxHwN/4YT82y6p4Z0QMcvm96ZmYNNrD0ntlMOsbT94HwyMgR0T+fXF1TSwLWIouu02LTJr27f5IAbGwE0m3M8flNrWqLboPa8kthP+sibxkQeFXN/jXnhGfXRcOq9YAy+Zm73t6w3BwBi4h0Sz0wVmnCnat3c9aU6ekF/S3Ped7El83Mfz+T7L737vQoVRmxW7DtemQ2Zte78+GBgD93CavW3vsuqE+rtn5pPENtplTeJTJ4bMo+75k6W2+fqqn33OScXeX2e9D+7qwsAYuJvXHXYEZ3erbQYPDPri/OwJvOdO2e8Dp3wm28buq5v2aNva2ESMIsxra3vt87O0vX9fDIyBV9kjeda5UjNoT8lj281kOaX+hXvy2VDdFhG0c1tgG7o3cyrDpsOCvrEkfwO/ujB7+zdaDwNj4BUJZXsS79riYvWhg4P+6Mb2Rp8xOYy+pjuuau3adj6RnR7YyjXGjs7/fvjqadkNvN1IDJy8gf+0VPRzx9Tvp9qd0jfp6FA7c7eZxH17mdQ2asvDvCZbk9vsqDt9UvvnAo/fO799qexzNt8ke9uPGIeBkzbw3ItFNxyaj5HsKfVJE0LtyfJfnnzvdWxr1JfvE71iqtR+kuZlXrumPYTqqZ3LfiC6fQ4nL9i+WLYBfNa4n35MddcFS2p4m7Bd/eyB7A9RVie7jx4xPOjwDetGK+Ia9hCsmbbuvkN+17T7zgWz24u5/QyffGx+3+XB6/LPC0kNbyNmkY2YRRm4DH3l1OYMvHiO5L5/1d671I8JbWanSNss/pZLpfZuOa/r9+1dzHtqSQ1vE2aRLUfLY06ul1o5DGzi+OJ+adi9qE12ue4CqW06d89M0RtnSO1khUP3C7ruoPyvO3E864GTN7Al9mVn+5yPm1X287yVY0dsAYFtReP9vfPSw9cXU9QlNbxH0awyE4wb45+QrcoKT6tttZ+x3t87D+00qrXihYE72MCm3/xYdP0h/onZrGwktddf7bT1xCP8v38VH17pCklqeJsvz3nPZe5vnEUXndV+O+09dB6vlLw0oeD1z5Ia3sbLU3d9q9hXS3nIJkBkffpqvzi2+IB/W1rVsA3yXc6JgTvMwCZ7elr2kSHNymZR5bVO95cP5zuppGj171vOod+SGt6GK0L2sKdPQZMvsuiqafkvKLCn2d7tkh5kSx3vb3PyCAZO0MAmq/Z2Do938jY07eRi7v1spZFNyvBun3SjQQPaWzCCgRMegRv61SP5rNnNIvs5bxMiimynzaf+8intL+goStuPDPrSveX2uaSGt8nKWCN8zfTm1gjnLZvBZBuil9XWx28t/lyjZrTWmkGnnljslj4YOBEDr7xLx6c+Vl8+WMaoa69L7Jplt9PmNl9/gc+9ca9eQT9xQNBXFvj1s6SGt7HKlu2kYdvt/L89pLLKfsIeMra1Oc5FydYP28O8Mu6P1xkQ9JQjQ23JpXe7JTW8A+4l2zvZTsjbd7f63lFZRh3bCcS2uPnFw/7t6u5p9SVT6mbOa7KLvdO1bXptR5F3ctooIA9JangHvAqyA65tIf9XJ4kefmDQnbcOtamZNrJYstpobffQm2xUX8NrezmbYefPqm/u7v39W5GZbdGc+t5hpx1VPx1hhy1DbWMEa2OjmA3oV//3ZsNDbfsgWz1kC/Bvv7K+Ftu7HdqNJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBBoiiMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEg+/BceiofdqS/+vQAAAABJRU5ErkJggg==",
  cte = "assets/mongodb-54000b2b.png",
  fte = "assets/mui-87d5051f.png",
  hte = "assets/mysql-bc523966.png",
  dte = "assets/nodejs-d83eb6dd.png",
  mte = "assets/postgresql-366931b7.png",
  gte = "assets/pr-dbbb24f3.png",
  vte = "assets/ps-92835d93.png",
  yte = "assets/reactjs-966214a8.png",
  _te = "assets/redux-171787ca.png",
  xte = "assets/saqlain-21e80c60.jpg",
  Ate = "assets/sarthak-9a32fc54.png",
  Mte = "assets/tailwind-6ece120d.png",
  wte = "assets/threejs-fe1b0909.svg",
  Ete =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANMUlEQVR4nO2d+48V9RXAv//Gtw/balttayOpjVZr06TPqLRJ09Q+09Yaa01sapNWKqiAqCiU+MJXfSGC+ADxQa1AK0WMogJW2L3syrIvdpcL+95ln7B7mu8Y7GaD9N7ZmXvuzPl8kvOLMXsvZ87nnLkz852vcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsfDX7BaCHOSlBpw1tBNOkAOPwAhMI6AReCYwRUAjyHYNOGtoJ5wgBx6BEZhGQCPwTGCKgEaQ7Rpw1tBOOEEOPAIjMI2ARuCZwBQBjSDbNeCsoZ1wghx4BEZgGgGNwDOBKQIaQbZrwFlDO+EEOfAIjMA0AhqBZwJTBDSCbNeAs4Z2wgly4BEYgWkENALPBKYIaATZrgFnDe2EE+TAIzAC0whoBJ4JTBHQCLJdA84a2gknyIFHYASmEdAIPBOYIqARZLsGnDW0E06QA4/ACEwjoBF4JjBFQCPIdg04a2gnnCAHHoERmEZAI/BMYIqARpDtGnDW0E44QQ48AiMwjYBG4JnAFAGNINs14KyhnXCCHHgERmAaAY3AM4EpAhpBtmvAWUM74QQ58AiMwDQCGoFnAlMENIJs14CzhnbCCXLgERiBaQQ0As8EpghoBNmuAWcN7YQT5MAjMALTCGgEnglMEdAIsl0DzhraCSfIgUdgBKYR0Ag8E5gioBFkuwacNbQTTpADj8AITCOgEXgmMEVAI8h2DThraCecIAcegRGYRkAj8ExgioBGkO0acNbQTjhBDjwCIzCNgEbgmcAUAY0g2zXgrKGdcIIceARGYBoBjcAzgSkCGkG2a8BZQzvhBDnwCIzANAIagWcCUwQ0gmzXgLOGdsIJcuARGIFpBDQCzwSmCGgE2a4BZw3thBPkwCMwAtMIaASeCUwR0AiyXQPOGtoJJ8iBR2AEphHQCDwTmCKgEWS7Bpw1tBNOkAOPwAhMI6AReCYwRUAjyHYNOGtoJ5wgBx6BEZhGQCPwTGCKgEaQ7Rpw1tBOOEEOPALnW+Dm7jEBkYUbOiqW81mLCvKjBxrl6qcPyF83FeXJt3tk275BebdtWJq6xqJj0jt0TPqG34+uI0ej/7bv8Gj0/2ypH5BndvbKfVs7ZcGLHXLlE61y0d0N8vkFtUzgJNGWE4GrQ+ALltbL3Ofa5eXafin2j6faL/uGj8nOliFZub1b5jzbJrOXN8ip82oS+Xc4a2jLicB6Ap97a100XeuLo6LNsYnJaHqv3dUrf17XJucsrkNgBM4XSQl88fIG+fue/kiaamXVm90IjMD5YqYCn3dbnWzY3SeT1evtBzz0WhcCI3C+iCvwR+bsjk5Lh8YmJCvc9cphBEbgfBFH4NOuq4kuTGWNpZuKCIzAtgU+a1FB9rQPSxa5MebZhrOG9hXmUoL7wOULfPoNtZmVN3Dt+nYERmCbAn/8L3vk9f1HJMtc/fQBBEZgmwIv23xIss4Vq1sQGIHtCXzhXfuq+v5uqfxqRTMCI7A9gbc1DEoeuOTBRgRGYFsC/+zhJskL37unAYER2JbAm/cOVOy7tHSPyT9q+qNHHu/d2im3bSxGz1U/uK0zWoUUvktrT/xVZN++Yx8CI7Adgc++ZW+qv33D395U6JdLH2uWMxcWSpbrjPm10bLEIPiOliEp9SuG1VHcB87JfeCfPNQol61sTiX+8NSBxIo8rKZJ63uGCM8yf1iOwprbtAjPT4cGkcSxPHNhQf74zAF5s+nkt7m+HPPznDW05dSOLywsJFbobzUNqf070jh9Hj82Kb9/sjW173zB0nr527ZOOXKCZ7TDcYnzN501tAXSjjwIHB7cGBxNdqFCONX93er05PXTTrPDKXb/8LEPPj/uAn9nDW2BtCMPAn9tab0kzYo34i3n8zMUOVwQC5P/o3Pi/Q1nDW2BtCMPAoeHHpIknNKWc6HKJxxxL2CFcNbQFkg78iBwuDqdJC/u7lM/Lj5mOGtoJ1w78iDwPf8+LEnyp7Vt6sfFxwxnDe2Ea0ceBH709S5JknDbTvu4+JjhrKGdcO3Ig8BP7eiRJJkd8zFGXwXhrKGdcO3Ig8DPvtMrSfLrmCuBfBWEs4Z2wrUjDwKvfrNbkiQ8XKF9XHzMcNbQTrh25EHgIFzSOyeEV/JoHxsfI5w1tBOuHXkQOOnbSIGwF5L2sfExwllDO+HakQeBw0KHNAgbk2kfH19mOGtoJ1w78iBwWKWUFkHi8Ky19nHyJYazhnbCtSMPAoc4NHBU0mJX69BJlzL6KgpnDe2Ea0deBF6f8K2k6QyMTERrjk+5trqnsbOGdsK1Iy8Cp/U7eDphc+/wWWG/Je1j5xEYgfMi8Kfm1UjP0P/W06bN7rbhaBVUtYnsrKGdcO3Ii8Ah7t6S7KKGUgjbt1y2sjn2+l0ERmAEnrKZ2YleT1MJ6oujctWaVvUr1s4a2h1TO/I0gUOEV7tq0tw9Fu1FrHWxy1lDu+C0I28Cf3LunujtmNp09I3L9S90yCfmVlZkZw3tgtOOvAkc4uLlDdF7paqBtt7xaKfBj1Xo1NpZQ7vYtCOPAoeY+1y7VBP1xVH56UNNCIzACFyqxPe/muwqpSR4/t0+mXVTMi+JP1E4a2hPCu3I6wQ+HmGvompjYGRC5jybznu3nDW0C0w78i5weNDikYTfmZXk2y9PT3jdsbOGdoFpR94FnrpmuBo3/m7qGpPv3BlvJ0IERmAzAof4wX37pXMwvVVLcRken4i9off0cNbQLirtsCRwiHMW18n2xpPvDKjByPiE/PzhmV+ldtbQLijtsCZwiPDc8rzn22VI6bHLDyPcu/7lozOT2FlDu5i0w6LAx+PcW+vklbrktyWdCeFZ7m/e/h4CIzAClypy+P1ZODgi1UJz95h85nq2F2UCM4FLljisIpq7vj3VV/OUw+Pbu2NNYWcN7dM47bB8Cn2iCIsPwmqiorLIE5MiF91d/hYvzhraBaMdCHzivJx2XY3c/NLBir7lYzqvNRxBYARG4Jk0uPBbdMnGovQP64h84V3lPeThrKE9AbWDCVxank6fXyu3//OQDI5W9tbTk2XuEOGsoS2QdiBw+fkKq5wqtd64f/hYWS8FcNbQFkg7EDhe3r66pF42FSpzD/mSMh6zdNbQFkg7EHhm+fvNymbpPpLuFetlmw8hMAIjcFpNcNaigrz63mBqAoenxZjATGAmcIpnMqdcu0c27O5LReDGzlEERmAErsTTXBtr+xMXOFwwK3UHCGcN7d+g2sFv4GTz+bkFtan8Jj51XmnPRjtraAukHQicfE6XbT6UuMBfvLGAwAiMwJV6L3XShEbLBGYCM4ErIPCXbt6buMBh90UERmAEroDA5y+pT1Te8DK+Uj/bWaMSB7SaIw+/gc+7rS5662Slti/5fzH7nobEH6cs9bOdNbQPtnbkQeCvL3t/4r3dPDSj19EkFQs3dEiS1HaMlPzZzhraB1s78iTw8dPN8CL3M0u86JNGvHNgWJIkPCBS6mc7a2gLpB15E3jqy+Hu/Neh6L5sJb/LLx5pkqRZvuVwyZ/vrKEtkHbkVeCp+xA98GpndGEp7e9x1qKCtPeOS9L8dlULAiOwTYGnvmMqLAq49LHmkm/JlBPnL6lPZWPxycnSH+II4ayhUXDVFFYEnn56Hbb5vGJVi3z6uppE3p01mNKbOuqKpV/AQuAqEAqB0xd4KuGiV6FjRNa81RNt+fndO/eddMfAcKsqbM9y5ROt0etuwil6moTX+CAwE5gJXCZh25XwgvW9B0fk3bbhaBK29oxV7FU6x0+fwz1uBEZgBM4gbzTyWll+A/MbOLNcEmPLUWcN7d+g2mHxIlZep69HYH2hEBiBx45OyjdiPhLqrKEtkHYwgauPhRs6Yh9PZw1tgbQDgauLTYX+aANyBEZgBM4YO1uGogdDZtKQnTW0J6B2MIGrg+2NR+SM+TNfeOGsoS2QdiCwPuvf6S1r/yMERmAErgIGRiaizcSTbMjOGtoTUDvyMIG/cmtd9OhjVpiYFFm7q1fOvmVv4rlw1tAWSDvyIHCIcAr64wcb5d6tnbKjZaiizyyXSvhOz/+nT751R3qv/XHW0BZIO/Ii8PQIOxn88P79smRjUbbUD1R8Y+6p1LSPyOKXizLrpuQnLgJXQbEhcPo5CPdWw6L7yx9viXZOeGlPv9QXR2X06GTiK4hausdk3a5euWZdW9mriRCYCVxWEeR1Ape7Pej3722Qq9a0yvwXO6I1uCve6IpOd7e+NxhtHTo9Nu8diNYDh/duXf9CR7Q+ePbyBvnsDcm/7aOccNbQLh6CHHgERmAaAY3AM4EpAhpBtmvAWUM74QQ58AiMwDQCGoFnAlMENIJs14CzhnbCCXLgERiBaQQ0As8EpghoBNmuAWcN7YQT5MAjMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4bf4LtvMh68AvCz8AAAAASUVORK5CYII=",
  Cte = {
    hidden: { opacity: 0, y: -40 },
    visible: (n) => ({
      opacity: 1,
      y: 0,
      transition: { delay: n * 0.1, duration: 0.6, type: "spring" },
    }),
  },
  bte = [
    {
      name: "Ozair JK",
      subscribers: "1.11M subscribers",
      followers: "350k+ followers",
      image: "2swag.jpg",
    },
    {
      name: "Switch and Click",
      subscribers: "950K+ subscribers",
      followers: "43.1k+ followers",
      image: "SNK.jpg",
    },
    {
      name: "Justin Lalonde",
      subscribers: "24.6K subscribers",
      followers: "",
      image: "Justin.jpg",
    },
  ],
  Rte = () =>
    Dt("section", {
      className: "mt-10",
      children: [
        _e("h2", {
          className: "text-white text-3xl font-bold text-center mb-8",
          children: "TRUSTED BY",
        }),
        _e("div", {
          className: "flex flex-wrap justify-center gap-10",
          children: bte.map((n, e) => {
            const t = new URL(
              Object.assign({
                "../assets/tech/2swag.jpg": pte,
                "../assets/tech/SNK.jpg": Ste,
                "../assets/tech/Justin.jpg": Tte,
                "../assets/tech/ae.png": Kee,
                "../assets/tech/ai.png": Qee,
                "../assets/tech/aws.png": Zee,
                "../assets/tech/css.png": qee,
                "../assets/tech/cutting.jpg": $ee,
                "../assets/tech/docker.png": ete,
                "../assets/tech/enrico.png": tte,
                "../assets/tech/express.png": nte,
                "../assets/tech/fi.png": ite,
                "../assets/tech/figma.png": rte,
                "../assets/tech/framer.png": ste,
                "../assets/tech/git.png": ote,
                "../assets/tech/gsap.png": ate,
                "../assets/tech/html.png": lte,
                "../assets/tech/javascript.png": ute,
                "../assets/tech/mongodb.png": cte,
                "../assets/tech/mui.png": fte,
                "../assets/tech/mysql.png": hte,
                "../assets/tech/nodejs.png": dte,

                "../assets/tech/postgresql.png": mte,
                "../assets/tech/pr.png": gte,
                "../assets/tech/ps.png": vte,
                "../assets/tech/reactjs.png": yte,
                "../assets/tech/redux.png": _te,
                "../assets/tech/saqlain.jpg": xte,
                "../assets/tech/sarthak.png": Ate,
                "../assets/tech/SNK.jpg": Ste,
                "../assets/tech/tailwind.png": Mte,
                "../assets/tech/threejs.svg": wte,
                "../assets/tech/typescript.png": Ete,
              })[`../assets/tech/${n.image}`],
              self.location
            ).href;
            return Dt(
              D_.div,
              {
                className: "flex flex-col items-center text-center",
                variants: Cte,
                initial: "hidden",
                whileInView: "visible",
                viewport: { once: !0 },
                custom: e,
                children: [
                  _e("div", {
                    className:
                      "w-28 h-28 rounded-full overflow-hidden border-2 border-white shadow-lg",
                    children: _e("img", {
                      src: t,
                      alt: n.name,
                      className: "w-full h-full object-cover",
                    }),
                  }),
                  _e("h3", {
                    className: "text-white text-[16px] font-semibold mt-3",
                    children: n.name,
                  }),
                  _e("p", {
                    className: "text-sm text-gray-400",
                    children: n.subscribers,
                  }),
                  n.followers &&
                    _e("p", {
                      className: "text-sm text-gray-400",
                      children: n.followers,
                    }),
                ],
              },
              n.name
            );
          }),
        }),
      ],
    });
Hc.registerPlugin(Gt);
const Sz = (n, e, t = 0) => {
    j.useEffect(() => {
      n.current &&
        Hc.fromTo(n.current, e.from, {
          ...e.to,
          delay: t,
          scrollTrigger: {
            trigger: n.current,
            start: "top 85%",
            toggleActions: "play none none reverse",
          },
        });
    }, [n, e, t]);
  },
  Pte = ({ experience: n, index: e }) => {
    const t = j.useRef(null);
    return (
      Sz(
        t,
        {
          from: { opacity: 0, y: 100 },
          to: { opacity: 1, y: 0, duration: 1.2, ease: "power3.out" },
        },
        e * 0.2
      ),
      Dt("div", {
        ref: t,
        className:
          "bg-tertiary p-6 rounded-2xl w-full max-w-4xl mx-auto shadow-md",
        children: [
          Dt("div", {
            className: "flex items-center gap-4 mb-4",
            children: [
              _e("div", {
                className:
                  "w-16 h-16 rounded-full bg-white flex items-center justify-center overflow-hidden border-2 border-[#915EFF]",
                children: _e("img", {
                  src: n.icon,
                  alt: n.company_name,
                  className: "w-full h-full object-cover",
                }),
              }),
              Dt("div", {
                children: [
                  _e("h3", {
                    className: "text-white text-xl font-bold",
                    children: n.title,
                  }),
                  _e("p", {
                    className: "text-secondary text-sm",
                    children: n.company_name,
                  }),
                  _e("p", {
                    className: "text-secondary text-xs mt-1",
                    children: n.date,
                  }),
                ],
              }),
            ],
          }),
          _e("ul", {
            className: "list-disc ml-5 space-y-2 text-white text-sm",
            children: n.points.map((i, r) =>
              _e("li", { className: "pl-1", children: i }, `exp-point-${r}`)
            ),
          }),
        ],
      })
    );
  },
  Bte = () => {
    const n = j.useRef(null);
    return (
      Sz(n, {
        from: { opacity: 0, x: -50 },
        to: { opacity: 1, x: 0, duration: 1, ease: "power2.out" },
      }),
      Dt(N4, {
        children: [
          Dt("div", {
            ref: n,
            children: [
              _e("p", {
                className: pi.sectionSubText,
                children: "What I have done so far",
              }),
              _e("h2", {
                className: pi.sectionHeadText,
                children: "Work Experience.",
              }),
            ],
          }),
          _e("div", {
            className: "mt-16 flex flex-col gap-10",
            children: tK.map((e, t) =>
              _e(Pte, { experience: e, index: t }, `exp-${t}`)
            ),
          }),
        ],
      })
    );
  },
  Ite = og(Bte, "work"),
  Dte = [
    {
      id: 1,
      title: "",
      url: "https://www.youtube.com/embed/yqRFA9wq4qM?rel=0",

      aspect: "16:9",
    },

    {
      id: 2,
      title: "",
      url: "https://www.youtube.com/embed/RkSeFmiq-wI?rel=0",
      aspect: "16:9",
    },
    {
      id: 3,
      title: "",
      url: "https://www.youtube.com/embed/jaP1zkkaByw?rel=0",
      aspect: "16:9",
    },
    {
      id: 4,
      title: "",
      url: "https://www.youtube.com/embed/gDtknyX2p1w?rel=0",
      aspect: "16:9",
    },
  ],
  Lte = [
    {
      id: 1,
      title: "",
      url: "https://www.youtube.com/embed/Hjmz4GveJ6g",
      aspect: "9:16",
    },
    {
      id: 2,
      title: "",
      url: "https://www.youtube.com/embed/7MF38ZOQJ4s",
      aspect: "9:16",
    },
    {
      id: 3,
      title: "",
      url: "https://www.youtube.com/embed/Y_LDN_r4drg",
      aspect: "9:16",
    },
    {
      id: 4,
      title: "",
      url: "https://www.youtube.com/embed/9i_0qigCWJE",
      aspect: "9:16",
    },
  ],
  HD = ({ url: n, title: e, aspect: t }) =>
    _e("div", {
      style: {
        width: "100%",
        maxWidth: t === "9:16" ? "260px" : "520px",
        margin: "0 auto", //  centers horizontally
        display: "flex", //  enables centering
        justifyContent: "center", //  horizontally centers inner div
      },
      children: _e("div", {
        style: {
          position: "relative",
          width: "100%",
          paddingTop: t === "9:16" ? "177.78%" : "56.25%",
          overflow: "hidden",
          borderRadius: "12px",
          backgroundColor: "#000",
        },
        children: _e("iframe", {
          src: n,
          title: e,
          allow:
            "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
          allowFullScreen: !0,
          style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            border: "none",
            borderRadius: "12px",
          },
        }),
      }),
    }),
  Fte = () =>
    Dt("div", {
      id: "",
      children: [
        Dt("div", {
          children: [
            _e("p", { className: `${pi.sectionSubText}` }),
            _e("h2", { className: `${pi.sectionHeadText}` }),
          ],
        }),
        _e("div", {
          className: "w-full flex",
          children: _e("p", {
            className:
              "mt-3 text-secondary text-[17px] max-w-3xl leading-[30px]",
          }),
        }),
        Dt("div", {
          className: "mt-16 text-center",
          children: [
            _e("h2", {
              className: `${pi.sectionHeadText} mb-6`,
              children: "YouTube Videos",
            }),
            _e("div", {
              className: "flex flex-wrap gap-6",
              children: Dte.map((n) => _e(HD, { ...n }, n.id)),
            }),
          ],
        }),
        Dt("div", {
          className: "mt-16 text-center",
          children: [
            _e("h2", {
              className: `${pi.sectionHeadText} mb-6`,
              children: "Reels and Shorts",
            }),
            _e("div", {
              className: "flex flex-wrap gap-6",
              children: Lte.map((n) => _e(HD, { ...n }, n.id)),
            }),
          ],
        }),
      ],
    }),
  Nte = og(Fte, "projects");
Hc.registerPlugin(Gt);
const Ote = ({
    index: n,
    testimonial: e,
    name: t,
    designation: i,
    company: r,
    image: s,
  }) => {
    const o = zr.useRef(null);
    return (
      j.useEffect(() => {
        const a = o.current;
        Hc.fromTo(
          a,
          { opacity: 0, y: 100 },
          {
            opacity: 1,
            y: 0,
            scrollTrigger: {
              trigger: a,
              start: "top bottom",
              end: "top center",
              scrub: !0,
              markers: !1,
            },
          }
        );
      }, []),
      Dt("div", {
        ref: o,
        className: "bg-black-200 p-6 rounded-3xl xs:w-[280px] w-full",
        children: [
          _e("p", {
            className: "text-white font-black text-[36px]",
            children: '"',
          }),
          Dt("div", {
            className: "mt-1",
            children: [
              _e("p", {
                className: "text-white tracking-wider text-[16px]",
                children: e,
              }),
              Dt("div", {
                className: "mt-7 flex justify-between items-center gap-1",
                children: [
                  Dt("div", {
                    className: "flex-1 flex flex-col",
                    children: [
                      Dt("p", {
                        className: "text-white font-medium text-[14px]",
                        children: [
                          _e("span", {
                            className: "blue-text-gradient",
                            children: "@",
                          }),
                          " ",
                          t,
                        ],
                      }),
                      Dt("p", {
                        className: "mt-1 text-secondary text-[11px]",
                        children: [i, " of ", r],
                      }),
                    ],
                  }),
                  _e("img", {
                    src: s,
                    alt: `feedback_by-${t}`,
                    className: "w-10 h-10 rounded-full object-cover",
                  }),
                ],
              }),
            ],
          }),
        ],
      })
    );
  },
  Ute = () =>
    Dt("div", {
      id: "testimonials",
      className: "mt-12 bg-black-100 rounded-[20px]",
      children: [
        _e("div", {
          className: `bg-tertiary rounded-2xl ${pi.padding} min-h-[300px]`,
          children: Dt("div", {
            children: [
              _e("p", {
                className: pi.sectionSubText,
                children: "What others say",
              }),
              _e("h2", {
                className: pi.sectionHeadText,
                children: "Testimonials.",
              }),
            ],
          }),
        }),
        _e("div", {
          className: `-mt-20 pb-14 ${pi.paddingX} grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-10 justify-items-center`,
          children: nK.map((n, e) => _e(Ote, { index: e, ...n }, n.name)),
        }),
      ],
    }),
  kte = og(Ute, "testimonials"),
  Im = { _origin: "https://api.emailjs.com" },
  zte = (n, e = "https://api.emailjs.com") => {
    (Im._userID = n), (Im._origin = e);
  },
  Mz = (n, e, t) => {
    if (!n)
      throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account";
    if (!e)
      throw "The service ID is required. Visit https://dashboard.emailjs.com/admin";
    if (!t)
      throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates";
    return !0;
  };
class GD {
  constructor(e) {
    (this.status = e ? e.status : 0),
      (this.text = e ? e.responseText : "Network Error");
  }
}
const wz = (n, e, t = {}) =>
    new Promise((i, r) => {
      const s = new XMLHttpRequest();
      s.addEventListener("load", ({ target: o }) => {
        const a = new GD(o);
        a.status === 200 || a.text === "OK" ? i(a) : r(a);
      }),
        s.addEventListener("error", ({ target: o }) => {
          r(new GD(o));
        }),
        s.open("POST", Im._origin + n, !0),
        Object.keys(t).forEach((o) => {
          s.setRequestHeader(o, t[o]);
        }),
        s.send(e);
    }),
  Hte = (n, e, t, i) => {
    const r = i || Im._userID;
    return (
      Mz(r, n, e),
      wz(
        "/api/v1.0/email/send",
        JSON.stringify({
          lib_version: "3.12.1",
          user_id: r,
          service_id: n,
          template_id: e,
          template_params: t,
        }),
        { "Content-type": "application/json" }
      )
    );
  },
  Gte = (n) => {
    let e;
    if (
      (typeof n == "string" ? (e = document.querySelector(n)) : (e = n),
      !e || e.nodeName !== "FORM")
    )
      throw "The 3rd parameter is expected to be the HTML form element or the style selector of form";
    return e;
  },
  Vte = (n, e, t, i) => {
    const r = i || Im._userID,
      s = Gte(t);
    Mz(r, n, e);
    const o = new FormData(s);
    return (
      o.append("lib_version", "3.12.1"),
      o.append("service_id", n),
      o.append("template_id", e),
      o.append("user_id", r),
      wz("/api/v1.0/email/send-form", o)
    );
  },
  Wte = { init: zte, send: Hte, sendForm: Vte },
  Xte = () => {
    const n = j.useRef(),
      [e, t] = j.useState({ name: "", email: "", message: "" }),
      [i, r] = j.useState(!1),
      s = (a) => {
        const { target: l } = a,
          { name: u, value: c } = l;
        t({ ...e, [u]: c });
      },
      o = (a) => {
        a.preventDefault(),
          r(!0),
          Wte.send(
            "service_0ff3jkl",
            "template_eb3twqc",
            {
              from_name: e.name,
              to_name: "Amra",
              from_email: e.email,
              to_email: "hireamra@gmail.com",
              message: e.message,
            },
            "RFHzJ7q5BL-ybCBJH"
          ).then(
            () => {
              r(!1),
                alert("Thank you. I will get back to you as soon as possible."),
                t({ name: "", email: "", message: "" });
            },
            (l) => {
              r(!1),
                console.error(l),
                alert("Ahh, something went wrong. Please try again.");
            }
          );
      };
    return Dt("div", {
      className:
        "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden",
      children: [
        Dt(D_.div, {
          variants: kD("left", "tween", 0.2, 1),
          className: "flex-[0.75] bg-black-100 p-8 rounded-2xl",
          children: [
            _e("p", { className: pi.sectionSubText, children: "Get in touch" }),
            _e("h3", { className: pi.sectionHeadText, children: "Contact." }),
            Dt("form", {
              ref: n,
              onSubmit: o,
              className: "mt-12 flex flex-col gap-8",
              children: [
                Dt("label", {
                  className: "flex flex-col",
                  children: [
                    _e("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Name",
                    }),
                    _e("input", {
                      type: "text",
                      name: "name",
                      value: e.name,
                      onChange: s,
                      placeholder: "Enter your name",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                      required: !0,
                    }),
                  ],
                }),
                Dt("label", {
                  className: "flex flex-col",
                  children: [
                    _e("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Email",
                    }),
                    _e("input", {
                      type: "email",
                      name: "email",
                      value: e.email,
                      onChange: s,
                      placeholder: "Enter your email",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                      required: !0,
                    }),
                  ],
                }),
                Dt("label", {
                  className: "flex flex-col",
                  children: [
                    _e("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Message",
                    }),
                    _e("textarea", {
                      rows: 7,
                      name: "message",
                      value: e.message,
                      onChange: s,
                      placeholder: "Write your message...",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                      required: !0,
                    }),
                  ],
                }),
                _e("button", {
                  type: "submit",
                  className:
                    "bg-tertiary py-3 px-8 rounded-xl outline-none w-fit text-white font-bold shadow-md shadow-primary",
                  children: i ? "Sending..." : "Send",
                }),
              ],
            }),
          ],
        }),
        _e(D_.div, {
          variants: kD("right", "tween", 0.2, 1),
          className: "xl:flex-1 xl:h-auto md:h-[550px] h-[350px]",
          children: _e(RY, {}),
        }),
      ],
    });
  },
  Jte = og(Xte, "contact");
function jte(n) {
  return tg({
    tag: "svg",
    attr: { viewBox: "0 0 448 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z",
        },
        child: [],
      },
    ],
  })(n);
}
function Yte(n) {
  return tg({
    tag: "svg",
    attr: { viewBox: "0 0 576 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M549.655 124.083c-6.281-23.673-24.797-42.276-48.403-48.564C458.469 64 288 64 288 64s-170.469 0-213.252 11.519c-23.606 6.288-42.122 24.891-48.403 48.564C16 166.889 16 256.037 16 256.037s0 89.148 10.345 131.954c6.281 23.673 24.797 42.276 48.403 48.564C117.531 448 288 448 288 448s170.469 0 213.252-11.519c23.606-6.288 42.122-24.891 48.403-48.564C560 345.185 560 256.037 560 256.037s0-89.148-10.345-131.954zM232 338.5v-165l142 82.5-142 82.5z",
        },
        child: [],
      },
    ],
  })(n);
}
function Kte(n) {
  return tg({
    tag: "svg",
    attr: { viewBox: "0 0 512 512" },
    child: [
      {
        tag: "path",
        attr: {
          d: "M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z",
        },
        child: [],
      },
    ],
  })(n);
}
const Qte = () =>
    Dt("footer", {
      className:
        "w-full py-4 bg-black-100/55 text-white flex justify-center gap-6",
      children: [
        _e("a", {
          href: "https://x.com/amraedits",
          target: "_blank",
          rel: "noopener noreferrer",
          children: _e(Kte, { size: 24 }),
        }),
        _e("a", {
          href: "https://www.youtube.com/@amraedits",
          target: "_blank",
          rel: "noopener noreferrer",
          children: _e(Yte, { size: 24 }),
        }),
        _e("a", {
          href: "https://www.instagram.com/amraedits",
          target: "_blank",
          rel: "noopener noreferrer",
          children: _e(jte, { size: 24 }),
        }),
      ],
    }),
  Zte = () =>
    _e(hV, {
      children: Dt("div", {
        className: "relative z-0 bg-primary",
        children: [
          Dt("div", {
            className: "bg-hero-pattern bg-cover bg-no-repeat bg-center",
            children: [
              _e(iK, {}),
              _e(HY, {}),
              //  Inserted video section
              Dt("div", {
                className: "flex justify-center mt-12 px-4 md:px-8",
                id: "about",
                children: _e("iframe", {
                  src: "https://www.youtube.com/embed/en7ElyWvjxo?start=1377&rel=0",
                  title: "Intro Video",
                  allow:
                    "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                  allowFullScreen: !0,
                  style: {
                    width: "100%",
                    maxWidth: "1080px",
                    aspectRatio: "16/9",
                    border: "none",
                    borderRadius: "12px",
                  },
                }),
              }),
            ],
          }),
          // _e(Yee, {}),
          // _e(Ite, {}),
          _e(Rte, {}),
          _e(Nte, {}),
          _e(kte, {}),
          Dt("div", {
            className: "relative z-0",
            children: [_e(Jte, {}), _e(UY, {}), _e(Qte, {})],
          }),
        ],
      }),
    });
QS.createRoot(document.getElementById("root")).render(
  _e(zr.StrictMode, { children: _e(Zte, {}) })
);
